import { glob } from "glob";
import { Herb } from "@herb-tools/node-wasm";
import { existsSync, statSync } from "fs";
import { dirname, resolve, relative } from "path";
import { ArgumentParser } from "./cli/argument-parser.js";
import { FileProcessor } from "./cli/file-processor.js";
import { OutputManager } from "./cli/output-manager.js";
export * from "./cli/index.js";
export class CLI {
    argumentParser = new ArgumentParser();
    fileProcessor = new FileProcessor();
    outputManager = new OutputManager();
    projectPath = process.cwd();
    getProjectPath() {
        return this.projectPath;
    }
    findProjectRoot(startPath) {
        let currentPath = resolve(startPath);
        if (existsSync(currentPath) && statSync(currentPath).isFile()) {
            currentPath = dirname(currentPath);
        }
        const projectIndicators = [
            'package.json',
            'Gemfile',
            '.git',
            'tsconfig.json',
            'composer.json',
            'pyproject.toml',
            'requirements.txt',
            '.herb.yml'
        ];
        while (currentPath !== '/') {
            for (const indicator of projectIndicators) {
                if (existsSync(resolve(currentPath, indicator))) {
                    return currentPath;
                }
            }
            const parentPath = dirname(currentPath);
            if (parentPath === currentPath) {
                break;
            }
            currentPath = parentPath;
        }
        return existsSync(startPath) && statSync(startPath).isDirectory()
            ? startPath
            : dirname(startPath);
    }
    exitWithError(message, formatOption, exitCode = 1) {
        this.outputManager.outputError(message, {
            formatOption,
            theme: 'auto',
            wrapLines: false,
            truncateLines: false,
            showTiming: false,
            useGitHubActions: false,
            startTime: 0,
            startDate: new Date()
        });
        process.exit(exitCode);
    }
    exitWithInfo(message, formatOption, exitCode = 0, timingData) {
        const outputOptions = {
            formatOption,
            theme: 'auto',
            wrapLines: false,
            truncateLines: false,
            showTiming: timingData?.showTiming ?? false,
            useGitHubActions: false,
            startTime: timingData?.startTime ?? Date.now(),
            startDate: timingData?.startDate ?? new Date()
        };
        this.outputManager.outputInfo(message, outputOptions);
        process.exit(exitCode);
    }
    determineProjectPath(pattern) {
        if (pattern) {
            const resolvedPattern = resolve(pattern);
            if (existsSync(resolvedPattern)) {
                const stats = statSync(resolvedPattern);
                if (stats.isDirectory()) {
                    this.projectPath = resolvedPattern;
                }
                else {
                    this.projectPath = this.findProjectRoot(resolvedPattern);
                }
            }
        }
    }
    adjustPattern(pattern) {
        if (!pattern) {
            return '**/*.html.erb';
        }
        const resolvedPattern = resolve(pattern);
        if (existsSync(resolvedPattern)) {
            const stats = statSync(resolvedPattern);
            if (stats.isDirectory()) {
                return '**/*.html.erb';
            }
            else if (stats.isFile()) {
                return relative(this.projectPath, resolvedPattern);
            }
        }
        return pattern;
    }
    async beforeProcess() {
        // Hook for subclasses to add custom output before processing
    }
    async afterProcess(_results, _outputOptions) {
        // Hook for subclasses to add custom output after processing
    }
    async run() {
        await Herb.load();
        const startTime = Date.now();
        const startDate = new Date();
        let { pattern, formatOption, showTiming, theme, wrapLines, truncateLines, useGitHubActions } = this.argumentParser.parse(process.argv);
        this.determineProjectPath(pattern);
        pattern = this.adjustPattern(pattern);
        const outputOptions = {
            formatOption,
            theme,
            wrapLines,
            truncateLines,
            showTiming,
            useGitHubActions,
            startTime,
            startDate
        };
        try {
            await this.beforeProcess();
            const files = await glob(pattern, { cwd: this.projectPath });
            if (files.length === 0) {
                this.exitWithInfo(`No files found matching pattern: ${pattern}`, formatOption, 0, { startTime, startDate, showTiming });
            }
            const context = {
                projectPath: this.projectPath,
                pattern: pattern
            };
            const results = await this.fileProcessor.processFiles(files, formatOption, context);
            await this.outputManager.outputResults({ ...results, files }, outputOptions);
            await this.afterProcess(results, outputOptions);
            if (results.totalErrors > 0) {
                process.exit(1);
            }
        }
        catch (error) {
            this.exitWithError(`Error: ${error}`, formatOption);
        }
    }
}
//# sourceMappingURL=cli.js.map