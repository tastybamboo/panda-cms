import { Visitor, Position, Location, getStaticAttributeName, hasDynamicAttributeName as hasNodeDynamicAttributeName, getCombinedAttributeName, hasERBOutput, getStaticContentFromNodes, hasStaticContent, isEffectivelyStatic, getValidatableStaticContent } from "@herb-tools/core";
import { DEFAULT_LINT_CONTEXT } from "../types.js";
export var ControlFlowType;
(function (ControlFlowType) {
    ControlFlowType[ControlFlowType["CONDITIONAL"] = 0] = "CONDITIONAL";
    ControlFlowType[ControlFlowType["LOOP"] = 1] = "LOOP";
})(ControlFlowType || (ControlFlowType = {}));
/**
 * Base visitor class that provides common functionality for rule visitors
 */
export class BaseRuleVisitor extends Visitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        super();
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create a lint offense
     */
    createOffense(message, location, severity = "error") {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            severity,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, severity = "error") {
        this.offenses.push(this.createOffense(message, location, severity));
    }
}
/**
 * Mixin that adds control flow tracking capabilities to rule visitors
 * This allows rules to track state across different control flow structures
 * like if/else branches, loops, etc.
 *
 * @template TControlFlowState - Type for state passed between onEnterControlFlow and onExitControlFlow
 * @template TBranchState - Type for state passed between onEnterBranch and onExitBranch
 */
export class ControlFlowTrackingVisitor extends BaseRuleVisitor {
    isInControlFlow = false;
    currentControlFlowType = null;
    /**
     * Handle visiting a control flow node with proper scope management
     */
    handleControlFlowNode(node, controlFlowType, visitChildren) {
        const wasInControlFlow = this.isInControlFlow;
        const previousControlFlowType = this.currentControlFlowType;
        this.isInControlFlow = true;
        this.currentControlFlowType = controlFlowType;
        const stateToRestore = this.onEnterControlFlow(controlFlowType, wasInControlFlow);
        visitChildren();
        this.onExitControlFlow(controlFlowType, wasInControlFlow, stateToRestore);
        this.isInControlFlow = wasInControlFlow;
        this.currentControlFlowType = previousControlFlowType;
    }
    /**
     * Handle visiting a branch node (like else, when) with proper scope management
     */
    startNewBranch(visitChildren) {
        const stateToRestore = this.onEnterBranch();
        visitChildren();
        this.onExitBranch(stateToRestore);
    }
    visitERBIfNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBIfNode(node));
    }
    visitERBUnlessNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBUnlessNode(node));
    }
    visitERBCaseNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBCaseNode(node));
    }
    visitERBCaseMatchNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBCaseMatchNode(node));
    }
    visitERBWhileNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBWhileNode(node));
    }
    visitERBForNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBForNode(node));
    }
    visitERBUntilNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBUntilNode(node));
    }
    visitERBBlockNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBBlockNode(node));
    }
    visitERBElseNode(node) {
        this.startNewBranch(() => super.visitERBElseNode(node));
    }
    visitERBWhenNode(node) {
        this.startNewBranch(() => super.visitERBWhenNode(node));
    }
}
/**
 * Gets attributes from an HTMLOpenTagNode
 */
export function getAttributes(node) {
    return node.children.filter(node => node.type === "AST_HTML_ATTRIBUTE_NODE");
}
/**
 * Gets the tag name from an HTML tag node (lowercased)
 */
export function getTagName(node) {
    return node.tag_name?.value.toLowerCase() || null;
}
/**
 * Gets the attribute name from an HTMLAttributeNode (lowercased)
 * Returns null if the attribute name contains dynamic content (ERB)
 */
export function getAttributeName(attributeNode, lowercase = true) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        const staticName = getStaticAttributeName(nameNode);
        if (!lowercase)
            return staticName;
        return staticName ? staticName.toLowerCase() : null;
    }
    return null;
}
/**
 * Checks if an attribute has a dynamic (ERB-containing) name
 */
export function hasDynamicAttributeName(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        return hasNodeDynamicAttributeName(nameNode);
    }
    return false;
}
/**
 * Gets the combined string representation of an attribute name (for debugging)
 * This includes both static content and ERB syntax
 */
export function getCombinedAttributeNameString(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        return getCombinedAttributeName(nameNode);
    }
    return "";
}
/**
 * Checks if an attribute value contains only static content (no ERB)
 */
export function hasStaticAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (!valueNode?.children)
        return false;
    return valueNode.children.every(child => child.type === "AST_LITERAL_NODE");
}
/**
 * Checks if an attribute value contains dynamic content (ERB)
 */
export function hasDynamicAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (!valueNode?.children)
        return false;
    return valueNode.children.some(child => child.type === "AST_ERB_CONTENT_NODE");
}
/**
 * Gets the static string value of an attribute (returns null if it contains ERB)
 */
export function getStaticAttributeValue(attributeNode) {
    if (!hasStaticAttributeValue(attributeNode))
        return null;
    const valueNode = attributeNode.value;
    const result = valueNode.children
        ?.filter(child => child.type === "AST_LITERAL_NODE")
        .map(child => child.content)
        .join("") || "";
    return result;
}
/**
 * Gets the value nodes array for dynamic inspection
 */
export function getAttributeValueNodes(attributeNode) {
    const valueNode = attributeNode.value;
    return valueNode?.children || [];
}
/**
 * Checks if an attribute value contains any static content (for validation purposes)
 */
export function hasStaticAttributeValueContent(attributeNode) {
    const valueNodes = getAttributeValueNodes(attributeNode);
    return hasStaticContent(valueNodes);
}
/**
 * Gets the static content of an attribute value (all literal parts combined)
 * Returns the concatenated literal content, or null if no literal nodes exist
 */
export function getStaticAttributeValueContent(attributeNode) {
    const valueNodes = getAttributeValueNodes(attributeNode);
    return getStaticContentFromNodes(valueNodes);
}
/**
 * Gets the attribute value content from an HTMLAttributeValueNode
 */
export function getAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (valueNode === null)
        return null;
    if (valueNode.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE" || !valueNode.children?.length) {
        return null;
    }
    let result = "";
    for (const child of valueNode.children) {
        switch (child.type) {
            case "AST_ERB_CONTENT_NODE": {
                const erbNode = child;
                if (erbNode.content) {
                    result += `${erbNode.tag_opening?.value}${erbNode.content.value}${erbNode.tag_closing?.value}`;
                }
                break;
            }
            case "AST_LITERAL_NODE": {
                result += child.content;
                break;
            }
        }
    }
    return result;
}
/**
 * Checks if an attribute has a value
 */
export function hasAttributeValue(attributeNode) {
    return attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE";
}
/**
 * Gets the quote type used for an attribute value
 */
export function getAttributeValueQuoteType(nodeOrAttribute) {
    let valueNode;
    if (nodeOrAttribute.type === "AST_HTML_ATTRIBUTE_NODE") {
        const attributeNode = nodeOrAttribute;
        if (attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
            valueNode = attributeNode.value;
        }
    }
    else if (nodeOrAttribute.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
        valueNode = nodeOrAttribute;
    }
    if (valueNode) {
        if (valueNode.quoted && valueNode.open_quote) {
            return valueNode.open_quote.value === '"' ? "double" : "single";
        }
        return "none";
    }
    return null;
}
/**
 * Finds an attribute by name in a list of attributes
 */
export function findAttributeByName(attributes, attributeName) {
    for (const child of attributes) {
        if (child.type === "AST_HTML_ATTRIBUTE_NODE") {
            const attributeNode = child;
            const name = getAttributeName(attributeNode);
            if (name === attributeName.toLowerCase()) {
                return attributeNode;
            }
        }
    }
    return null;
}
/**
 * Checks if a tag has a specific attribute
 */
export function hasAttribute(node, attributeName) {
    return getAttribute(node, attributeName) !== null;
}
/**
 * Checks if a tag has a specific attribute
 */
export function getAttribute(node, attributeName) {
    const attributes = getAttributes(node);
    return findAttributeByName(attributes, attributeName);
}
/**
 * Common HTML element categorization
 */
export const HTML_INLINE_ELEMENTS = new Set([
    "a", "abbr", "acronym", "b", "bdo", "big", "br", "button", "cite", "code",
    "dfn", "em", "i", "img", "input", "kbd", "label", "map", "object", "output",
    "q", "samp", "script", "select", "small", "span", "strong", "sub", "sup",
    "textarea", "time", "tt", "var"
]);
export const HTML_BLOCK_ELEMENTS = new Set([
    "address", "article", "aside", "blockquote", "canvas", "dd", "div", "dl",
    "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2",
    "h3", "h4", "h5", "h6", "header", "hr", "li", "main", "nav", "noscript",
    "ol", "p", "pre", "section", "table", "tfoot", "ul", "video"
]);
export const HTML_VOID_ELEMENTS = new Set([
    "area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta",
    "param", "source", "track", "wbr",
]);
export const HTML_BOOLEAN_ATTRIBUTES = new Set([
    "autofocus", "autoplay", "checked", "controls", "defer", "disabled", "hidden",
    "loop", "multiple", "muted", "readonly", "required", "reversed", "selected",
    "open", "default", "formnovalidate", "novalidate", "itemscope", "scoped",
    "seamless", "allowfullscreen", "async", "compact", "declare", "nohref",
    "noresize", "noshade", "nowrap", "sortable", "truespeed", "typemustmatch"
]);
export const HEADING_TAGS = new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
/**
 * SVG elements that use camelCase naming
 */
export const SVG_CAMEL_CASE_ELEMENTS = new Set([
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
]);
/**
 * Mapping from lowercase SVG element names to their correct camelCase versions
 * Generated dynamically from SVG_CAMEL_CASE_ELEMENTS
 */
export const SVG_LOWERCASE_TO_CAMELCASE = new Map(Array.from(SVG_CAMEL_CASE_ELEMENTS).map(element => [element.toLowerCase(), element]));
export const VALID_ARIA_ROLES = new Set([
    "banner", "complementary", "contentinfo", "form", "main", "navigation", "region", "search",
    "article", "cell", "columnheader", "definition", "directory", "document", "feed", "figure",
    "group", "heading", "img", "list", "listitem", "math", "none", "note", "presentation",
    "row", "rowgroup", "rowheader", "separator", "table", "term", "tooltip",
    "alert", "alertdialog", "button", "checkbox", "combobox", "dialog", "grid", "gridcell", "link",
    "listbox", "menu", "menubar", "menuitem", "menuitemcheckbox", "menuitemradio", "option",
    "progressbar", "radio", "radiogroup", "scrollbar", "searchbox", "slider", "spinbutton",
    "status", "switch", "tab", "tablist", "tabpanel", "textbox", "timer", "toolbar", "tree",
    "treegrid", "treeitem",
    "log", "marquee"
]);
export const ARIA_ATTRIBUTES = new Set([
    'aria-activedescendant',
    'aria-atomic',
    'aria-autocomplete',
    'aria-busy',
    'aria-checked',
    'aria-colcount',
    'aria-colindex',
    'aria-colspan',
    'aria-controls',
    'aria-current',
    'aria-describedby',
    'aria-details',
    'aria-disabled',
    'aria-dropeffect',
    'aria-errormessage',
    'aria-expanded',
    'aria-flowto',
    'aria-grabbed',
    'aria-haspopup',
    'aria-hidden',
    'aria-invalid',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-level',
    'aria-live',
    'aria-modal',
    'aria-multiline',
    'aria-multiselectable',
    'aria-orientation',
    'aria-owns',
    'aria-placeholder',
    'aria-posinset',
    'aria-pressed',
    'aria-readonly',
    'aria-relevant',
    'aria-required',
    'aria-roledescription',
    'aria-rowcount',
    'aria-rowindex',
    'aria-rowspan',
    'aria-selected',
    'aria-setsize',
    'aria-sort',
    'aria-valuemax',
    'aria-valuemin',
    'aria-valuenow',
    'aria-valuetext',
]);
/**
 * Helper function to create a location at the end of the source with a 1-character range
 */
export function createEndOfFileLocation(source) {
    const lines = source.split('\n');
    const lastLineNumber = lines.length;
    const lastLine = lines[lines.length - 1];
    const lastColumnNumber = lastLine.length;
    const startColumn = lastColumnNumber > 0 ? lastColumnNumber - 1 : 0;
    const start = new Position(lastLineNumber, startColumn);
    const end = new Position(lastLineNumber, lastColumnNumber);
    return new Location(start, end);
}
/**
 * Checks if an element is inline
 */
export function isInlineElement(tagName) {
    return HTML_INLINE_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an element is block-level
 */
export function isBlockElement(tagName) {
    return HTML_BLOCK_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an element is a void element
 */
export function isVoidElement(tagName) {
    return HTML_VOID_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an attribute is a boolean attribute
 */
export function isBooleanAttribute(attributeName) {
    return HTML_BOOLEAN_ATTRIBUTES.has(attributeName.toLowerCase());
}
/**
 * Attribute visitor that provides granular processing based on both
 * attribute name type (static/dynamic) and value type (static/dynamic)
 *
 * This gives you 4 distinct methods to override:
 * - checkStaticAttributeStaticValue()   - name="class" value="foo"
 * - checkStaticAttributeDynamicValue()  - name="class" value="<%= css_class %>"
 * - checkDynamicAttributeStaticValue()  - name="data-<%= key %>" value="foo"
 * - checkDynamicAttributeDynamicValue() - name="data-<%= key %>" value="<%= value %>"
 */
export class AttributeVisitorMixin extends BaseRuleVisitor {
    constructor(ruleName, context) {
        super(ruleName, context);
    }
    visitHTMLOpenTagNode(node) {
        this.checkAttributesOnNode(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkAttributesOnNode(node) {
        forEachAttribute(node, (attributeNode) => {
            const staticAttributeName = getAttributeName(attributeNode);
            const originalAttributeName = getAttributeName(attributeNode, false) || "";
            const isDynamicName = hasDynamicAttributeName(attributeNode);
            const staticAttributeValue = getStaticAttributeValue(attributeNode);
            const valueNodes = getAttributeValueNodes(attributeNode);
            const hasOutputERB = hasERBOutput(valueNodes);
            const isEffectivelyStaticValue = isEffectivelyStatic(valueNodes);
            if (staticAttributeName && staticAttributeValue !== null) {
                this.checkStaticAttributeStaticValue({
                    attributeName: staticAttributeName,
                    attributeValue: staticAttributeValue,
                    attributeNode,
                    originalAttributeName,
                    parentNode: node
                });
            }
            else if (staticAttributeName && isEffectivelyStaticValue && !hasOutputERB) {
                const validatableContent = getValidatableStaticContent(valueNodes) || "";
                this.checkStaticAttributeStaticValue({ attributeName: staticAttributeName, attributeValue: validatableContent, attributeNode, originalAttributeName, parentNode: node });
            }
            else if (staticAttributeName && hasOutputERB) {
                const combinedValue = getAttributeValue(attributeNode);
                this.checkStaticAttributeDynamicValue({ attributeName: staticAttributeName, valueNodes, attributeNode, parentNode: node, originalAttributeName, combinedValue });
            }
            else if (isDynamicName && staticAttributeValue !== null) {
                const nameNode = attributeNode.name;
                const nameNodes = nameNode.children || [];
                const combinedName = getCombinedAttributeNameString(attributeNode);
                this.checkDynamicAttributeStaticValue({ nameNodes, attributeValue: staticAttributeValue, attributeNode, parentNode: node, combinedName });
            }
            else if (isDynamicName) {
                const nameNode = attributeNode.name;
                const nameNodes = nameNode.children || [];
                const combinedName = getCombinedAttributeNameString(attributeNode);
                const combinedValue = getAttributeValue(attributeNode);
                this.checkDynamicAttributeDynamicValue({ nameNodes, valueNodes, attributeNode, parentNode: node, combinedName, combinedValue });
            }
        });
    }
    /**
     * Static attribute name with static value: class="container"
     */
    checkStaticAttributeStaticValue(_params) {
        // Default implementation does nothing
    }
    /**
     * Static attribute name with dynamic value: class="<%= css_class %>"
     */
    checkStaticAttributeDynamicValue(_params) {
        // Default implementation does nothing
    }
    /**
     * Dynamic attribute name with static value: data-<%= key %>="foo"
     */
    checkDynamicAttributeStaticValue(_params) {
        // Default implementation does nothing
    }
    /**
     * Dynamic attribute name with dynamic value: data-<%= key %>="<%= value %>"
     */
    checkDynamicAttributeDynamicValue(_params) {
        // Default implementation does nothing
    }
}
/**
 * Checks if an attribute value is quoted
 */
export function isAttributeValueQuoted(attributeNode) {
    if (attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
        const valueNode = attributeNode.value;
        return !!valueNode.quoted;
    }
    return false;
}
/**
 * Iterates over all attributes of a tag node, calling the callback for each attribute
 */
export function forEachAttribute(node, callback) {
    const attributes = getAttributes(node);
    for (const child of attributes) {
        if (child.type === "AST_HTML_ATTRIBUTE_NODE") {
            callback(child);
        }
    }
}
/**
 * Base lexer visitor class that provides common functionality for lexer-based rule visitors
 */
export class BaseLexerRuleVisitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create a lint offense for lexer rules
     */
    createOffense(message, location, severity = "error") {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            severity,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, severity = "error") {
        this.offenses.push(this.createOffense(message, location, severity));
    }
    /**
     * Main entry point for lexer rule visitors
     * @param lexResult - The lexer result containing tokens and source
     */
    visit(lexResult) {
        this.visitTokens(lexResult.value.tokens);
    }
    /**
     * Visit all tokens
     * Override this method to implement token-level checks
     */
    visitTokens(tokens) {
        for (const token of tokens) {
            this.visitToken(token);
        }
    }
    /**
     * Visit individual tokens
     * Override this method to implement per-token checks
     */
    visitToken(_token) {
        // Default implementation does nothing
    }
}
/**
 * Base source visitor class that provides common functionality for source-based rule visitors
 */
export class BaseSourceRuleVisitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create a lint offense for source rules
     */
    createOffense(message, location, severity = "error") {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            severity,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, severity = "error") {
        this.offenses.push(this.createOffense(message, location, severity));
    }
    /**
     * Main entry point for source rule visitors
     * @param source - The raw source code
     */
    visit(source) {
        this.visitSource(source);
    }
    /**
     * Helper method to create a location for a specific position in the source
     */
    createLocationAt(source, position) {
        const beforePosition = source.substring(0, position);
        const lines = beforePosition.split('\n');
        const line = lines.length;
        const column = lines[lines.length - 1].length + 1;
        const start = new Position(line, column);
        const end = new Position(line, column);
        return new Location(start, end);
    }
}
//# sourceMappingURL=rule-utils.js.map