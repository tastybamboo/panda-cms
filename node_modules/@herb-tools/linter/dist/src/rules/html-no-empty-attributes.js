import { ParserRule } from "../types.js";
import { AttributeVisitorMixin } from "./rule-utils.js";
import { IdentityPrinter } from "@herb-tools/printer";
// Attributes that must not have empty values
const RESTRICTED_ATTRIBUTES = new Set([
    'id',
    'class',
    'name',
    'for',
    'src',
    'href',
    'title',
    'data',
    'role'
]);
// Check if attribute name matches any restricted patterns
function isRestrictedAttribute(attributeName) {
    // Check direct matches
    if (RESTRICTED_ATTRIBUTES.has(attributeName)) {
        return true;
    }
    // Check for data-* attributes
    if (attributeName.startsWith('data-')) {
        return true;
    }
    // Check for aria-* attributes
    if (attributeName.startsWith('aria-')) {
        return true;
    }
    return false;
}
function isDataAttribute(attributeName) {
    return attributeName.startsWith('data-');
}
class NoEmptyAttributesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        this.checkEmptyAttribute(attributeName, attributeValue, attributeNode);
    }
    checkDynamicAttributeStaticValue({ combinedName, attributeValue, attributeNode }) {
        const name = (combinedName || "").toLowerCase();
        this.checkEmptyAttribute(name, attributeValue, attributeNode);
    }
    checkEmptyAttribute(attributeName, attributeValue, attributeNode) {
        if (!isRestrictedAttribute(attributeName))
            return;
        if (attributeValue.trim() !== "")
            return;
        const hasExplicitValue = attributeNode.value !== null;
        if (isDataAttribute(attributeName)) {
            if (hasExplicitValue) {
                this.addOffense(`Data attribute \`${attributeName}\` should not have an empty value. Either provide a meaningful value or use \`${attributeName}\` instead of \`${IdentityPrinter.print(attributeNode)}\`.`, attributeNode.location, "warning");
            }
            return;
        }
        this.addOffense(`Attribute \`${attributeName}\` must not be empty. Either provide a meaningful value or remove the attribute entirely.`, attributeNode.location, "warning");
    }
}
export class HTMLNoEmptyAttributesRule extends ParserRule {
    name = "html-no-empty-attributes";
    check(result, context) {
        const visitor = new NoEmptyAttributesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}
//# sourceMappingURL=html-no-empty-attributes.js.map