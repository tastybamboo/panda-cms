import { Highlighter } from "@herb-tools/highlighter";
import { BaseFormatter } from "./base-formatter.js";
import { name, version } from "../../../package.json";
// https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-commands
export class GitHubActionsFormatter extends BaseFormatter {
    highlighter;
    wrapLines;
    truncateLines;
    constructor(wrapLines = true, truncateLines = false) {
        super();
        this.wrapLines = wrapLines;
        this.truncateLines = truncateLines;
        this.highlighter = new Highlighter();
    }
    static MESSAGE_ESCAPE_MAP = {
        '%': '%25',
        '\n': '%0A',
        '\r': '%0D'
    };
    static PARAM_ESCAPE_MAP = {
        '%': '%25',
        '\n': '%0A',
        '\r': '%0D',
        ':': '%3A',
        ',': '%2C'
    };
    async format(allDiagnostics, _isSingleFile = false) {
        await this.formatAnnotations(allDiagnostics);
    }
    async formatAnnotations(allDiagnostics) {
        if (allDiagnostics.length === 0)
            return;
        if (!this.highlighter.initialized) {
            await this.highlighter.initialize();
        }
        for (const { filename, offense, content } of allDiagnostics) {
            const originalNoColor = process.env.NO_COLOR;
            process.env.NO_COLOR = "1";
            let plainCodePreview = "";
            try {
                const formatted = this.highlighter.highlightDiagnostic(filename, offense, content, {
                    contextLines: 2,
                    wrapLines: this.wrapLines,
                    truncateLines: this.truncateLines
                });
                plainCodePreview = formatted.split('\n').slice(1).join('\n');
            }
            finally {
                if (originalNoColor === undefined) {
                    delete process.env.NO_COLOR;
                }
                else {
                    process.env.NO_COLOR = originalNoColor;
                }
            }
            this.formatDiagnostic(filename, offense, plainCodePreview);
        }
    }
    formatFile(filename, diagnostics) {
        for (const diagnostic of diagnostics) {
            this.formatDiagnostic(filename, diagnostic);
        }
    }
    // GitHub Actions annotation format:
    // ::{level} file={file},line={line},col={col},title={title}::{message}
    //
    formatDiagnostic(filename, diagnostic, codePreview = "") {
        const level = diagnostic.severity === "error" ? "error" : "warning";
        const { line, column } = diagnostic.location.start;
        const escapedFilename = this.escapeParam(filename);
        let message = diagnostic.message;
        if (diagnostic.code) {
            message += ` [${diagnostic.code}]`;
        }
        if (codePreview) {
            message += "\n\n" + codePreview;
        }
        const escapedMessage = this.escapeMessage(message);
        let annotations = `file=${escapedFilename},line=${line},col=${column}`;
        if (diagnostic.code) {
            const title = `${diagnostic.code} â€¢ ${name}@${version}`;
            const escapedTitle = this.escapeParam(title);
            annotations += `,title=${escapedTitle}`;
        }
        console.log(`\n::${level} ${annotations}::${escapedMessage}`);
    }
    escapeMessage(string) {
        return string.replace(new RegExp(Object.keys(GitHubActionsFormatter.MESSAGE_ESCAPE_MAP).map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'), 'g'), match => GitHubActionsFormatter.MESSAGE_ESCAPE_MAP[match]);
    }
    escapeParam(string) {
        return string.replace(new RegExp(Object.keys(GitHubActionsFormatter.PARAM_ESCAPE_MAP).map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'), 'g'), match => GitHubActionsFormatter.PARAM_ESCAPE_MAP[match]);
    }
}
//# sourceMappingURL=github-actions-formatter.js.map