#!/usr/bin/env node
'use strict';

var node_url = require('node:url');
var node_path = require('node:path');
var fs = require('fs');
var actualFS = require('node:fs');
var promises = require('node:fs/promises');
var node_events = require('node:events');
var Stream = require('node:stream');
var node_string_decoder = require('node:string_decoder');
var path$1 = require('path');
var util = require('util');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var actualFS__namespace = /*#__PURE__*/_interopNamespaceDefault(actualFS);

const balanced = (a, b, str) => {
    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;
    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;
    const r = ma !== null && mb != null && range(ma, mb, str);
    return (r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + ma.length, r[1]),
        post: str.slice(r[1] + mb.length),
    });
};
const maybeMatch = (reg, str) => {
    const m = str.match(reg);
    return m ? m[0] : null;
};
const range = (a, b, str) => {
    let begs, beg, left, right = undefined, result;
    let ai = str.indexOf(a);
    let bi = str.indexOf(b, ai + 1);
    let i = ai;
    if (ai >= 0 && bi > 0) {
        if (a === b) {
            return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
            if (i === ai) {
                begs.push(i);
                ai = str.indexOf(a, i + 1);
            }
            else if (begs.length === 1) {
                const r = begs.pop();
                if (r !== undefined)
                    result = [r, bi];
            }
            else {
                beg = begs.pop();
                if (beg !== undefined && beg < left) {
                    left = beg;
                    right = bi;
                }
                bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length && right !== undefined) {
            result = [left, right];
        }
    }
    return result;
};

const escSlash = '\0SLASH' + Math.random() + '\0';
const escOpen = '\0OPEN' + Math.random() + '\0';
const escClose = '\0CLOSE' + Math.random() + '\0';
const escComma = '\0COMMA' + Math.random() + '\0';
const escPeriod = '\0PERIOD' + Math.random() + '\0';
const escSlashPattern = new RegExp(escSlash, 'g');
const escOpenPattern = new RegExp(escOpen, 'g');
const escClosePattern = new RegExp(escClose, 'g');
const escCommaPattern = new RegExp(escComma, 'g');
const escPeriodPattern = new RegExp(escPeriod, 'g');
const slashPattern = /\\\\/g;
const openPattern = /\\{/g;
const closePattern = /\\}/g;
const commaPattern = /\\,/g;
const periodPattern = /\\./g;
function numeric(str) {
    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
    return str
        .replace(slashPattern, escSlash)
        .replace(openPattern, escOpen)
        .replace(closePattern, escClose)
        .replace(commaPattern, escComma)
        .replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
    return str
        .replace(escSlashPattern, '\\')
        .replace(escOpenPattern, '{')
        .replace(escClosePattern, '}')
        .replace(escCommaPattern, ',')
        .replace(escPeriodPattern, '.');
}
/**
 * Basically just str.split(","), but handling cases
 * where we have nested braced sections, which should be
 * treated as individual members, like {a,{b,c},d}
 */
function parseCommaParts(str) {
    if (!str) {
        return [''];
    }
    const parts = [];
    const m = balanced('{', '}', str);
    if (!m) {
        return str.split(',');
    }
    const { pre, body, post } = m;
    const p = pre.split(',');
    p[p.length - 1] += '{' + body + '}';
    const postParts = parseCommaParts(post);
    if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
}
function expand(str) {
    if (!str) {
        return [];
    }
    // I don't know why Bash 4.3 does this, but it does.
    // Anything starting with {} will have the first two bytes preserved
    // but *only* at the top level, so {},a}b will not expand to anything,
    // but a{},b}c will be expanded to [a}c,abc].
    // One could argue that this is a bug in Bash, but since the goal of
    // this module is to match Bash's rules, we escape a leading {}
    if (str.slice(0, 2) === '{}') {
        str = '\\{\\}' + str.slice(2);
    }
    return expand_(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
    return '{' + str + '}';
}
function isPadded(el) {
    return /^-?0\d/.test(el);
}
function lte(i, y) {
    return i <= y;
}
function gte(i, y) {
    return i >= y;
}
function expand_(str, isTop) {
    /** @type {string[]} */
    const expansions = [];
    const m = balanced('{', '}', str);
    if (!m)
        return [str];
    // no need to expand pre, since it is guaranteed to be free of brace-sets
    const pre = m.pre;
    const post = m.post.length ? expand_(m.post, false) : [''];
    if (/\$$/.test(m.pre)) {
        for (let k = 0; k < post.length; k++) {
            const expansion = pre + '{' + m.body + '}' + post[k];
            expansions.push(expansion);
        }
    }
    else {
        const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        const isSequence = isNumericSequence || isAlphaSequence;
        const isOptions = m.body.indexOf(',') >= 0;
        if (!isSequence && !isOptions) {
            // {a},b}
            if (m.post.match(/,(?!,).*\}/)) {
                str = m.pre + '{' + m.body + escClose + m.post;
                return expand_(str);
            }
            return [str];
        }
        let n;
        if (isSequence) {
            n = m.body.split(/\.\./);
        }
        else {
            n = parseCommaParts(m.body);
            if (n.length === 1 && n[0] !== undefined) {
                // x{{a,b}}y ==> x{a}y x{b}y
                n = expand_(n[0], false).map(embrace);
                //XXX is this necessary? Can't seem to hit it in tests.
                /* c8 ignore start */
                if (n.length === 1) {
                    return post.map(p => m.pre + n[0] + p);
                }
                /* c8 ignore stop */
            }
        }
        // at this point, n is the parts, and we know it's not a comma set
        // with a single entry.
        let N;
        if (isSequence && n[0] !== undefined && n[1] !== undefined) {
            const x = numeric(n[0]);
            const y = numeric(n[1]);
            const width = Math.max(n[0].length, n[1].length);
            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;
            let test = lte;
            const reverse = y < x;
            if (reverse) {
                incr *= -1;
                test = gte;
            }
            const pad = n.some(isPadded);
            N = [];
            for (let i = x; test(i, y); i += incr) {
                let c;
                if (isAlphaSequence) {
                    c = String.fromCharCode(i);
                    if (c === '\\') {
                        c = '';
                    }
                }
                else {
                    c = String(i);
                    if (pad) {
                        const need = width - c.length;
                        if (need > 0) {
                            const z = new Array(need + 1).join('0');
                            if (i < 0) {
                                c = '-' + z + c.slice(1);
                            }
                            else {
                                c = z + c;
                            }
                        }
                    }
                }
                N.push(c);
            }
        }
        else {
            N = [];
            for (let j = 0; j < n.length; j++) {
                N.push.apply(N, expand_(n[j], false));
            }
        }
        for (let j = 0; j < N.length; j++) {
            for (let k = 0; k < post.length; k++) {
                const expansion = pre + N[j] + post[k];
                if (!isTop || isSequence || expansion) {
                    expansions.push(expansion);
                }
            }
        }
    }
    return expansions;
}

const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = (pattern) => {
    if (typeof pattern !== 'string') {
        throw new TypeError('invalid pattern');
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError('pattern is too long');
    }
};

// translate the various posix character classes into unicode properties
// this works across all unicode locales
// { <posix class>: [<translation>, /u flag required, negated]
const posixClasses = {
    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
    '[:blank:]': ['\\p{Zs}\\t', true],
    '[:cntrl:]': ['\\p{Cc}', true],
    '[:digit:]': ['\\p{Nd}', true],
    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
    '[:lower:]': ['\\p{Ll}', true],
    '[:print:]': ['\\p{C}', true],
    '[:punct:]': ['\\p{P}', true],
    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
    '[:upper:]': ['\\p{Lu}', true],
    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
    '[:xdigit:]': ['A-Fa-f0-9', false],
};
// only need to escape a few things inside of brace expressions
// escapes: [ \ ] -
const braceEscape = (s) => s.replace(/[[\]\\-]/g, '\\$&');
// escape all regexp magic characters
const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// everything has already been escaped, we just have to join
const rangesToString = (ranges) => ranges.join('');
// takes a glob string at a posix brace expression, and returns
// an equivalent regular expression source, and boolean indicating
// whether the /u flag needs to be applied, and the number of chars
// consumed to parse the character class.
// This also removes out of order ranges, and returns ($.) if the
// entire class just no good.
const parseClass = (glob, position) => {
    const pos = position;
    /* c8 ignore start */
    if (glob.charAt(pos) !== '[') {
        throw new Error('not in a brace expression');
    }
    /* c8 ignore stop */
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = '';
    WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === '!' || c === '^') && i === pos + 1) {
            negate = true;
            i++;
            continue;
        }
        if (c === ']' && sawStart && !escaping) {
            endPos = i + 1;
            break;
        }
        sawStart = true;
        if (c === '\\') {
            if (!escaping) {
                escaping = true;
                i++;
                continue;
            }
            // escaped \ char, fall through and treat like normal char
        }
        if (c === '[' && !escaping) {
            // either a posix class, a collation equivalent, or just a [
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
                if (glob.startsWith(cls, i)) {
                    // invalid, [a-[] is fine, but not [a-[:alpha]]
                    if (rangeStart) {
                        return ['$.', false, glob.length - pos, true];
                    }
                    i += cls.length;
                    if (neg)
                        negs.push(unip);
                    else
                        ranges.push(unip);
                    uflag = uflag || u;
                    continue WHILE;
                }
            }
        }
        // now it's just a normal character, effectively
        escaping = false;
        if (rangeStart) {
            // throw this range away if it's not valid, but others
            // can still match.
            if (c > rangeStart) {
                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
            }
            else if (c === rangeStart) {
                ranges.push(braceEscape(c));
            }
            rangeStart = '';
            i++;
            continue;
        }
        // now might be the start of a range.
        // can be either c-d or c-] or c<more...>] or c] at this point
        if (glob.startsWith('-]', i + 1)) {
            ranges.push(braceEscape(c + '-'));
            i += 2;
            continue;
        }
        if (glob.startsWith('-', i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
        }
        // not the start of a range, just a single character
        ranges.push(braceEscape(c));
        i++;
    }
    if (endPos < i) {
        // didn't see the end of the class, not a valid class,
        // but might still be valid as a literal match.
        return ['', false, 0, false];
    }
    // if we got no ranges and no negates, then we have a range that
    // cannot possibly match anything, and that poisons the whole glob
    if (!ranges.length && !negs.length) {
        return ['$.', false, glob.length - pos, true];
    }
    // if we got one positive range, and it's a single character, then that's
    // not actually a magic pattern, it's just that one literal character.
    // we should not treat that as "magic", we should just return the literal
    // character. [_] is a perfectly valid way to escape glob magic chars.
    if (negs.length === 0 &&
        ranges.length === 1 &&
        /^\\?.$/.test(ranges[0]) &&
        !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
    const comb = ranges.length && negs.length
        ? '(' + sranges + '|' + snegs + ')'
        : ranges.length
            ? sranges
            : snegs;
    return [comb, uflag, endPos - pos, true];
};

/**
 * Un-escape a string that has been escaped with {@link escape}.
 *
 * If the {@link windowsPathsNoEscape} option is used, then square-brace
 * escapes are removed, but not backslash escapes.  For example, it will turn
 * the string `'[*]'` into `*`, but it will not turn `'\\*'` into `'*'`,
 * becuase `\` is a path separator in `windowsPathsNoEscape` mode.
 *
 * When `windowsPathsNoEscape` is not set, then both brace escapes and
 * backslash escapes are removed.
 *
 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
 * or unescaped.
 */
const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {
    return windowsPathsNoEscape
        ? s.replace(/\[([^\/\\])\]/g, '$1')
        : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2').replace(/\\([^\/])/g, '$1');
};

// parse a single path portion
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape$1 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark$1 = '[^/]';
// * => any number of characters
const star$1 = qmark$1 + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark$1 + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,
                    // even if it starts with . or dot:true is set.
                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart;
                        // check if we have a possibility of matching . or ..,
                        // and prevent that.
                        const needNoTrav = 
                        // dots are allowed, and the pattern starts with [ or .
                        (dot && aps.has(src.charAt(0))) ||
                            // the pattern starts with \., and then [ or .
                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
                            // the pattern starts with \.\., and then [ or .
                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                        // no need to prevent dots if it can't match a dot, or if a
                        // sub-pattern will be preventing it anyway.
                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
                    }
                }
            }
            // append the "end of path portion" pattern to negation tails
            let end = '';
            if (this.isEnd() &&
                this.#root.#filledNegs &&
                this.#parent?.type === '!') {
                end = '(?:$|\\/)';
            }
            const final = start + src + end;
            return [
                final,
                unescape(src),
                (this.#hasMagic = !!this.#hasMagic),
                this.#uflag,
            ];
        }
        // We need to calculate the body *twice* if it's a repeat pattern
        // at the start, once in nodot mode, then again in dot mode, so a
        // pattern like *(?) can match 'x.y'
        const repeated = this.type === '*' || this.type === '+';
        // some kind of extglob
        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
            // invalid extglob, has to at least be *something* present, if it's
            // the entire path portion.
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [s, unescape(this.toString()), false, false];
        }
        // XXX abstract out this map method
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot
            ? ''
            : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
            bodyDotAllowed = '';
        }
        if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        // an empty !() is exactly equivalent to a starNoEmpty
        let final = '';
        if (this.type === '!' && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
        }
        else {
            const close = this.type === '!'
                ? // !() must match something,but !(x) can match ''
                    '))' +
                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +
                        star$1 +
                        ')'
                : this.type === '@'
                    ? ')'
                    : this.type === '?'
                        ? ')?'
                        : this.type === '+' && bodyDotAllowed
                            ? ')'
                            : this.type === '*' && bodyDotAllowed
                                ? `)?`
                                : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            unescape(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
        ];
    }
    #partsToRegExp(dot) {
        return this.#parts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = parseClass(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                if (noEmpty && glob === '*')
                    re += starNoEmpty;
                else
                    re += star$1;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark$1;
                hasMagic = true;
                continue;
            }
            re += regExpEscape$1(c);
        }
        return [re, unescape(glob), !!hasMagic, uflag];
    }
}

/**
 * Escape all magic characters in a glob pattern.
 *
 * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}
 * option is used, then characters are escaped by wrapping in `[]`, because
 * a magic character wrapped in a character class can only be satisfied by
 * that exact character.  In this mode, `\` is _not_ escaped, because it is
 * not interpreted as a magic character, but instead as a path separator.
 */
const escape = (s, { windowsPathsNoEscape = false, } = {}) => {
    // don't need to escape +@! because we escape the parens
    // that make those magic, and escaping ! as [!] isn't valid,
    // because [!]] is a valid glob class meaning not ']'.
    return windowsPathsNoEscape
        ? s.replace(/[?*()[\]]/g, '[$&]')
        : s.replace(/[?*()[\]\\]/g, '\\$&');
};

const minimatch = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform$2 = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
const sep = defaultPlatform$2 === 'win32' ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
const GLOBSTAR = Symbol('globstar **');
minimatch.GLOBSTAR = GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: GLOBSTAR,
    });
};
minimatch.defaults = defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return expand(pattern);
};
minimatch.braceExpand = braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
minimatch.match = match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        assertValidPattern(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform$2;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== '.' && p !== '..' && p !== '**') {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [''] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === '**') {
                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== '..')
                        continue;
                    if (!p ||
                        p === '.' ||
                        p === '..' ||
                        !p2 ||
                        p2 === '.' ||
                        p2 === '..') {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = '**';
                    globParts.push(other);
                    gs--;
                }
                // <pre>/<e>/<rest> -> <pre>/<rest>
                if (!this.preserveMultipleSlashes) {
                    for (let i = 1; i < parts.length - 1; i++) {
                        const p = parts[i];
                        // don't squeeze out UNC patterns
                        if (i === 1 && p === '' && parts[0] === '')
                            continue;
                        if (p === '.' || p === '') {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === '.' &&
                        parts.length === 2 &&
                        (parts[1] === '.' || parts[1] === '')) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                let dd = 0;
                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                    const p = parts[dd - 1];
                    if (p && p !== '.' && p !== '..' && p !== '**') {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === '**';
                        const splin = needDot ? ['.'] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0)
                            parts.push('');
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (matched) {
                    globParts[i] = [];
                    globParts[j] = matched;
                    break;
                }
            }
        }
        return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = '';
        while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === 'b' ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === '*' &&
                b[bi] &&
                (this.options.dot || !b[bi].startsWith('.')) &&
                b[bi] !== '**') {
                if (which === 'b')
                    return false;
                which = 'a';
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === '*' &&
                a[ai] &&
                (this.options.dot || !a[ai].startsWith('.')) &&
                a[ai] !== '**') {
                if (which === 'a')
                    return false;
                which = 'b';
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &&
                file[0] === '' &&
                file[1] === '' &&
                file[2] === '?' &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // dont' need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
        assertValidPattern(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === GLOBSTAR
                        ? GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== GLOBSTAR || prev === GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
                }
                else if (next !== GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = GLOBSTAR;
                }
            });
            return pp.filter(p => p !== GLOBSTAR).join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return minimatch.defaults(def).Minimatch;
    }
}
/* c8 ignore stop */
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

/**
 * @module LRUCache
 */
const perf = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
        ? PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #onInsert;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    #hasOnInsert;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.onInsert} (read-only)
     */
    get onInsert() {
        return this.#onInsert;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined &&
            typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof onInsert === 'function') {
            this.#onInsert = onInsert;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasOnInsert = !!this.#onInsert;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined)
            return undefined;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v)
            ? v.__staleWhileFetching
            : v;
        if (value === undefined)
            return undefined;
        const entry = { value };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                    ? this.#free.pop()
                    : this.#size === this.#max
                        ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
            if (this.#hasOnInsert) {
                this.#onInsert?.(v, k, 'add');
            }
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
                        ? oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
            if (this.#hasOnInsert) {
                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined ||
            (!allowStale && this.#isStale(index))) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.#delete(k, 'fetch');
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort ||
                    options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined)
            throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined)
            return v;
        const vv = memoMethod(k, v, {
            options,
            context,
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, reason]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, reason]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}

const proc = typeof process === 'object' && process
    ? process
    : {
        stdout: null,
        stderr: null,
    };
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
const isStream = (s) => !!s &&
    typeof s === 'object' &&
    (s instanceof Minipass ||
        s instanceof Stream ||
        isReadable(s) ||
        isWritable(s));
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
const isReadable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof node_events.EventEmitter &&
    typeof s.pipe === 'function' &&
    // node core Writable streams have a pipe() method, but it throws
    s.pipe !== Stream.Writable.prototype.pipe;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
const isWritable = (s) => !!s &&
    typeof s === 'object' &&
    s instanceof node_events.EventEmitter &&
    typeof s.write === 'function' &&
    typeof s.end === 'function';
const EOF = Symbol('EOF');
const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
const EMITTED_END = Symbol('emittedEnd');
const EMITTING_END = Symbol('emittingEnd');
const EMITTED_ERROR = Symbol('emittedError');
const CLOSED = Symbol('closed');
const READ = Symbol('read');
const FLUSH = Symbol('flush');
const FLUSHCHUNK = Symbol('flushChunk');
const ENCODING = Symbol('encoding');
const DECODER = Symbol('decoder');
const FLOWING = Symbol('flowing');
const PAUSED = Symbol('paused');
const RESUME = Symbol('resume');
const BUFFER = Symbol('buffer');
const PIPES = Symbol('pipes');
const BUFFERLENGTH = Symbol('bufferLength');
const BUFFERPUSH = Symbol('bufferPush');
const BUFFERSHIFT = Symbol('bufferShift');
const OBJECTMODE = Symbol('objectMode');
// internal event when stream is destroyed
const DESTROYED = Symbol('destroyed');
// internal event when stream has an error
const ERROR = Symbol('error');
const EMITDATA = Symbol('emitData');
const EMITEND = Symbol('emitEnd');
const EMITEND2 = Symbol('emitEnd2');
const ASYNC = Symbol('async');
const ABORT = Symbol('abort');
const ABORTED = Symbol('aborted');
const SIGNAL = Symbol('signal');
const DATALISTENERS = Symbol('dataListeners');
const DISCARDED = Symbol('discarded');
const defer = (fn) => Promise.resolve().then(fn);
const nodefer = (fn) => fn();
const isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';
const isArrayBufferLike = (b) => b instanceof ArrayBuffer ||
    (!!b &&
        typeof b === 'object' &&
        b.constructor &&
        b.constructor.name === 'ArrayBuffer' &&
        b.byteLength >= 0);
const isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
class Pipe {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on('drain', this.ondrain);
    }
    unpipe() {
        this.dest.removeListener('drain', this.ondrain);
    }
    // only here for the prototype
    /* c8 ignore start */
    proxyErrors(_er) { }
    /* c8 ignore stop */
    end() {
        this.unpipe();
        if (this.opts.end)
            this.dest.end();
    }
}
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
class PipeProxyErrors extends Pipe {
    unpipe() {
        this.src.removeListener('error', this.proxyErrors);
        super.unpipe();
    }
    constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = er => dest.emit('error', er);
        src.on('error', this.proxyErrors);
    }
}
const isObjectModeOptions = (o) => !!o.objectMode;
const isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
class Minipass extends node_events.EventEmitter {
    [FLOWING] = false;
    [PAUSED] = false;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = false;
    [EMITTED_END] = false;
    [EMITTING_END] = false;
    [CLOSED] = false;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = false;
    [SIGNAL];
    [ABORTED] = false;
    [DATALISTENERS] = 0;
    [DISCARDED] = false;
    /**
     * true if the stream can be written
     */
    writable = true;
    /**
     * true if the stream can be read
     */
    readable = true;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args) {
        const options = (args[0] ||
            {});
        super();
        if (options.objectMode && typeof options.encoding === 'string') {
            throw new TypeError('Encoding and objectMode may not be used together');
        }
        if (isObjectModeOptions(options)) {
            this[OBJECTMODE] = true;
            this[ENCODING] = null;
        }
        else if (isEncodingOptions(options)) {
            this[ENCODING] = options.encoding;
            this[OBJECTMODE] = false;
        }
        else {
            this[OBJECTMODE] = false;
            this[ENCODING] = null;
        }
        this[ASYNC] = !!options.async;
        this[DECODER] = this[ENCODING]
            ? new node_string_decoder.StringDecoder(this[ENCODING])
            : null;
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposeBuffer === true) {
            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });
        }
        //@ts-ignore - private option for debugging and testing
        if (options && options.debugExposePipes === true) {
            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });
        }
        const { signal } = options;
        if (signal) {
            this[SIGNAL] = signal;
            if (signal.aborted) {
                this[ABORT]();
            }
            else {
                signal.addEventListener('abort', () => this[ABORT]());
            }
        }
    }
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength() {
        return this[BUFFERLENGTH];
    }
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding() {
        return this[ENCODING];
    }
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc) {
        throw new Error('Encoding must be set at instantiation time');
    }
    /**
     * True if this is an objectMode stream
     */
    get objectMode() {
        return this[OBJECTMODE];
    }
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om) {
        throw new Error('objectMode must be set at instantiation time');
    }
    /**
     * true if this is an async stream
     */
    get ['async']() {
        return this[ASYNC];
    }
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a) {
        this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
        this[ABORTED] = true;
        this.emit('abort', this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
    }
    /**
     * True if the stream has been aborted.
     */
    get aborted() {
        return this[ABORTED];
    }
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_) { }
    write(chunk, encoding, cb) {
        if (this[ABORTED])
            return false;
        if (this[EOF])
            throw new Error('write after end');
        if (this[DESTROYED]) {
            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));
            return true;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (!encoding)
            encoding = 'utf8';
        const fn = this[ASYNC] ? defer : nodefer;
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything is only allowed if in object mode, so throw
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            else if (isArrayBufferLike(chunk)) {
                //@ts-ignore - sinful unsafe type changing
                chunk = Buffer.from(chunk);
            }
            else if (typeof chunk !== 'string') {
                throw new Error('Non-contiguous data written to non-objectMode stream');
            }
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE]) {
            // maybe impossible?
            /* c8 ignore start */
            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
                this[FLUSH](true);
            /* c8 ignore stop */
            if (this[FLOWING])
                this.emit('data', chunk);
            else
                this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0)
                this.emit('readable');
            if (cb)
                fn(cb);
            return this[FLOWING];
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === 'string' &&
            // unless it is a string already ready for us to use
            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
            //@ts-ignore - sinful unsafe type change
            chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
            //@ts-ignore - sinful unsafe type change
            chunk = this[DECODER].write(chunk);
        }
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
        if (this[FLOWING])
            this.emit('data', chunk);
        else
            this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
            this.emit('readable');
        if (cb)
            fn(cb);
        return this[FLOWING];
    }
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n) {
        if (this[DESTROYED])
            return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 ||
            n === 0 ||
            (n && n > this[BUFFERLENGTH])) {
            this[MAYBE_EMIT_END]();
            return null;
        }
        if (this[OBJECTMODE])
            n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
            // not object mode, so if we have an encoding, then RType is string
            // otherwise, must be Buffer
            this[BUFFER] = [
                (this[ENCODING]
                    ? this[BUFFER].join('')
                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),
            ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [READ](n, chunk) {
        if (this[OBJECTMODE])
            this[BUFFERSHIFT]();
        else {
            const c = chunk;
            if (n === c.length || n === null)
                this[BUFFERSHIFT]();
            else if (typeof c === 'string') {
                this[BUFFER][0] = c.slice(n);
                chunk = c.slice(0, n);
                this[BUFFERLENGTH] -= n;
            }
            else {
                this[BUFFER][0] = c.subarray(n);
                chunk = c.subarray(0, n);
                this[BUFFERLENGTH] -= n;
            }
        }
        this.emit('data', chunk);
        if (!this[BUFFER].length && !this[EOF])
            this.emit('drain');
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') {
            cb = chunk;
            chunk = undefined;
        }
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = 'utf8';
        }
        if (chunk !== undefined)
            this.write(chunk, encoding);
        if (cb)
            this.once('end', cb);
        this[EOF] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this[FLOWING] || !this[PAUSED])
            this[MAYBE_EMIT_END]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
        if (this[DESTROYED])
            return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
            this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit('resume');
        if (this[BUFFER].length)
            this[FLUSH]();
        else if (this[EOF])
            this[MAYBE_EMIT_END]();
        else
            this.emit('drain');
    }
    /**
     * Resume the stream if it is currently in a paused state
     *
     * If called when there are no pipe destinations or `data` event listeners,
     * this will place the stream in a "discarded" state, where all data will
     * be thrown away. The discarded state is removed if a pipe destination or
     * data handler is added, if pause() is called, or if any synchronous or
     * asynchronous iteration is started.
     */
    resume() {
        return this[RESUME]();
    }
    /**
     * Pause the stream
     */
    pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
    }
    /**
     * true if the stream has been forcibly destroyed
     */
    get destroyed() {
        return this[DESTROYED];
    }
    /**
     * true if the stream is currently in a flowing state, meaning that
     * any writes will be immediately emitted.
     */
    get flowing() {
        return this[FLOWING];
    }
    /**
     * true if the stream is currently in a paused state
     */
    get paused() {
        return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] += 1;
        else
            this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
        else
            this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
    }
    [FLUSH](noDrain = false) {
        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&
            this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
            this.emit('drain');
    }
    [FLUSHCHUNK](chunk) {
        this.emit('data', chunk);
        return this[FLOWING];
    }
    /**
     * Pipe all data emitted by this stream into the destination provided.
     *
     * Triggers the flow of data.
     */
    pipe(dest, opts) {
        if (this[DESTROYED])
            return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
            opts.end = false;
        else
            opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        // piping an ended stream ends immediately
        if (ended) {
            if (opts.end)
                dest.end();
        }
        else {
            // "as" here just ignores the WType, which pipes don't care about,
            // since they're only consuming from us, and writing to the dest
            this[PIPES].push(!opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts));
            if (this[ASYNC])
                defer(() => this[RESUME]());
            else
                this[RESUME]();
        }
        return dest;
    }
    /**
     * Fully unhook a piped destination stream.
     *
     * If the destination stream was the only consumer of this stream (ie,
     * there are no other piped destinations or `'data'` event listeners)
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    unpipe(dest) {
        const p = this[PIPES].find(p => p.dest === dest);
        if (p) {
            if (this[PIPES].length === 1) {
                if (this[FLOWING] && this[DATALISTENERS] === 0) {
                    this[FLOWING] = false;
                }
                this[PIPES] = [];
            }
            else
                this[PIPES].splice(this[PIPES].indexOf(p), 1);
            p.unpipe();
        }
    }
    /**
     * Alias for {@link Minipass#on}
     */
    addListener(ev, handler) {
        return this.on(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.on`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * - Adding a 'data' event handler will trigger the flow of data
     *
     * - Adding a 'readable' event handler when there is data waiting to be read
     *   will cause 'readable' to be emitted immediately.
     *
     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
     *   already passed will cause the event to be emitted immediately and all
     *   handlers removed.
     *
     * - Adding an 'error' event handler after an error has been emitted will
     *   cause the event to be re-emitted immediately with the error previously
     *   raised.
     */
    on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === 'data') {
            this[DISCARDED] = false;
            this[DATALISTENERS]++;
            if (!this[PIPES].length && !this[FLOWING]) {
                this[RESUME]();
            }
        }
        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {
            super.emit('readable');
        }
        else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
        }
        else if (ev === 'error' && this[EMITTED_ERROR]) {
            const h = handler;
            if (this[ASYNC])
                defer(() => h.call(this, this[EMITTED_ERROR]));
            else
                h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
    }
    /**
     * Alias for {@link Minipass#off}
     */
    removeListener(ev, handler) {
        return this.off(ev, handler);
    }
    /**
     * Mostly identical to `EventEmitter.off`
     *
     * If a 'data' event handler is removed, and it was the last consumer
     * (ie, there are no pipe destinations or other 'data' event listeners),
     * then the flow of data will stop until there is another consumer or
     * {@link Minipass#resume} is explicitly called.
     */
    off(ev, handler) {
        const ret = super.off(ev, handler);
        // if we previously had listeners, and now we don't, and we don't
        // have any pipes, then stop the flow, unless it's been explicitly
        // put in a discarded flowing state via stream.resume().
        if (ev === 'data') {
            this[DATALISTENERS] = this.listeners('data').length;
            if (this[DATALISTENERS] === 0 &&
                !this[DISCARDED] &&
                !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * Mostly identical to `EventEmitter.removeAllListeners`
     *
     * If all 'data' event handlers are removed, and they were the last consumer
     * (ie, there are no pipe destinations), then the flow of data will stop
     * until there is another consumer or {@link Minipass#resume} is explicitly
     * called.
     */
    removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === 'data' || ev === undefined) {
            this[DATALISTENERS] = 0;
            if (!this[DISCARDED] && !this[PIPES].length) {
                this[FLOWING] = false;
            }
        }
        return ret;
    }
    /**
     * true if the 'end' event has been emitted
     */
    get emittedEnd() {
        return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this[BUFFER].length === 0 &&
            this[EOF]) {
            this[EMITTING_END] = true;
            this.emit('end');
            this.emit('prefinish');
            this.emit('finish');
            if (this[CLOSED])
                this.emit('close');
            this[EMITTING_END] = false;
        }
    }
    /**
     * Mostly identical to `EventEmitter.emit`, with the following
     * behavior differences to prevent data loss and unnecessary hangs:
     *
     * If the stream has been destroyed, and the event is something other
     * than 'close' or 'error', then `false` is returned and no handlers
     * are called.
     *
     * If the event is 'end', and has already been emitted, then the event
     * is ignored. If the stream is in a paused or non-flowing state, then
     * the event will be deferred until data flow resumes. If the stream is
     * async, then handlers will be called on the next tick rather than
     * immediately.
     *
     * If the event is 'close', and 'end' has not yet been emitted, then
     * the event will be deferred until after 'end' is emitted.
     *
     * If the event is 'error', and an AbortSignal was provided for the stream,
     * and there are no listeners, then the event is ignored, matching the
     * behavior of node core streams in the presense of an AbortSignal.
     *
     * If the event is 'finish' or 'prefinish', then all listeners will be
     * removed after emitting the event, to prevent double-firing.
     */
    emit(ev, ...args) {
        const data = args[0];
        // error and close are only events allowed after calling destroy()
        if (ev !== 'error' &&
            ev !== 'close' &&
            ev !== DESTROYED &&
            this[DESTROYED]) {
            return false;
        }
        else if (ev === 'data') {
            return !this[OBJECTMODE] && !data
                ? false
                : this[ASYNC]
                    ? (defer(() => this[EMITDATA](data)), true)
                    : this[EMITDATA](data);
        }
        else if (ev === 'end') {
            return this[EMITEND]();
        }
        else if (ev === 'close') {
            this[CLOSED] = true;
            // don't emit close before 'end' and 'finish'
            if (!this[EMITTED_END] && !this[DESTROYED])
                return false;
            const ret = super.emit('close');
            this.removeAllListeners('close');
            return ret;
        }
        else if (ev === 'error') {
            this[EMITTED_ERROR] = data;
            super.emit(ERROR, data);
            const ret = !this[SIGNAL] || this.listeners('error').length
                ? super.emit('error', data)
                : false;
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'resume') {
            const ret = super.emit('resume');
            this[MAYBE_EMIT_END]();
            return ret;
        }
        else if (ev === 'finish' || ev === 'prefinish') {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
        }
        // Some other unknown event
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITDATA](data) {
        for (const p of this[PIPES]) {
            if (p.dest.write(data) === false)
                this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit('data', data);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITEND]() {
        if (this[EMITTED_END])
            return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC]
            ? (defer(() => this[EMITEND2]()), true)
            : this[EMITEND2]();
    }
    [EMITEND2]() {
        if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
                for (const p of this[PIPES]) {
                    p.dest.write(data);
                }
                if (!this[DISCARDED])
                    super.emit('data', data);
            }
        }
        for (const p of this[PIPES]) {
            p.end();
        }
        const ret = super.emit('end');
        this.removeAllListeners('end');
        return ret;
    }
    /**
     * Return a Promise that resolves to an array of all emitted data once
     * the stream ends.
     */
    async collect() {
        const buf = Object.assign([], {
            dataLength: 0,
        });
        if (!this[OBJECTMODE])
            buf.dataLength = 0;
        // set the promise first, in case an error is raised
        // by triggering the flow here.
        const p = this.promise();
        this.on('data', c => {
            buf.push(c);
            if (!this[OBJECTMODE])
                buf.dataLength += c.length;
        });
        await p;
        return buf;
    }
    /**
     * Return a Promise that resolves to the concatenation of all emitted data
     * once the stream ends.
     *
     * Not allowed on objectMode streams.
     */
    async concat() {
        if (this[OBJECTMODE]) {
            throw new Error('cannot concat in objectMode');
        }
        const buf = await this.collect();
        return (this[ENCODING]
            ? buf.join('')
            : Buffer.concat(buf, buf.dataLength));
    }
    /**
     * Return a void Promise that resolves once the stream ends.
     */
    async promise() {
        return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error('stream destroyed')));
            this.on('error', er => reject(er));
            this.on('end', () => resolve());
        });
    }
    /**
     * Asynchronous `for await of` iteration.
     *
     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
            this.pause();
            stopped = true;
            return { value: undefined, done: true };
        };
        const next = () => {
            if (stopped)
                return stop();
            const res = this.read();
            if (res !== null)
                return Promise.resolve({ done: false, value: res });
            if (this[EOF])
                return stop();
            let resolve;
            let reject;
            const onerr = (er) => {
                this.off('data', ondata);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                stop();
                reject(er);
            };
            const ondata = (value) => {
                this.off('error', onerr);
                this.off('end', onend);
                this.off(DESTROYED, ondestroy);
                this.pause();
                resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
                this.off('error', onerr);
                this.off('data', ondata);
                this.off(DESTROYED, ondestroy);
                stop();
                resolve({ done: true, value: undefined });
            };
            const ondestroy = () => onerr(new Error('stream destroyed'));
            return new Promise((res, rej) => {
                reject = rej;
                resolve = res;
                this.once(DESTROYED, ondestroy);
                this.once('error', onerr);
                this.once('end', onend);
                this.once('data', ondata);
            });
        };
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator]() {
        // set this up front, in case the consumer doesn't call next()
        // right away.
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
            this.pause();
            this.off(ERROR, stop);
            this.off(DESTROYED, stop);
            this.off('end', stop);
            stopped = true;
            return { done: true, value: undefined };
        };
        const next = () => {
            if (stopped)
                return stop();
            const value = this.read();
            return value === null ? stop() : { done: false, value };
        };
        this.once('end', stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
            next,
            throw: stop,
            return: stop,
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(er) {
        if (this[DESTROYED]) {
            if (er)
                this.emit('error', er);
            else
                this.emit(DESTROYED);
            return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        // throw away all buffered data, it's never coming out
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === 'function' && !this[CLOSED])
            wc.close();
        if (er)
            this.emit('error', er);
        // if no error to emit, still reject pending promises
        else
            this.emit(DESTROYED);
        return this;
    }
    /**
     * Alias for {@link isStream}
     *
     * Former export location, maintained for backwards compatibility.
     *
     * @deprecated
     */
    static get isStream() {
        return isStream;
    }
}

const realpathSync = fs.realpathSync.native;
const defaultFS = {
    lstatSync: fs.lstatSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync,
    readlinkSync: fs.readlinkSync,
    realpathSync,
    promises: {
        lstat: promises.lstat,
        readdir: promises.readdir,
        readlink: promises.readlink,
        realpath: promises.realpath,
    },
};
// if they just gave us require('fs') then use our default
const fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS__namespace ?
    defaultFS
    : {
        ...defaultFS,
        ...fsOption,
        promises: {
            ...defaultFS.promises,
            ...(fsOption.promises || {}),
        },
    };
// turn something like //?/c:/ into c:\
const uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
const uncToDrive = (rootPath) => rootPath.replace(/\//g, '\\').replace(uncDriveRegexp, '$1\\');
// windows paths are separated by either / or \
const eitherSep = /[\\\/]/;
const UNKNOWN = 0; // may not even exist, for all we know
const IFIFO = 0b0001;
const IFCHR = 0b0010;
const IFDIR = 0b0100;
const IFBLK = 0b0110;
const IFREG = 0b1000;
const IFLNK = 0b1010;
const IFSOCK = 0b1100;
const IFMT = 0b1111;
// mask to unset low 4 bits
const IFMT_UNKNOWN = ~IFMT;
// set after successfully calling readdir() and getting entries.
const READDIR_CALLED = 0b0000_0001_0000;
// set after a successful lstat()
const LSTAT_CALLED = 0b0000_0010_0000;
// set if an entry (or one of its parents) is definitely not a dir
const ENOTDIR = 0b0000_0100_0000;
// set if an entry (or one of its parents) does not exist
// (can also be set on lstat errors like EACCES or ENAMETOOLONG)
const ENOENT = 0b0000_1000_0000;
// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK
// set if we fail to readlink
const ENOREADLINK = 0b0001_0000_0000;
// set if we know realpath() will fail
const ENOREALPATH = 0b0010_0000_0000;
const ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
const TYPEMASK = 0b0011_1111_1111;
const entToType = (s) => s.isFile() ? IFREG
    : s.isDirectory() ? IFDIR
        : s.isSymbolicLink() ? IFLNK
            : s.isCharacterDevice() ? IFCHR
                : s.isBlockDevice() ? IFBLK
                    : s.isSocket() ? IFSOCK
                        : s.isFIFO() ? IFIFO
                            : UNKNOWN;
// normalize unicode path names
const normalizeCache = new Map();
const normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
        return c;
    const n = s.normalize('NFKD');
    normalizeCache.set(s, n);
    return n;
};
const normalizeNocaseCache = new Map();
const normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
        return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
};
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
class ResolveCache extends LRUCache {
    constructor() {
        super({ max: 256 });
    }
}
// In order to prevent blowing out the js heap by allocating hundreds of
// thousands of Path entries when walking extremely large trees, the "children"
// in this tree are represented by storing an array of Path entries in an
// LRUCache, indexed by the parent.  At any time, Path.children() may return an
// empty array, indicating that it doesn't know about any of its children, and
// thus has to rebuild that cache.  This is fine, it just means that we don't
// benefit as much from having the cached entries, but huge directory walks
// don't blow out the stack, and smaller ones are still as fast as possible.
//
//It does impose some complexity when building up the readdir data, because we
//need to pass a reference to the children array that we started with.
/**
 * an LRUCache for storing child entries.
 * @internal
 */
class ChildrenCache extends LRUCache {
    constructor(maxSize = 16 * 1024) {
        super({
            maxSize,
            // parent + children
            sizeCalculation: a => a.length + 1,
        });
    }
}
const setAsCwd = Symbol('PathScurry setAsCwd');
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
class PathBase {
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots;
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase;
    /**
     * boolean indicating that this path is the current working directory
     * of the PathScurry collection that contains it.
     */
    isCWD = false;
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
        return this.#dev;
    }
    #mode;
    get mode() {
        return this.#mode;
    }
    #nlink;
    get nlink() {
        return this.#nlink;
    }
    #uid;
    get uid() {
        return this.#uid;
    }
    #gid;
    get gid() {
        return this.#gid;
    }
    #rdev;
    get rdev() {
        return this.#rdev;
    }
    #blksize;
    get blksize() {
        return this.#blksize;
    }
    #ino;
    get ino() {
        return this.#ino;
    }
    #size;
    get size() {
        return this.#size;
    }
    #blocks;
    get blocks() {
        return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
        return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
        return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
        return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
        return this.#birthtimeMs;
    }
    #atime;
    get atime() {
        return this.#atime;
    }
    #mtime;
    get mtime() {
        return this.#mtime;
    }
    #ctime;
    get ctime() {
        return this.#ctime;
    }
    #birthtime;
    get birthtime() {
        return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['parentPath'] refers to the path of the
     * directory that was passed to readdir. For root entries, it's the path
     * to the entry itself.
     */
    get parentPath() {
        return (this.parent || this).fullpath();
    }
    /**
     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
     * this property refers to the *parent* path, not the path object itself.
     *
     * @deprecated
     */
    get path() {
        return this.parentPath;
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        this.name = name;
        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
            this.#fs = this.parent.#fs;
        }
        else {
            this.#fs = fsFromOption(opts.fs);
        }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth() {
        if (this.#depth !== undefined)
            return this.#depth;
        if (!this.parent)
            return (this.#depth = 0);
        return (this.#depth = this.parent.depth() + 1);
    }
    /**
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path) {
        if (!path) {
            return this;
        }
        const rootPath = this.getRootString(path);
        const dir = path.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ?
            this.getRoot(rootPath).#resolveParts(dirParts)
            : this.#resolveParts(dirParts);
        return result;
    }
    #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
            p = p.child(part);
        }
        return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children() {
        const cached = this.#children.get(this);
        if (cached) {
            return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart, opts) {
        if (pathPart === '' || pathPart === '.') {
            return this;
        }
        if (pathPart === '..') {
            return this.parent || this;
        }
        // find the child
        const children = this.children();
        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
        for (const p of children) {
            if (p.#matchName === name) {
                return p;
            }
        }
        // didn't find it, create provisional child, since it might not
        // actually exist.  If we know the parent isn't a dir, then
        // in fact it CAN'T exist.
        const s = this.parent ? this.sep : '';
        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;
        const pchild = this.newChild(pathPart, UNKNOWN, {
            ...opts,
            parent: this,
            fullpath,
        });
        if (!this.canReaddir()) {
            pchild.#type |= ENOENT;
        }
        // don't have to update provisional, because if we have real children,
        // then provisional is set to children.length, otherwise a lower number
        children.push(pchild);
        return pchild;
    }
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative() {
        if (this.isCWD)
            return '';
        if (this.#relative !== undefined) {
            return this.#relative;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relative = this.name);
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? '' : this.sep) + name;
    }
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix() {
        if (this.sep === '/')
            return this.relative();
        if (this.isCWD)
            return '';
        if (this.#relativePosix !== undefined)
            return this.#relativePosix;
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#relativePosix = this.fullpathPosix());
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? '' : '/') + name;
    }
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath() {
        if (this.#fullpath !== undefined) {
            return this.#fullpath;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
            return (this.#fullpath = this.name);
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? '' : this.sep) + name;
        return (this.#fullpath = fp);
    }
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix() {
        if (this.#fullpathPosix !== undefined)
            return this.#fullpathPosix;
        if (this.sep === '/')
            return (this.#fullpathPosix = this.fullpath());
        if (!this.parent) {
            const p = this.fullpath().replace(/\\/g, '/');
            if (/^[a-z]:\//i.test(p)) {
                return (this.#fullpathPosix = `//?/${p}`);
            }
            else {
                return (this.#fullpathPosix = p);
            }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;
        return (this.#fullpathPosix = fpp);
    }
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type) {
        return this[`is${type}`]();
    }
    getType() {
        return (this.isUnknown() ? 'Unknown'
            : this.isDirectory() ? 'Directory'
                : this.isFile() ? 'File'
                    : this.isSymbolicLink() ? 'SymbolicLink'
                        : this.isFIFO() ? 'FIFO'
                            : this.isCharacterDevice() ? 'CharacterDevice'
                                : this.isBlockDevice() ? 'BlockDevice'
                                    : /* c8 ignore start */ this.isSocket() ? 'Socket'
                                        : 'Unknown');
        /* c8 ignore stop */
    }
    /**
     * Is the Path a regular file?
     */
    isFile() {
        return (this.#type & IFMT) === IFREG;
    }
    /**
     * Is the Path a directory?
     */
    isDirectory() {
        return (this.#type & IFMT) === IFDIR;
    }
    /**
     * Is the path a character device?
     */
    isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
    }
    /**
     * Is the path a block device?
     */
    isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
    }
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO() {
        return (this.#type & IFMT) === IFIFO;
    }
    /**
     * Is the path a socket?
     */
    isSocket() {
        return (this.#type & IFMT) === IFSOCK;
    }
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached() {
        return this.#type & LSTAT_CALLED ? this : undefined;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached() {
        return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached() {
        return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink() {
        if (this.#linkTarget)
            return true;
        if (!this.parent)
            return false;
        // cases where it cannot possibly succeed
        const ifmt = this.#type & IFMT;
        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||
            this.#type & ENOREADLINK ||
            this.#type & ENOENT);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT() {
        return !!(this.#type & ENOENT);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n) {
        return !this.nocase ?
            this.#matchName === normalize(n)
            : this.#matchName === normalizeNocase(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    async readlink() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = await this.#fs.promises.readlink(this.fullpath());
            const linkTarget = (await this.parent.realpath())?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = this.#fs.readlinkSync(this.fullpath());
            const linkTarget = this.parent.realpathSync()?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    #readdirSuccess(children) {
        // succeeded, mark readdir called bit
        this.#type |= READDIR_CALLED;
        // mark all remaining provisional children as ENOENT
        for (let p = children.provisional; p < children.length; p++) {
            const c = children[p];
            if (c)
                c.#markENOENT();
        }
    }
    #markENOENT() {
        // mark as UNKNOWN and ENOENT
        if (this.#type & ENOENT)
            return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
        // all children are provisional and do not exist
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
            p.#markENOENT();
        }
    }
    #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
        // entry is not a directory, so any children can't exist.
        // this *should* be impossible, since any children created
        // after it's been marked ENOTDIR should be marked ENOENT,
        // so it won't even get to this point.
        /* c8 ignore start */
        if (this.#type & ENOTDIR)
            return;
        /* c8 ignore stop */
        let t = this.#type;
        // this could happen if we stat a dir, then delete it,
        // then try to read it or one of its children.
        if ((t & IFMT) === IFDIR)
            t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
    }
    #readdirFail(code = '') {
        // markENOTDIR and markENOENT also set provisional=0
        if (code === 'ENOTDIR' || code === 'EPERM') {
            this.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            this.#markENOENT();
        }
        else {
            this.children().provisional = 0;
        }
    }
    #lstatFail(code = '') {
        // Windows just raises ENOENT in this case, disable for win CI
        /* c8 ignore start */
        if (code === 'ENOTDIR') {
            // already know it has a parent by this point
            const p = this.parent;
            p.#markENOTDIR();
        }
        else if (code === 'ENOENT') {
            /* c8 ignore stop */
            this.#markENOENT();
        }
    }
    #readlinkFail(code = '') {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === 'ENOENT')
            ter |= ENOENT;
        // windows gets a weird error when you try to readlink a file
        if (code === 'EINVAL' || code === 'UNKNOWN') {
            // exists, but not a symlink, we don't know WHAT it is, so remove
            // all IFMT bits.
            ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        // windows just gets ENOENT in this case.  We do cover the case,
        // just disabled because it's impossible on Windows CI
        /* c8 ignore start */
        if (code === 'ENOTDIR' && this.parent) {
            this.parent.#markENOTDIR();
        }
        /* c8 ignore stop */
    }
    #readdirAddChild(e, c) {
        return (this.#readdirMaybePromoteChild(e, c) ||
            this.#readdirAddNewChild(e, c));
    }
    #readdirAddNewChild(e, c) {
        // alloc new entry at head, so it's never provisional
        const type = entToType(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
            child.#type |= ENOTDIR;
        }
        c.unshift(child);
        c.provisional++;
        return child;
    }
    #readdirMaybePromoteChild(e, c) {
        for (let p = c.provisional; p < c.length; p++) {
            const pchild = c[p];
            const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
            if (name !== pchild.#matchName) {
                continue;
            }
            return this.#readdirPromoteChild(e, pchild, p, c);
        }
    }
    #readdirPromoteChild(e, p, index, c) {
        const v = p.name;
        // retain any other flags, but set ifmt from dirent
        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);
        // case sensitivity fixing when we learn the true name.
        if (v !== e.name)
            p.name = e.name;
        // just advance provisional index (potentially off the list),
        // otherwise we have to splice/pop it out and re-insert at head
        if (index !== c.provisional) {
            if (index === c.length - 1)
                c.pop();
            else
                c.splice(index, 1);
            c.unshift(p);
        }
        c.provisional++;
        return p;
    }
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(this.#fs.lstatSync(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        // retain any other flags, but set the ifmt
        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
            this.#type |= ENOTDIR;
        }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach(cb => cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
            if (allowZalgo)
                cb(null, []);
            else
                queueMicrotask(() => cb(null, []));
            return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
            const c = children.slice(0, children.provisional);
            if (allowZalgo)
                cb(null, c);
            else
                queueMicrotask(() => cb(null, c));
            return;
        }
        // don't have to worry about zalgo at this point.
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
            return;
        }
        this.#readdirCBInFlight = true;
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
            if (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            else {
                // if we didn't get an error, we always get entries.
                //@ts-ignore
                for (const e of entries) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            this.#callOnReaddirCB(children.slice(0, children.provisional));
            return;
        });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async readdir() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
            await this.#asyncReaddirInFlight;
        }
        else {
            /* c8 ignore start */
            let resolve = () => { };
            /* c8 ignore stop */
            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));
            try {
                for (const e of await this.#fs.promises.readdir(fullpath, {
                    withFileTypes: true,
                })) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            catch (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            this.#asyncReaddirInFlight = undefined;
            resolve();
        }
        return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        try {
            for (const e of this.#fs.readdirSync(fullpath, {
                withFileTypes: true,
            })) {
                this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
        }
        catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
        }
        return children.slice(0, children.provisional);
    }
    canReaddir() {
        if (this.#type & ENOCHILD)
            return false;
        const ifmt = IFMT & this.#type;
        // we always set ENOTDIR when setting IFMT, so should be impossible
        /* c8 ignore start */
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
            return false;
        }
        /* c8 ignore stop */
        return true;
    }
    shouldWalk(dirs, walkFilter) {
        return ((this.#type & IFDIR) === IFDIR &&
            !(this.#type & ENOCHILD) &&
            !dirs.has(this) &&
            (!walkFilter || walkFilter(this)));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    async realpath() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = await this.#fs.promises.realpath(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Synchronous {@link realpath}
     */
    realpathSync() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = this.#fs.realpathSync(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd) {
        if (oldCwd === this)
            return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
            changed.add(p);
            p.#relative = rp.join(this.sep);
            p.#relativePosix = rp.join('/');
            p = p.parent;
            rp.push('..');
        }
        // now un-memoize parents of old cwd
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
            p.#relative = undefined;
            p.#relativePosix = undefined;
            p = p.parent;
        }
    }
}
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
class PathWin32 extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep = '\\';
    /**
     * Separator for parsing path strings.
     */
    splitSep = eitherSep;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN, opts = {}) {
        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return node_path.win32.parse(path).root;
    }
    /**
     * @internal
     */
    getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
            return this.root;
        }
        // ok, not that one, check if it matches another we know about
        for (const [compare, root] of Object.entries(this.roots)) {
            if (this.sameRoot(rootPath, compare)) {
                return (this.roots[rootPath] = root);
            }
        }
        // otherwise, have to create a new one.
        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);
    }
    /**
     * @internal
     */
    sameRoot(rootPath, compare = this.root.name) {
        // windows can (rarely) have case-sensitive filesystem, but
        // UNC and drive letters are always case-insensitive, and canonically
        // represented uppercase.
        rootPath = rootPath
            .toUpperCase()
            .replace(/\//g, '\\')
            .replace(uncDriveRegexp, '$1\\');
        return rootPath === compare;
    }
}
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
class PathPosix extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep = '/';
    /**
     * separator for generating path strings
     */
    sep = '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return path.startsWith('/') ? '/' : '';
    }
    /**
     * @internal
     */
    getRoot(_rootPath) {
        return this.root;
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN, opts = {}) {
        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
}
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
class PathScurryBase {
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots;
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase;
    #fs;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {
        this.#fs = fsFromOption(fs);
        if (cwd instanceof URL || cwd.startsWith('file://')) {
            cwd = node_url.fileURLToPath(cwd);
        }
        // resolve and split root, and then add to the store.
        // this is the only time we call path.resolve()
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        // resolve('/') leaves '', splits to [''], we don't want that.
        if (split.length === 1 && !split[0]) {
            split.pop();
        }
        /* c8 ignore start */
        if (nocase === undefined) {
            throw new TypeError('must provide nocase setting to PathScurryBase ctor');
        }
        /* c8 ignore stop */
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
            const l = len--;
            prev = prev.child(part, {
                relative: new Array(l).fill('..').join(joinSep),
                relativePosix: new Array(l).fill('..').join('/'),
                fullpath: (abs += (sawFirst ? '' : joinSep) + part),
            });
            sawFirst = true;
        }
        this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path = this.cwd) {
        if (typeof path === 'string') {
            path = this.cwd.resolve(path);
        }
        return path.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
    }
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths) {
        // first figure out the minimum number of paths we have to test
        // we always start at cwd, but any absolutes will bump the start
        let r = '';
        for (let i = paths.length - 1; i >= 0; i--) {
            const p = paths[i];
            if (!p || p === '.')
                continue;
            r = r ? `${p}/${r}` : p;
            if (this.isAbsolute(p)) {
                break;
            }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== undefined) {
            return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
    }
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.relative();
    }
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
    }
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.name;
    }
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
        withFileTypes: true,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry.canReaddir()) {
            return [];
        }
        else {
            const p = await entry.readdir();
            return withFileTypes ? p : p.map(e => e.name);
        }
    }
    readdirSync(entry = this.cwd, opts = {
        withFileTypes: true,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry.canReaddir()) {
            return [];
        }
        else if (withFileTypes) {
            return entry.readdirSync();
        }
        else {
            return entry.readdirSync().map(e => e.name);
        }
    }
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
    }
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry = this.cwd) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false,
    }) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            withFileTypes = entry.withFileTypes;
            entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const walk = (dir, cb) => {
            dirs.add(dir);
            dir.readdirCB((er, entries) => {
                /* c8 ignore start */
                if (er) {
                    return cb(er);
                }
                /* c8 ignore stop */
                let len = entries.length;
                if (!len)
                    return cb();
                const next = () => {
                    if (--len === 0) {
                        cb();
                    }
                };
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        results.push(withFileTypes ? e : e.fullpath());
                    }
                    if (follow && e.isSymbolicLink()) {
                        e.realpath()
                            .then(r => (r?.isUnknown() ? r.lstat() : r))
                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
                    }
                    else {
                        if (e.shouldWalk(dirs, walkFilter)) {
                            walk(e, next);
                        }
                        else {
                            next();
                        }
                    }
                }
            }, true); // zalgooooooo
        };
        const start = entry;
        return new Promise((res, rej) => {
            walk(start, er => {
                /* c8 ignore start */
                if (er)
                    return rej(er);
                /* c8 ignore stop */
                res(results);
            });
        });
    }
    walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    results.push(withFileTypes ? e : e.fullpath());
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
        return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
        // iterating async over the stream is significantly more performant,
        // especially in the warm-cache scenario, because it buffers up directory
        // entries in the background instead of waiting for a yield for each one.
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            options = entry;
            entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        if (!filter || filter(entry)) {
            yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    yield withFileTypes ? e : e.fullpath();
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
    }
    stream(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new Minipass({ objectMode: true });
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const onReaddir = (er, entries, didRealpaths = false) => {
                    /* c8 ignore start */
                    if (er)
                        return results.emit('error', er);
                    /* c8 ignore stop */
                    if (follow && !didRealpaths) {
                        const promises = [];
                        for (const e of entries) {
                            if (e.isSymbolicLink()) {
                                promises.push(e
                                    .realpath()
                                    .then((r) => r?.isUnknown() ? r.lstat() : r));
                            }
                        }
                        if (promises.length) {
                            Promise.all(promises).then(() => onReaddir(null, entries, true));
                            return;
                        }
                    }
                    for (const e of entries) {
                        if (e && (!filter || filter(e))) {
                            if (!results.write(withFileTypes ? e : e.fullpath())) {
                                paused = true;
                            }
                        }
                    }
                    processing--;
                    for (const e of entries) {
                        const r = e.realpathCached() || e;
                        if (r.shouldWalk(dirs, walkFilter)) {
                            queue.push(r);
                        }
                    }
                    if (paused && !results.flowing) {
                        results.once('drain', process);
                    }
                    else if (!sync) {
                        process();
                    }
                };
                // zalgo containment
                let sync = true;
                dir.readdirCB(onReaddir, true);
                sync = false;
            }
        };
        process();
        return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new Minipass({ objectMode: true });
        const dirs = new Set();
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const entries = dir.readdirSync();
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        if (!results.write(withFileTypes ? e : e.fullpath())) {
                            paused = true;
                        }
                    }
                }
                processing--;
                for (const e of entries) {
                    let r = e;
                    if (e.isSymbolicLink()) {
                        if (!(follow && (r = e.realpathSync())))
                            continue;
                        if (r.isUnknown())
                            r.lstatSync();
                    }
                    if (r.shouldWalk(dirs, walkFilter)) {
                        queue.push(r);
                    }
                }
            }
            if (paused && !results.flowing)
                results.once('drain', process);
        };
        process();
        return results;
    }
    chdir(path = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;
        this.cwd[setAsCwd](oldCwd);
    }
}
/**
 * Windows implementation of {@link PathScurryBase}
 *
 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
 * {@link PathWin32} for Path objects.
 */
class PathScurryWin32 extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '\\';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, node_path.win32, '\\', { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
            p.nocase = this.nocase;
        }
    }
    /**
     * @internal
     */
    parseRootPath(dir) {
        // if the path starts with a single separator, it's not a UNC, and we'll
        // just get separator as the root, and driveFromUNC will return \
        // In that case, mount \ on the root from the cwd.
        return node_path.win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return (p.startsWith('/') || p.startsWith('\\') || /^[a-z]:(\/|\\)/i.test(p));
    }
}
/**
 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
 *
 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
class PathScurryPosix extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '/';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, node_path.posix, '/', { ...opts, nocase });
        this.nocase = nocase;
    }
    /**
     * @internal
     */
    parseRootPath(_dir) {
        return '/';
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return p.startsWith('/');
    }
}
/**
 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
 *
 * Defaults to case-insensitive matching, uses `'/'` for generating path
 * strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
    }
}
/**
 * Default {@link PathBase} implementation for the current platform.
 *
 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
 */
process.platform === 'win32' ? PathWin32 : PathPosix;
/**
 * Default {@link PathScurryBase} implementation for the current platform.
 *
 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
 */
const PathScurry = process.platform === 'win32' ? PathScurryWin32
    : process.platform === 'darwin' ? PathScurryDarwin
        : PathScurryPosix;

// this is just a very light wrapper around 2 arrays with an offset index
const isPatternList = (pl) => pl.length >= 1;
const isGlobList = (gl) => gl.length >= 1;
/**
 * An immutable-ish view on an array of glob parts and their parsed
 * results
 */
class Pattern {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = true;
    constructor(patternList, globList, index, platform) {
        if (!isPatternList(patternList)) {
            throw new TypeError('empty pattern list');
        }
        if (!isGlobList(globList)) {
            throw new TypeError('empty glob list');
        }
        if (globList.length !== patternList.length) {
            throw new TypeError('mismatched pattern list and glob list lengths');
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
            throw new TypeError('index out of range');
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index;
        this.#platform = platform;
        // normalize root entries of absolute patterns on initial creation.
        if (this.#index === 0) {
            // c: => ['c:/']
            // C:/ => ['C:/']
            // C:/x => ['C:/', 'x']
            // //host/share => ['//host/share/']
            // //host/share/ => ['//host/share/']
            // //host/share/x => ['//host/share/', 'x']
            // /etc => ['/', 'etc']
            // / => ['/']
            if (this.isUNC()) {
                // '' / '' / 'host' / 'share'
                const [p0, p1, p2, p3, ...prest] = this.#patternList;
                const [g0, g1, g2, g3, ...grest] = this.#globList;
                if (prest[0] === '') {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = [p0, p1, p2, p3, ''].join('/');
                const g = [g0, g1, g2, g3, ''].join('/');
                this.#patternList = [p, ...prest];
                this.#globList = [g, ...grest];
                this.length = this.#patternList.length;
            }
            else if (this.isDrive() || this.isAbsolute()) {
                const [p1, ...prest] = this.#patternList;
                const [g1, ...grest] = this.#globList;
                if (prest[0] === '') {
                    // ends in /
                    prest.shift();
                    grest.shift();
                }
                const p = p1 + '/';
                const g = g1 + '/';
                this.#patternList = [p, ...prest];
                this.#globList = [g, ...grest];
                this.length = this.#patternList.length;
            }
        }
    }
    /**
     * The first entry in the parsed list of patterns
     */
    pattern() {
        return this.#patternList[this.#index];
    }
    /**
     * true of if pattern() returns a string
     */
    isString() {
        return typeof this.#patternList[this.#index] === 'string';
    }
    /**
     * true of if pattern() returns GLOBSTAR
     */
    isGlobstar() {
        return this.#patternList[this.#index] === GLOBSTAR;
    }
    /**
     * true if pattern() returns a regexp
     */
    isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
    }
    /**
     * The /-joined set of glob parts that make up this pattern
     */
    globString() {
        return (this.#globString =
            this.#globString ||
                (this.#index === 0 ?
                    this.isAbsolute() ?
                        this.#globList[0] + this.#globList.slice(1).join('/')
                        : this.#globList.join('/')
                    : this.#globList.slice(this.#index).join('/')));
    }
    /**
     * true if there are more pattern parts after this one
     */
    hasMore() {
        return this.length > this.#index + 1;
    }
    /**
     * The rest of the pattern after this part, or null if this is the end
     */
    rest() {
        if (this.#rest !== undefined)
            return this.#rest;
        if (!this.hasMore())
            return (this.#rest = null);
        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
    }
    /**
     * true if the pattern represents a //unc/path/ on windows
     */
    isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== undefined ?
            this.#isUNC
            : (this.#isUNC =
                this.#platform === 'win32' &&
                    this.#index === 0 &&
                    pl[0] === '' &&
                    pl[1] === '' &&
                    typeof pl[2] === 'string' &&
                    !!pl[2] &&
                    typeof pl[3] === 'string' &&
                    !!pl[3]);
    }
    // pattern like C:/...
    // split = ['C:', ...]
    // XXX: would be nice to handle patterns like `c:*` to test the cwd
    // in c: for *, but I don't know of a way to even figure out what that
    // cwd is without actually chdir'ing into it?
    /**
     * True if the pattern starts with a drive letter on Windows
     */
    isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== undefined ?
            this.#isDrive
            : (this.#isDrive =
                this.#platform === 'win32' &&
                    this.#index === 0 &&
                    this.length > 1 &&
                    typeof pl[0] === 'string' &&
                    /^[a-z]:$/i.test(pl[0]));
    }
    // pattern = '/' or '/...' or '/x/...'
    // split = ['', ''] or ['', ...] or ['', 'x', ...]
    // Drive and UNC both considered absolute on windows
    /**
     * True if the pattern is rooted on an absolute path
     */
    isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== undefined ?
            this.#isAbsolute
            : (this.#isAbsolute =
                (pl[0] === '' && pl.length > 1) ||
                    this.isDrive() ||
                    this.isUNC());
    }
    /**
     * consume the root of the pattern, and return it
     */
    root() {
        const p = this.#patternList[0];
        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?
            p
            : '';
    }
    /**
     * Check to see if the current globstar pattern is allowed to follow
     * a symbolic link.
     */
    checkFollowGlobstar() {
        return !(this.#index === 0 ||
            !this.isGlobstar() ||
            !this.#followGlobstar);
    }
    /**
     * Mark that the current globstar pattern is following a symbolic link
     */
    markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
            return false;
        this.#followGlobstar = false;
        return true;
    }
}

// give it a pattern, and it'll be able to tell you if
// a given path should be ignored.
// Ignoring a path ignores its children if the pattern ends in /**
// Ignores are always parsed in dot:true mode
const defaultPlatform$1 = (typeof process === 'object' &&
    process &&
    typeof process.platform === 'string') ?
    process.platform
    : 'linux';
/**
 * Class used to process ignored patterns
 */
class Ignore {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    platform;
    mmopts;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform$1, }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        this.platform = platform;
        this.mmopts = {
            dot: true,
            nobrace,
            nocase,
            noext,
            noglobstar,
            optimizationLevel: 2,
            platform,
            nocomment: true,
            nonegate: true,
        };
        for (const ign of ignored)
            this.add(ign);
    }
    add(ign) {
        // this is a little weird, but it gives us a clean set of optimized
        // minimatch matchers, without getting tripped up if one of them
        // ends in /** inside a brace section, and it's only inefficient at
        // the start of the walk, not along it.
        // It'd be nice if the Pattern class just had a .test() method, but
        // handling globstars is a bit of a pita, and that code already lives
        // in minimatch anyway.
        // Another way would be if maybe Minimatch could take its set/globParts
        // as an option, and then we could at least just use Pattern to test
        // for absolute-ness.
        // Yet another way, Minimatch could take an array of glob strings, and
        // a cwd option, and do the right thing.
        const mm = new Minimatch(ign, this.mmopts);
        for (let i = 0; i < mm.set.length; i++) {
            const parsed = mm.set[i];
            const globParts = mm.globParts[i];
            /* c8 ignore start */
            if (!parsed || !globParts) {
                throw new Error('invalid pattern object');
            }
            // strip off leading ./ portions
            // https://github.com/isaacs/node-glob/issues/570
            while (parsed[0] === '.' && globParts[0] === '.') {
                parsed.shift();
                globParts.shift();
            }
            /* c8 ignore stop */
            const p = new Pattern(parsed, globParts, 0, this.platform);
            const m = new Minimatch(p.globString(), this.mmopts);
            const children = globParts[globParts.length - 1] === '**';
            const absolute = p.isAbsolute();
            if (absolute)
                this.absolute.push(m);
            else
                this.relative.push(m);
            if (children) {
                if (absolute)
                    this.absoluteChildren.push(m);
                else
                    this.relativeChildren.push(m);
            }
        }
    }
    ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || '.';
        const relatives = `${relative}/`;
        for (const m of this.relative) {
            if (m.match(relative) || m.match(relatives))
                return true;
        }
        for (const m of this.absolute) {
            if (m.match(fullpath) || m.match(fullpaths))
                return true;
        }
        return false;
    }
    childrenIgnored(p) {
        const fullpath = p.fullpath() + '/';
        const relative = (p.relative() || '.') + '/';
        for (const m of this.relativeChildren) {
            if (m.match(relative))
                return true;
        }
        for (const m of this.absoluteChildren) {
            if (m.match(fullpath))
                return true;
        }
        return false;
    }
}

// synchronous utility for filtering entries and calculating subwalks
/**
 * A cache of which patterns have been processed for a given Path
 */
class HasWalkedCache {
    store;
    constructor(store = new Map()) {
        this.store = store;
    }
    copy() {
        return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
            cached.add(pattern.globString());
        else
            this.store.set(fullpath, new Set([pattern.globString()]));
    }
}
/**
 * A record of which paths have been matched in a given walk step,
 * and whether they only are considered a match if they are a directory,
 * and whether their absolute or relative path should be returned.
 */
class MatchRecord {
    store = new Map();
    add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === undefined ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
        return [...this.store.entries()].map(([path, n]) => [
            path,
            !!(n & 2),
            !!(n & 1),
        ]);
    }
}
/**
 * A collection of patterns that must be processed in a subsequent step
 * for a given path.
 */
class SubWalks {
    store = new Map();
    add(target, pattern) {
        if (!target.canReaddir()) {
            return;
        }
        const subs = this.store.get(target);
        if (subs) {
            if (!subs.find(p => p.globString() === pattern.globString())) {
                subs.push(pattern);
            }
        }
        else
            this.store.set(target, [pattern]);
    }
    get(target) {
        const subs = this.store.get(target);
        /* c8 ignore start */
        if (!subs) {
            throw new Error('attempting to walk unknown path');
        }
        /* c8 ignore stop */
        return subs;
    }
    entries() {
        return this.keys().map(k => [k, this.store.get(k)]);
    }
    keys() {
        return [...this.store.keys()].filter(t => t.canReaddir());
    }
}
/**
 * The class that processes patterns for a given path.
 *
 * Handles child entry filtering, and determining whether a path's
 * directory contents must be read.
 */
class Processor {
    hasWalkedCache;
    matches = new MatchRecord();
    subwalks = new SubWalks();
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache =
            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
    }
    processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map(p => [target, p]);
        // map of paths to the magic-starting subwalks they need to walk
        // first item in patterns is the filter
        for (let [t, pattern] of processingSet) {
            this.hasWalkedCache.storeWalked(t, pattern);
            const root = pattern.root();
            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
            // start absolute patterns at root
            if (root) {
                t = t.resolve(root === '/' && this.opts.root !== undefined ?
                    this.opts.root
                    : root);
                const rest = pattern.rest();
                if (!rest) {
                    this.matches.add(t, true, false);
                    continue;
                }
                else {
                    pattern = rest;
                }
            }
            if (t.isENOENT())
                continue;
            let p;
            let rest;
            let changed = false;
            while (typeof (p = pattern.pattern()) === 'string' &&
                (rest = pattern.rest())) {
                const c = t.resolve(p);
                t = c;
                pattern = rest;
                changed = true;
            }
            p = pattern.pattern();
            rest = pattern.rest();
            if (changed) {
                if (this.hasWalkedCache.hasWalked(t, pattern))
                    continue;
                this.hasWalkedCache.storeWalked(t, pattern);
            }
            // now we have either a final string for a known entry,
            // more strings for an unknown entry,
            // or a pattern starting with magic, mounted on t.
            if (typeof p === 'string') {
                // must not be final entry, otherwise we would have
                // concatenated it earlier.
                const ifDir = p === '..' || p === '' || p === '.';
                this.matches.add(t.resolve(p), absolute, ifDir);
                continue;
            }
            else if (p === GLOBSTAR) {
                // if no rest, match and subwalk pattern
                // if rest, process rest and subwalk pattern
                // if it's a symlink, but we didn't get here by way of a
                // globstar match (meaning it's the first time THIS globstar
                // has traversed a symlink), then we follow it. Otherwise, stop.
                if (!t.isSymbolicLink() ||
                    this.follow ||
                    pattern.checkFollowGlobstar()) {
                    this.subwalks.add(t, pattern);
                }
                const rp = rest?.pattern();
                const rrest = rest?.rest();
                if (!rest || ((rp === '' || rp === '.') && !rrest)) {
                    // only HAS to be a dir if it ends in **/ or **/.
                    // but ending in ** will match files as well.
                    this.matches.add(t, absolute, rp === '' || rp === '.');
                }
                else {
                    if (rp === '..') {
                        // this would mean you're matching **/.. at the fs root,
                        // and no thanks, I'm not gonna test that specific case.
                        /* c8 ignore start */
                        const tp = t.parent || t;
                        /* c8 ignore stop */
                        if (!rrest)
                            this.matches.add(tp, absolute, true);
                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                            this.subwalks.add(tp, rrest);
                        }
                    }
                }
            }
            else if (p instanceof RegExp) {
                this.subwalks.add(t, pattern);
            }
        }
        return this;
    }
    subwalkTargets() {
        return this.subwalks.keys();
    }
    child() {
        return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        // put matches and entry walks into the results processor
        const results = this.child();
        for (const e of entries) {
            for (const pattern of patterns) {
                const absolute = pattern.isAbsolute();
                const p = pattern.pattern();
                const rest = pattern.rest();
                if (p === GLOBSTAR) {
                    results.testGlobstar(e, pattern, rest, absolute);
                }
                else if (p instanceof RegExp) {
                    results.testRegExp(e, p, rest, absolute);
                }
                else {
                    results.testString(e, p, rest, absolute);
                }
            }
        }
        return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith('.')) {
            if (!pattern.hasMore()) {
                this.matches.add(e, absolute, false);
            }
            if (e.canReaddir()) {
                // if we're in follow mode or it's not a symlink, just keep
                // testing the same pattern. If there's more after the globstar,
                // then this symlink consumes the globstar. If not, then we can
                // follow at most ONE symlink along the way, so we mark it, which
                // also checks to ensure that it wasn't already marked.
                if (this.follow || !e.isSymbolicLink()) {
                    this.subwalks.add(e, pattern);
                }
                else if (e.isSymbolicLink()) {
                    if (rest && pattern.checkFollowGlobstar()) {
                        this.subwalks.add(e, rest);
                    }
                    else if (pattern.markFollowGlobstar()) {
                        this.subwalks.add(e, pattern);
                    }
                }
            }
        }
        // if the NEXT thing matches this entry, then also add
        // the rest.
        if (rest) {
            const rp = rest.pattern();
            if (typeof rp === 'string' &&
                // dots and empty were handled already
                rp !== '..' &&
                rp !== '' &&
                rp !== '.') {
                this.testString(e, rp, rest.rest(), absolute);
            }
            else if (rp === '..') {
                /* c8 ignore start */
                const ep = e.parent || e;
                /* c8 ignore stop */
                this.subwalks.add(ep, rest);
            }
            else if (rp instanceof RegExp) {
                this.testRegExp(e, rp, rest.rest(), absolute);
            }
        }
    }
    testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
            return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        }
        else {
            this.subwalks.add(e, rest);
        }
    }
    testString(e, p, rest, absolute) {
        // should never happen?
        if (!e.isNamed(p))
            return;
        if (!rest) {
            this.matches.add(e, absolute, false);
        }
        else {
            this.subwalks.add(e, rest);
        }
    }
}

/**
 * Single-use utility classes to provide functionality to the {@link Glob}
 * methods.
 *
 * @module
 */
const makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new Ignore([ignore], opts)
    : Array.isArray(ignore) ? new Ignore(ignore, opts)
        : ignore;
/**
 * basic walking utilities that all the glob walker types use
 */
class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    includeChildMatches;
    constructor(patterns, path, opts) {
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
            this.#ignore = makeIgnore(opts.ignore ?? [], opts);
            if (!this.includeChildMatches &&
                typeof this.#ignore.add !== 'function') {
                const m = 'cannot ignore child matches, ignore lacks add() method.';
                throw new Error(m);
            }
        }
        // ignore, always set with maxDepth, but it's optional on the
        // GlobOptions type
        /* c8 ignore start */
        this.maxDepth = opts.maxDepth || Infinity;
        /* c8 ignore stop */
        if (opts.signal) {
            this.signal = opts.signal;
            this.signal.addEventListener('abort', () => {
                this.#onResume.length = 0;
            });
        }
    }
    #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
    }
    // backpressure mechanism
    pause() {
        this.paused = true;
    }
    resume() {
        /* c8 ignore start */
        if (this.signal?.aborted)
            return;
        /* c8 ignore stop */
        this.paused = false;
        let fn = undefined;
        while (!this.paused && (fn = this.#onResume.shift())) {
            fn();
        }
    }
    onResume(fn) {
        if (this.signal?.aborted)
            return;
        /* c8 ignore start */
        if (!this.paused) {
            fn();
        }
        else {
            /* c8 ignore stop */
            this.#onResume.push(fn);
        }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || (await e.realpath());
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = await s.realpath();
            /* c8 ignore start */
            if (target && (target.isUnknown() || this.opts.stat)) {
                await target.lstat();
            }
            /* c8 ignore stop */
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
        return (e &&
            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
            (!ifDir || e.canReaddir()) &&
            (!this.opts.nodir || !e.isDirectory()) &&
            (!this.opts.nodir ||
                !this.opts.follow ||
                !e.isSymbolicLink() ||
                !e.realpathCached()?.isDirectory()) &&
            !this.#ignored(e)) ?
            e
            : undefined;
    }
    matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || e.realpathSync();
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = s.realpathSync();
            if (target && (target?.isUnknown() || this.opts.stat)) {
                target.lstatSync();
            }
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
        if (this.#ignored(e))
            return;
        // we know we have an ignore if this is false, but TS doesn't
        if (!this.includeChildMatches && this.#ignore?.add) {
            const ign = `${e.relativePosix()}/**`;
            this.#ignore.add(ign);
        }
        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
        // ok, we have what we need!
        if (this.opts.withFileTypes) {
            this.matchEmit(e);
        }
        else if (abs) {
            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs + mark);
        }
        else {
            const rel = this.opts.posix ? e.relativePosix() : e.relative();
            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?
                '.' + this.#sep
                : '';
            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
        }
    }
    async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const childrenCached = t.readdirCached();
            if (t.calledReaddir())
                this.walkCB3(t, childrenCached, processor, next);
            else {
                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
            }
        }
        next();
    }
    walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2(target, patterns, processor.child(), next);
        }
        next();
    }
    walkCBSync(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const children = t.readdirSync();
            this.walkCB3Sync(t, children, processor, next);
        }
        next();
    }
    walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            this.matchSync(m, absolute, ifDir);
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2Sync(target, patterns, processor.child(), next);
        }
        next();
    }
}
class GlobWalker extends GlobUtil {
    matches = new Set();
    constructor(patterns, path, opts) {
        super(patterns, path, opts);
    }
    matchEmit(e) {
        this.matches.add(e);
    }
    async walk() {
        if (this.signal?.aborted)
            throw this.signal.reason;
        if (this.path.isUnknown()) {
            await this.path.lstat();
        }
        await new Promise((res, rej) => {
            this.walkCB(this.path, this.patterns, () => {
                if (this.signal?.aborted) {
                    rej(this.signal.reason);
                }
                else {
                    res(this.matches);
                }
            });
        });
        return this.matches;
    }
    walkSync() {
        if (this.signal?.aborted)
            throw this.signal.reason;
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        // nothing for the callback to do, because this never pauses
        this.walkCBSync(this.path, this.patterns, () => {
            if (this.signal?.aborted)
                throw this.signal.reason;
        });
        return this.matches;
    }
}
class GlobStream extends GlobUtil {
    results;
    constructor(patterns, path, opts) {
        super(patterns, path, opts);
        this.results = new Minipass({
            signal: this.signal,
            objectMode: true,
        });
        this.results.on('drain', () => this.resume());
        this.results.on('resume', () => this.resume());
    }
    matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
            this.pause();
    }
    stream() {
        const target = this.path;
        if (target.isUnknown()) {
            target.lstat().then(() => {
                this.walkCB(target, this.patterns, () => this.results.end());
            });
        }
        else {
            this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
    }
    streamSync() {
        if (this.path.isUnknown()) {
            this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
    }
}

// if no process global, just call it linux.
// so we default to case-sensitive, / separators
const defaultPlatform = (typeof process === 'object' &&
    process &&
    typeof process.platform === 'string') ?
    process.platform
    : 'linux';
/**
 * An object that can perform glob pattern traversals.
 */
class Glob {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    includeChildMatches;
    /**
     * The options provided to the constructor.
     */
    opts;
    /**
     * An array of parsed immutable {@link Pattern} objects.
     */
    patterns;
    /**
     * All options are stored as properties on the `Glob` object.
     *
     * See {@link GlobOptions} for full options descriptions.
     *
     * Note that a previous `Glob` object can be passed as the
     * `GlobOptions` to another `Glob` instantiation to re-use settings
     * and caches with a new pattern.
     *
     * Traversal functions can be called multiple times to run the walk
     * again.
     */
    constructor(pattern, opts) {
        /* c8 ignore start */
        if (!opts)
            throw new TypeError('glob options required');
        /* c8 ignore stop */
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
            this.cwd = '';
        }
        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {
            opts.cwd = node_url.fileURLToPath(opts.cwd);
        }
        this.cwd = opts.cwd || '';
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.includeChildMatches = opts.includeChildMatches !== false;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth =
            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== undefined) {
            throw new Error('cannot set absolute and withFileTypes:true');
        }
        if (typeof pattern === 'string') {
            pattern = [pattern];
        }
        this.windowsPathsNoEscape =
            !!opts.windowsPathsNoEscape ||
                opts.allowWindowsEscape ===
                    false;
        if (this.windowsPathsNoEscape) {
            pattern = pattern.map(p => p.replace(/\\/g, '/'));
        }
        if (this.matchBase) {
            if (opts.noglobstar) {
                throw new TypeError('base matching requires globstar');
            }
            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));
        }
        this.pattern = pattern;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
            this.scurry = opts.scurry;
            if (opts.nocase !== undefined &&
                opts.nocase !== opts.scurry.nocase) {
                throw new Error('nocase option contradicts provided scurry option');
            }
        }
        else {
            const Scurry = opts.platform === 'win32' ? PathScurryWin32
                : opts.platform === 'darwin' ? PathScurryDarwin
                    : opts.platform ? PathScurryPosix
                        : PathScurry;
            this.scurry = new Scurry(this.cwd, {
                nocase: opts.nocase,
                fs: opts.fs,
            });
        }
        this.nocase = this.scurry.nocase;
        // If you do nocase:true on a case-sensitive file system, then
        // we need to use regexps instead of strings for non-magic
        // path portions, because statting `aBc` won't return results
        // for the file `AbC` for example.
        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';
        const mmo = {
            // default nocase based on platform
            ...opts,
            dot: this.dot,
            matchBase: this.matchBase,
            nobrace: this.nobrace,
            nocase: this.nocase,
            nocaseMagicOnly,
            nocomment: true,
            noext: this.noext,
            nonegate: true,
            optimizationLevel: 2,
            platform: this.platform,
            windowsPathsNoEscape: this.windowsPathsNoEscape,
            debug: !!this.opts.debug,
        };
        const mms = this.pattern.map(p => new Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m) => {
            set[0].push(...m.set);
            set[1].push(...m.globParts);
            return set;
        }, [[], []]);
        this.patterns = matchSet.map((set, i) => {
            const g = globParts[i];
            /* c8 ignore start */
            if (!g)
                throw new Error('invalid pattern object');
            /* c8 ignore stop */
            return new Pattern(set, g, 0, this.platform);
        });
    }
    async walk() {
        // Walkers always return array of Path objects, so we just have to
        // coerce them into the right shape.  It will have already called
        // realpath() if the option was set to do so, so we know that's cached.
        // start out knowing the cwd, at least
        return [
            ...(await new GlobWalker(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity ?
                    this.maxDepth + this.scurry.cwd.depth()
                    : Infinity,
                platform: this.platform,
                nocase: this.nocase,
                includeChildMatches: this.includeChildMatches,
            }).walk()),
        ];
    }
    walkSync() {
        return [
            ...new GlobWalker(this.patterns, this.scurry.cwd, {
                ...this.opts,
                maxDepth: this.maxDepth !== Infinity ?
                    this.maxDepth + this.scurry.cwd.depth()
                    : Infinity,
                platform: this.platform,
                nocase: this.nocase,
                includeChildMatches: this.includeChildMatches,
            }).walkSync(),
        ];
    }
    stream() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ?
                this.maxDepth + this.scurry.cwd.depth()
                : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches,
        }).stream();
    }
    streamSync() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ?
                this.maxDepth + this.scurry.cwd.depth()
                : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches,
        }).streamSync();
    }
    /**
     * Default sync iteration function. Returns a Generator that
     * iterates over the results.
     */
    iterateSync() {
        return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    /**
     * Default async iteration function. Returns an AsyncGenerator that
     * iterates over the results.
     */
    iterate() {
        return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}

/**
 * Return true if the patterns provided contain any magic glob characters,
 * given the options provided.
 *
 * Brace expansion is not considered "magic" unless the `magicalBraces` option
 * is set, as brace expansion just turns one string into an array of strings.
 * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and
 * `'xby'` both do not contain any magic glob characters, and it's treated the
 * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`
 * is in the options, brace expansion _is_ treated as a pattern having magic.
 */
const hasMagic = (pattern, options = {}) => {
    if (!Array.isArray(pattern)) {
        pattern = [pattern];
    }
    for (const p of pattern) {
        if (new Minimatch(p, options).hasMagic())
            return true;
    }
    return false;
};

function globStreamSync(pattern, options = {}) {
    return new Glob(pattern, options).streamSync();
}
function globStream(pattern, options = {}) {
    return new Glob(pattern, options).stream();
}
function globSync(pattern, options = {}) {
    return new Glob(pattern, options).walkSync();
}
async function glob_(pattern, options = {}) {
    return new Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
    return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern, options = {}) {
    return new Glob(pattern, options).iterate();
}
// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc
const streamSync = globStreamSync;
const stream = Object.assign(globStream, { sync: globStreamSync });
const iterateSync = globIterateSync;
const iterate = Object.assign(globIterate, {
    sync: globIterateSync,
});
const sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync,
});
const glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync,
    globStream,
    stream,
    globStreamSync,
    streamSync,
    globIterate,
    iterate,
    globIterateSync,
    iterateSync,
    Glob,
    hasMagic,
    escape,
    unescape,
});
glob.glob = glob;

let Position$1 = class Position {
    line;
    column;
    static from(position) {
        return new Position(position.line, position.column);
    }
    constructor(line, column) {
        this.line = line;
        this.column = column;
    }
    toHash() {
        return { line: this.line, column: this.column };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `(${this.line}:${this.column})`;
    }
    inspect() {
        return `#<Herb::Position ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
};

let Location$1 = class Location {
    start;
    end;
    static from(location) {
        const start = Position$1.from(location.start);
        const end = Position$1.from(location.end);
        return new Location(start, end);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toHash() {
        return {
            start: this.start.toHash(),
            end: this.end.toHash(),
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `${this.start.treeInspect()}-${this.end.treeInspect()}`;
    }
    treeInspectWithLabel() {
        return `(location: ${this.treeInspect()})`;
    }
    inspect() {
        return `#<Herb::Location ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
};

let Range$1 = class Range {
    start;
    end;
    static from(range) {
        return new Range(range[0], range[1]);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toArray() {
        return [this.start, this.end];
    }
    toJSON() {
        return this.toArray();
    }
    treeInspect() {
        return `[${this.start}, ${this.end}]`;
    }
    inspect() {
        return `#<Herb::Range ${this.toArray()}>`;
    }
    toString() {
        return this.inspect();
    }
};

let Token$1 = class Token {
    value;
    range;
    location;
    type;
    static from(token) {
        return new Token(token.value, Range$1.from(token.range), Location$1.from(token.location), token.type);
    }
    constructor(value, range, location, type) {
        this.value = value;
        this.range = range;
        this.location = location;
        this.type = type;
    }
    toHash() {
        return {
            value: this.value,
            range: this.range?.toArray(),
            location: this.location?.toHash(),
            type: this.type,
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `"${this.value}" ${this.location.treeInspectWithLabel()}`;
    }
    valueInspect() {
        return this.type === "TOKEN_EOF"
            ? JSON.stringify("<EOF>")
            : JSON.stringify(this.value);
    }
    inspect() {
        return `#<Herb::Token type="${this.type}" value=${this.valueInspect()} range=${this.range.treeInspect()} start=${this.location.start.treeInspect()} end=${this.location.end.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
};

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.7.5/templates/javascript/packages/core/src/errors.ts.erb
let HerbError$1 = class HerbError {
    type;
    message;
    location;
    severity = "error";
    source = "parser";
    get code() {
        return this.type;
    }
    static from(error) {
        return fromSerializedError$1(error);
    }
    constructor(type, message, location) {
        this.type = type;
        this.message = message;
        this.location = location;
    }
    toJSON() {
        return {
            type: this.type,
            message: this.message,
            location: this.location.toJSON(),
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
};
let UnexpectedError$1 = class UnexpectedError extends HerbError$1 {
    description;
    expected;
    found;
    static from(data) {
        return new UnexpectedError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            description: data.description,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.description = props.description;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_ERROR",
            description: this.description,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` description: ${JSON.stringify(this.description)}\n`;
        output += ` expected: ${JSON.stringify(this.expected)}\n`;
        output += ` found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
};
let UnexpectedTokenError$1 = class UnexpectedTokenError extends HerbError$1 {
    expected_type;
    found;
    static from(data) {
        return new UnexpectedTokenError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            expected_type: data.expected_type,
            found: data.found ? Token$1.from(data.found) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.expected_type = props.expected_type;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_TOKEN_ERROR",
            expected_type: this.expected_type,
            found: this.found ? this.found.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedTokenError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` expected_type: ${JSON.stringify(this.expected_type)}\n`;
        output += ` found: ${this.found ? this.found.treeInspect() : ""}\n`;
        return output;
    }
};
let MissingOpeningTagError$1 = class MissingOpeningTagError extends HerbError$1 {
    closing_tag;
    static from(data) {
        return new MissingOpeningTagError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            closing_tag: data.closing_tag ? Token$1.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_OPENING_TAG_ERROR",
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingOpeningTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : ""}\n`;
        return output;
    }
};
let MissingClosingTagError$1 = class MissingClosingTagError extends HerbError$1 {
    opening_tag;
    static from(data) {
        return new MissingClosingTagError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            opening_tag: data.opening_tag ? Token$1.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_CLOSING_TAG_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : ""}\n`;
        return output;
    }
};
let TagNamesMismatchError$1 = class TagNamesMismatchError extends HerbError$1 {
    opening_tag;
    closing_tag;
    static from(data) {
        return new TagNamesMismatchError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            opening_tag: data.opening_tag ? Token$1.from(data.opening_tag) : null,
            closing_tag: data.closing_tag ? Token$1.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "TAG_NAMES_MISMATCH_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ TagNamesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : ""}\n`;
        output += ` closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : ""}\n`;
        return output;
    }
};
let QuotesMismatchError$1 = class QuotesMismatchError extends HerbError$1 {
    opening_quote;
    closing_quote;
    static from(data) {
        return new QuotesMismatchError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            opening_quote: data.opening_quote ? Token$1.from(data.opening_quote) : null,
            closing_quote: data.closing_quote ? Token$1.from(data.closing_quote) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_quote = props.opening_quote;
        this.closing_quote = props.closing_quote;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "QUOTES_MISMATCH_ERROR",
            opening_quote: this.opening_quote ? this.opening_quote.toJSON() : null,
            closing_quote: this.closing_quote ? this.closing_quote.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ QuotesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_quote: ${this.opening_quote ? this.opening_quote.treeInspect() : ""}\n`;
        output += ` closing_quote: ${this.closing_quote ? this.closing_quote.treeInspect() : ""}\n`;
        return output;
    }
};
let VoidElementClosingTagError$1 = class VoidElementClosingTagError extends HerbError$1 {
    tag_name;
    expected;
    found;
    static from(data) {
        return new VoidElementClosingTagError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            tag_name: data.tag_name ? Token$1.from(data.tag_name) : null,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.tag_name = props.tag_name;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "VOID_ELEMENT_CLOSING_TAG_ERROR",
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ VoidElementClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` expected: ${JSON.stringify(this.expected)}\n`;
        output += ` found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
};
let UnclosedElementError$1 = class UnclosedElementError extends HerbError$1 {
    opening_tag;
    static from(data) {
        return new UnclosedElementError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            opening_tag: data.opening_tag ? Token$1.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNCLOSED_ELEMENT_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnclosedElementError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : ""}\n`;
        return output;
    }
};
let RubyParseError$1 = class RubyParseError extends HerbError$1 {
    error_message;
    diagnostic_id;
    level;
    static from(data) {
        return new RubyParseError({
            type: data.type,
            message: data.message,
            location: Location$1.from(data.location),
            error_message: data.error_message,
            diagnostic_id: data.diagnostic_id,
            level: data.level,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.error_message = props.error_message;
        this.diagnostic_id = props.diagnostic_id;
        this.level = props.level;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "RUBY_PARSE_ERROR",
            error_message: this.error_message,
            diagnostic_id: this.diagnostic_id,
            level: this.level,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ RubyParseError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` error_message: ${JSON.stringify(this.error_message)}\n`;
        output += ` diagnostic_id: ${JSON.stringify(this.diagnostic_id)}\n`;
        output += ` level: ${JSON.stringify(this.level)}\n`;
        return output;
    }
};
function fromSerializedError$1(error) {
    switch (error.type) {
        case "UNEXPECTED_ERROR": return UnexpectedError$1.from(error);
        case "UNEXPECTED_TOKEN_ERROR": return UnexpectedTokenError$1.from(error);
        case "MISSING_OPENING_TAG_ERROR": return MissingOpeningTagError$1.from(error);
        case "MISSING_CLOSING_TAG_ERROR": return MissingClosingTagError$1.from(error);
        case "TAG_NAMES_MISMATCH_ERROR": return TagNamesMismatchError$1.from(error);
        case "QUOTES_MISMATCH_ERROR": return QuotesMismatchError$1.from(error);
        case "VOID_ELEMENT_CLOSING_TAG_ERROR": return VoidElementClosingTagError$1.from(error);
        case "UNCLOSED_ELEMENT_ERROR": return UnclosedElementError$1.from(error);
        case "RUBY_PARSE_ERROR": return RubyParseError$1.from(error);
        default:
            throw new Error(`Unknown node type: ${error.type}`);
    }
}

function ensureString(object) {
    if (typeof object === "string") {
        return object;
    }
    throw new TypeError("Argument must be a string");
}
function convertToUTF8$1(string) {
    const bytes = [];
    for (let i = 0; i < string.length; i++) {
        bytes.push(string.charCodeAt(i));
    }
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(new Uint8Array(bytes));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.7.5/templates/javascript/packages/core/src/nodes.ts.erb
let Node$1 = class Node {
    type;
    location;
    errors;
    static from(node) {
        return fromSerializedNode$1(node);
    }
    static get type() {
        throw new Error("AST_NODE");
    }
    constructor(type, location, errors) {
        this.type = type;
        this.location = location;
        this.errors = errors;
    }
    toJSON() {
        return {
            type: this.type,
            location: this.location.toJSON(),
            errors: this.errors,
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
    is(nodeClass) {
        return this.type === nodeClass.type;
    }
    isOfType(type) {
        return this.type === type;
    }
    get isSingleLine() {
        return this.location.start.line === this.location.end.line;
    }
    inspectArray(array, prefix) {
        if (!array)
            return "\n";
        if (array.length === 0)
            return "[]\n";
        let output = `(${array.length} item${array.length === 1 ? "" : "s"})\n`;
        array.forEach((item, index) => {
            const isLast = index === array.length - 1;
            if (item instanceof Node || item instanceof HerbError$1) {
                output += this.inspectNode(item, prefix, isLast ? "    " : "   ", isLast, false);
            }
            else {
                const symbol = isLast ? " " : " ";
                output += `${prefix}${symbol} ${item}\n`;
            }
        });
        output += `${prefix}\n`;
        return output;
    }
    inspectNode(node, prefix, prefix2 = "    ", last = true, trailingNewline = true) {
        if (!node)
            return "\n";
        let output = trailingNewline ? "\n" : "";
        output += `${prefix}`;
        output += last ? " " : " ";
        output += node
            .treeInspect()
            .trimStart()
            .split("\n")
            .map((line, index) => index === 0 ? line.trimStart() : `${prefix}${prefix2}${line}`)
            .join("\n")
            .trimStart();
        output += `\n`;
        return output;
    }
};
let DocumentNode$1 = class DocumentNode extends Node$1 {
    children;
    static get type() {
        return "AST_DOCUMENT_NODE";
    }
    static from(data) {
        return new DocumentNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitDocumentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_DOCUMENT_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ DocumentNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
};
let LiteralNode$1 = class LiteralNode extends Node$1 {
    content;
    static get type() {
        return "AST_LITERAL_NODE";
    }
    static from(data) {
        return new LiteralNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8$1(props.content);
    }
    accept(visitor) {
        visitor.visitLiteralNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_LITERAL_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ LiteralNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` content: ${this.content ? JSON.stringify(this.content) : ""}\n`;
        return output;
    }
};
let HTMLOpenTagNode$1 = class HTMLOpenTagNode extends Node$1 {
    tag_opening;
    tag_name;
    tag_closing;
    children;
    is_void;
    static get type() {
        return "AST_HTML_OPEN_TAG_NODE";
    }
    static from(data) {
        return new HTMLOpenTagNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token$1.from(data.tag_name) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLOpenTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_OPEN_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLOpenTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : ""}\n`;
        return output;
    }
};
let HTMLCloseTagNode$1 = class HTMLCloseTagNode extends Node$1 {
    tag_opening;
    tag_name;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_CLOSE_TAG_NODE";
    }
    static from(data) {
        return new HTMLCloseTagNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token$1.from(data.tag_name) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLCloseTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_CLOSE_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCloseTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
};
let HTMLElementNode$1 = class HTMLElementNode extends Node$1 {
    open_tag;
    tag_name;
    body;
    close_tag;
    is_void;
    source;
    static get type() {
        return "AST_HTML_ELEMENT_NODE";
    }
    static from(data) {
        return new HTMLElementNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            open_tag: data.open_tag ? fromSerializedNode$1((data.open_tag)) : null,
            tag_name: data.tag_name ? Token$1.from(data.tag_name) : null,
            body: (data.body || []).map(node => fromSerializedNode$1(node)),
            close_tag: data.close_tag ? fromSerializedNode$1((data.close_tag)) : null,
            is_void: data.is_void,
            source: data.source,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_tag = props.open_tag;
        this.tag_name = props.tag_name;
        this.body = props.body;
        this.close_tag = props.close_tag;
        this.is_void = props.is_void;
        this.source = props.source;
    }
    accept(visitor) {
        visitor.visitHTMLElementNode(this);
    }
    childNodes() {
        return [
            this.open_tag,
            ...this.body,
            this.close_tag,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.open_tag ? this.open_tag.recursiveErrors() : [],
            ...this.body.map(node => node.recursiveErrors()),
            this.close_tag ? this.close_tag.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ELEMENT_NODE",
            open_tag: this.open_tag ? this.open_tag.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            close_tag: this.close_tag ? this.close_tag.toJSON() : null,
            is_void: this.is_void,
            source: this.source,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLElementNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` open_tag: ${this.inspectNode(this.open_tag, "   ")}`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` body: ${this.inspectArray(this.body, "   ")}`;
        output += ` close_tag: ${this.inspectNode(this.close_tag, "   ")}`;
        output += ` is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : ""}\n`;
        output += ` source: ${this.source ? JSON.stringify(this.source) : ""}\n`;
        return output;
    }
};
let HTMLAttributeValueNode$1 = class HTMLAttributeValueNode extends Node$1 {
    open_quote;
    children;
    close_quote;
    quoted;
    static get type() {
        return "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    static from(data) {
        return new HTMLAttributeValueNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            open_quote: data.open_quote ? Token$1.from(data.open_quote) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            close_quote: data.close_quote ? Token$1.from(data.close_quote) : null,
            quoted: data.quoted,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_quote = props.open_quote;
        this.children = props.children;
        this.close_quote = props.close_quote;
        this.quoted = props.quoted;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeValueNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_VALUE_NODE",
            open_quote: this.open_quote ? this.open_quote.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            close_quote: this.close_quote ? this.close_quote.toJSON() : null,
            quoted: this.quoted,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeValueNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` open_quote: ${this.open_quote ? this.open_quote.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` close_quote: ${this.close_quote ? this.close_quote.treeInspect() : ""}\n`;
        output += ` quoted: ${typeof this.quoted === 'boolean' ? String(this.quoted) : ""}\n`;
        return output;
    }
};
let HTMLAttributeNameNode$1 = class HTMLAttributeNameNode extends Node$1 {
    children;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NAME_NODE";
    }
    static from(data) {
        return new HTMLAttributeNameNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNameNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NAME_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNameNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
};
let HTMLAttributeNode$1 = class HTMLAttributeNode extends Node$1 {
    name;
    equals;
    value;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NODE";
    }
    static from(data) {
        return new HTMLAttributeNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            name: data.name ? fromSerializedNode$1((data.name)) : null,
            equals: data.equals ? Token$1.from(data.equals) : null,
            value: data.value ? fromSerializedNode$1((data.value)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.name = props.name;
        this.equals = props.equals;
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNode(this);
    }
    childNodes() {
        return [
            this.name,
            this.value,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.name ? this.name.recursiveErrors() : [],
            this.value ? this.value.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NODE",
            name: this.name ? this.name.toJSON() : null,
            equals: this.equals ? this.equals.toJSON() : null,
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` name: ${this.inspectNode(this.name, "   ")}`;
        output += ` equals: ${this.equals ? this.equals.treeInspect() : ""}\n`;
        output += ` value: ${this.inspectNode(this.value, "    ")}`;
        return output;
    }
};
let HTMLTextNode$1 = class HTMLTextNode extends Node$1 {
    content;
    static get type() {
        return "AST_HTML_TEXT_NODE";
    }
    static from(data) {
        return new HTMLTextNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8$1(props.content);
    }
    accept(visitor) {
        visitor.visitHTMLTextNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_TEXT_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLTextNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` content: ${this.content ? JSON.stringify(this.content) : ""}\n`;
        return output;
    }
};
let HTMLCommentNode$1 = class HTMLCommentNode extends Node$1 {
    comment_start;
    children;
    comment_end;
    static get type() {
        return "AST_HTML_COMMENT_NODE";
    }
    static from(data) {
        return new HTMLCommentNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            comment_start: data.comment_start ? Token$1.from(data.comment_start) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            comment_end: data.comment_end ? Token$1.from(data.comment_end) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.comment_start = props.comment_start;
        this.children = props.children;
        this.comment_end = props.comment_end;
    }
    accept(visitor) {
        visitor.visitHTMLCommentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_COMMENT_NODE",
            comment_start: this.comment_start ? this.comment_start.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            comment_end: this.comment_end ? this.comment_end.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCommentNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` comment_start: ${this.comment_start ? this.comment_start.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` comment_end: ${this.comment_end ? this.comment_end.treeInspect() : ""}\n`;
        return output;
    }
};
let HTMLDoctypeNode$1 = class HTMLDoctypeNode extends Node$1 {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_DOCTYPE_NODE";
    }
    static from(data) {
        return new HTMLDoctypeNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLDoctypeNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_DOCTYPE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLDoctypeNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
};
let XMLDeclarationNode$1 = class XMLDeclarationNode extends Node$1 {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_XML_DECLARATION_NODE";
    }
    static from(data) {
        return new XMLDeclarationNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitXMLDeclarationNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_XML_DECLARATION_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ XMLDeclarationNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
};
let CDATANode$1 = class CDATANode extends Node$1 {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_CDATA_NODE";
    }
    static from(data) {
        return new CDATANode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitCDATANode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_CDATA_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ CDATANode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
};
let WhitespaceNode$1 = class WhitespaceNode extends Node$1 {
    value;
    static get type() {
        return "AST_WHITESPACE_NODE";
    }
    static from(data) {
        return new WhitespaceNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            value: data.value ? Token$1.from(data.value) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitWhitespaceNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_WHITESPACE_NODE",
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ WhitespaceNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` value: ${this.value ? this.value.treeInspect() : ""}\n`;
        return output;
    }
};
let ERBContentNode$1 = class ERBContentNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    // no-op for analyzed_ruby
    parsed;
    valid;
    static get type() {
        return "AST_ERB_CONTENT_NODE";
    }
    static from(data) {
        return new ERBContentNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            // no-op for analyzed_ruby
            parsed: data.parsed,
            valid: data.valid,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        // no-op for analyzed_ruby
        this.parsed = props.parsed;
        this.valid = props.valid;
    }
    accept(visitor) {
        visitor.visitERBContentNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CONTENT_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            // no-op for analyzed_ruby
            parsed: this.parsed,
            valid: this.valid,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBContentNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        // no-op for analyzed_ruby
        output += ` parsed: ${typeof this.parsed === 'boolean' ? String(this.parsed) : ""}\n`;
        output += ` valid: ${typeof this.valid === 'boolean' ? String(this.valid) : ""}\n`;
        return output;
    }
};
let ERBEndNode$1 = class ERBEndNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_END_NODE";
    }
    static from(data) {
        return new ERBEndNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBEndNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_END_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEndNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
};
let ERBElseNode$1 = class ERBElseNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ELSE_NODE";
    }
    static from(data) {
        return new ERBElseNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBElseNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ELSE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBElseNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
let ERBIfNode$1 = class ERBIfNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    end_node;
    static get type() {
        return "AST_ERB_IF_NODE";
    }
    static from(data) {
        return new ERBIfNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            subsequent: data.subsequent ? fromSerializedNode$1((data.subsequent)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBIfNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IF_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBIfNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` subsequent: ${this.inspectNode(this.subsequent, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBBlockNode$1 = class ERBBlockNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    body;
    end_node;
    static get type() {
        return "AST_ERB_BLOCK_NODE";
    }
    static from(data) {
        return new ERBBlockNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            body: (data.body || []).map(node => fromSerializedNode$1(node)),
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.body = props.body;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBlockNode(this);
    }
    childNodes() {
        return [
            ...this.body,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.body.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BLOCK_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBlockNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` body: ${this.inspectArray(this.body, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBWhenNode$1 = class ERBWhenNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_WHEN_NODE";
    }
    static from(data) {
        return new ERBWhenNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBWhenNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHEN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhenNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
let ERBCaseNode$1 = class ERBCaseNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_NODE";
    }
    static from(data) {
        return new ERBCaseNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode$1(node)),
            else_clause: data.else_clause ? fromSerializedNode$1((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` conditions: ${this.inspectArray(this.conditions, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBCaseMatchNode$1 = class ERBCaseMatchNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_MATCH_NODE";
    }
    static from(data) {
        return new ERBCaseMatchNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode$1(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode$1(node)),
            else_clause: data.else_clause ? fromSerializedNode$1((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseMatchNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_MATCH_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseMatchNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` conditions: ${this.inspectArray(this.conditions, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBWhileNode$1 = class ERBWhileNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_WHILE_NODE";
    }
    static from(data) {
        return new ERBWhileNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBWhileNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHILE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhileNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBUntilNode$1 = class ERBUntilNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_UNTIL_NODE";
    }
    static from(data) {
        return new ERBUntilNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUntilNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNTIL_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUntilNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBForNode$1 = class ERBForNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_FOR_NODE";
    }
    static from(data) {
        return new ERBForNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBForNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_FOR_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBForNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBRescueNode$1 = class ERBRescueNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    static get type() {
        return "AST_ERB_RESCUE_NODE";
    }
    static from(data) {
        return new ERBRescueNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            subsequent: data.subsequent ? fromSerializedNode$1((data.subsequent)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
    }
    accept(visitor) {
        visitor.visitERBRescueNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_RESCUE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBRescueNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` subsequent: ${this.inspectNode(this.subsequent, "    ")}`;
        return output;
    }
};
let ERBEnsureNode$1 = class ERBEnsureNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ENSURE_NODE";
    }
    static from(data) {
        return new ERBEnsureNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBEnsureNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ENSURE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEnsureNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
let ERBBeginNode$1 = class ERBBeginNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    rescue_clause;
    else_clause;
    ensure_clause;
    end_node;
    static get type() {
        return "AST_ERB_BEGIN_NODE";
    }
    static from(data) {
        return new ERBBeginNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            rescue_clause: data.rescue_clause ? fromSerializedNode$1((data.rescue_clause)) : null,
            else_clause: data.else_clause ? fromSerializedNode$1((data.else_clause)) : null,
            ensure_clause: data.ensure_clause ? fromSerializedNode$1((data.ensure_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.rescue_clause = props.rescue_clause;
        this.else_clause = props.else_clause;
        this.ensure_clause = props.ensure_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBeginNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.rescue_clause,
            this.else_clause,
            this.ensure_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.rescue_clause ? this.rescue_clause.recursiveErrors() : [],
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.ensure_clause ? this.ensure_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BEGIN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            rescue_clause: this.rescue_clause ? this.rescue_clause.toJSON() : null,
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            ensure_clause: this.ensure_clause ? this.ensure_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBeginNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` rescue_clause: ${this.inspectNode(this.rescue_clause, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` ensure_clause: ${this.inspectNode(this.ensure_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBUnlessNode$1 = class ERBUnlessNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_UNLESS_NODE";
    }
    static from(data) {
        return new ERBUnlessNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
            else_clause: data.else_clause ? fromSerializedNode$1((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode$1((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUnlessNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNLESS_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUnlessNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
};
let ERBYieldNode$1 = class ERBYieldNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_YIELD_NODE";
    }
    static from(data) {
        return new ERBYieldNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBYieldNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_YIELD_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBYieldNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
};
let ERBInNode$1 = class ERBInNode extends Node$1 {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_IN_NODE";
    }
    static from(data) {
        return new ERBInNode({
            type: data.type,
            location: Location$1.from(data.location),
            errors: (data.errors || []).map(error => HerbError$1.from(error)),
            tag_opening: data.tag_opening ? Token$1.from(data.tag_opening) : null,
            content: data.content ? Token$1.from(data.content) : null,
            tag_closing: data.tag_closing ? Token$1.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode$1(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBInNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBInNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
};
function fromSerializedNode$1(node) {
    switch (node.type) {
        case "AST_DOCUMENT_NODE": return DocumentNode$1.from(node);
        case "AST_LITERAL_NODE": return LiteralNode$1.from(node);
        case "AST_HTML_OPEN_TAG_NODE": return HTMLOpenTagNode$1.from(node);
        case "AST_HTML_CLOSE_TAG_NODE": return HTMLCloseTagNode$1.from(node);
        case "AST_HTML_ELEMENT_NODE": return HTMLElementNode$1.from(node);
        case "AST_HTML_ATTRIBUTE_VALUE_NODE": return HTMLAttributeValueNode$1.from(node);
        case "AST_HTML_ATTRIBUTE_NAME_NODE": return HTMLAttributeNameNode$1.from(node);
        case "AST_HTML_ATTRIBUTE_NODE": return HTMLAttributeNode$1.from(node);
        case "AST_HTML_TEXT_NODE": return HTMLTextNode$1.from(node);
        case "AST_HTML_COMMENT_NODE": return HTMLCommentNode$1.from(node);
        case "AST_HTML_DOCTYPE_NODE": return HTMLDoctypeNode$1.from(node);
        case "AST_XML_DECLARATION_NODE": return XMLDeclarationNode$1.from(node);
        case "AST_CDATA_NODE": return CDATANode$1.from(node);
        case "AST_WHITESPACE_NODE": return WhitespaceNode$1.from(node);
        case "AST_ERB_CONTENT_NODE": return ERBContentNode$1.from(node);
        case "AST_ERB_END_NODE": return ERBEndNode$1.from(node);
        case "AST_ERB_ELSE_NODE": return ERBElseNode$1.from(node);
        case "AST_ERB_IF_NODE": return ERBIfNode$1.from(node);
        case "AST_ERB_BLOCK_NODE": return ERBBlockNode$1.from(node);
        case "AST_ERB_WHEN_NODE": return ERBWhenNode$1.from(node);
        case "AST_ERB_CASE_NODE": return ERBCaseNode$1.from(node);
        case "AST_ERB_CASE_MATCH_NODE": return ERBCaseMatchNode$1.from(node);
        case "AST_ERB_WHILE_NODE": return ERBWhileNode$1.from(node);
        case "AST_ERB_UNTIL_NODE": return ERBUntilNode$1.from(node);
        case "AST_ERB_FOR_NODE": return ERBForNode$1.from(node);
        case "AST_ERB_RESCUE_NODE": return ERBRescueNode$1.from(node);
        case "AST_ERB_ENSURE_NODE": return ERBEnsureNode$1.from(node);
        case "AST_ERB_BEGIN_NODE": return ERBBeginNode$1.from(node);
        case "AST_ERB_UNLESS_NODE": return ERBUnlessNode$1.from(node);
        case "AST_ERB_YIELD_NODE": return ERBYieldNode$1.from(node);
        case "AST_ERB_IN_NODE": return ERBInNode$1.from(node);
        default:
            throw new Error(`Unknown node type: ${node.type}`);
    }
}

let Result$1 = class Result {
    source;
    warnings;
    errors;
    constructor(source, warnings = [], errors = []) {
        this.source = source;
        this.warnings = warnings || [];
        this.errors = errors || [];
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return this.errors.length === 0;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        return this.errors.length > 0;
    }
};

let HerbWarning$1 = class HerbWarning {
    message;
    location;
    static from(warning) {
        return new HerbWarning(warning.message, Location$1.from(warning.location));
    }
    constructor(message, location) {
        this.message = message;
        this.location = location;
    }
};

/**
 * Represents the result of a parsing operation, extending the base `Result` class.
 * It contains the parsed document node, source code, warnings, and errors.
 */
let ParseResult$1 = class ParseResult extends Result$1 {
    /** The document node generated from the source code. */
    value;
    /**
     * Creates a `ParseResult` instance from a serialized result.
     * @param result - The serialized parse result containing the value and source.
     * @returns A new `ParseResult` instance.
     */
    static from(result) {
        return new ParseResult(DocumentNode$1.from(result.value), result.source, result.warnings.map((warning) => HerbWarning$1.from(warning)), result.errors.map((error) => HerbError$1.from(error)));
    }
    /**
     * Constructs a new `ParseResult`.
     * @param value - The document node.
     * @param source - The source code that was parsed.
     * @param warnings - An array of warnings encountered during parsing.
     * @param errors - An array of errors encountered during parsing.
     */
    constructor(value, source, warnings = [], errors = []) {
        super(source, warnings, errors);
        this.value = value;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        // Consider errors on this result and recursively in the document tree
        return this.recursiveErrors().length > 0;
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return !this.failed;
    }
    /**
     * Returns a pretty-printed JSON string of the errors.
     * @returns A string representation of the errors.
     */
    prettyErrors() {
        return JSON.stringify([...this.errors, ...this.value.errors], null, 2);
    }
    recursiveErrors() {
        return [...this.errors, ...this.value.recursiveErrors()];
    }
    /**
     * Returns a pretty-printed string of the parse result.
     * @returns A string representation of the parse result.
     */
    inspect() {
        return this.value.inspect();
    }
    /**
     * Accepts a visitor to traverse the document node.
     * @param visitor - The visitor instance.
     */
    visit(visitor) {
        visitor.visit(this.value);
    }
};

var name$1 = "@herb-tools/core";
var version$1 = "0.7.5";
var packageJSON = {
	name: name$1,
	version: version$1};

class TokenList {
    list;
    static from(list) {
        return new TokenList(list.map((token) => Token$1.from(token)));
    }
    constructor(list) {
        this.list = list;
    }
    get length() {
        return this.list.length;
    }
    get tokens() {
        return this.list;
    }
    [Symbol.iterator]() {
        return this.list[Symbol.iterator]();
    }
    at(index) {
        return this.list.at(index);
    }
    forEach(callback) {
        this.list.forEach(callback);
    }
    map(callback) {
        return this.list.map(callback);
    }
    filter(predicate) {
        return this.list.filter(predicate);
    }
    __getobj__() {
        return this.list;
    }
    inspect() {
        return this.list.map((token) => token.inspect()).join("\n") + "\n";
    }
    toString() {
        return this.inspect();
    }
}

/**
 * Represents the result of a lexical analysis, extending the base `Result` class.
 * It contains the token list, source code, warnings, and errors.
 */
class LexResult extends Result$1 {
    /** The list of tokens generated from the source code. */
    value;
    /**
     * Creates a `LexResult` instance from a serialized result.
     * @param result - The serialized lexical result containing tokens, source, warnings, and errors.
     * @returns A new `LexResult` instance.
     */
    static from(result) {
        return new LexResult(TokenList.from(result.tokens || []), result.source, result.warnings.map((warning) => HerbWarning$1.from(warning)), result.errors.map((error) => HerbError$1.from(error)));
    }
    /**
     * Constructs a new `LexResult`.
     * @param value - The list of tokens.
     * @param source - The source code that was lexed.
     * @param warnings - An array of warnings encountered during lexing.
     * @param errors - An array of errors encountered during lexing.
     */
    constructor(value, source, warnings = [], errors = []) {
        super(source, warnings, errors);
        this.value = value;
    }
    /**
     * Determines if the lexing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return this.errors.length === 0;
    }
    /**
     * Determines if the lexing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        return this.errors.length > 0;
    }
    /**
     * Converts the `LexResult` to a JSON representation.
     * @returns An object containing the token list, source, warnings, and errors.
     */
    toJSON() {
        return {
            value: this.value,
            source: this.source,
            warnings: this.warnings,
            errors: this.errors,
        };
    }
}

const DEFAULT_PARSER_OPTIONS = {
    track_whitespace: false,
};

/**
 * The main Herb parser interface, providing methods to lex and parse input.
 */
class HerbBackend {
    /** The backend instance handling lexing and parsing. */
    backend = undefined;
    backendPromise;
    /**
     * Creates a new Herb instance.
     * @param backendPromise - A promise resolving to a `LibHerbBackend` implementation for lexing and parsing.
     * @throws Error if no valid backend is provided.
     */
    constructor(backendPromise) {
        if (!backendPromise) {
            throw new Error("No LibHerb backend provided");
        }
        this.backendPromise = backendPromise;
    }
    /**
     * Loads the backend by resolving the backend promise.
     * @returns A promise containing the resolved `HerbBackend` instance after loading it.
     */
    async load() {
        const backend = await this.backendPromise();
        this.backend = backend;
        return this;
    }
    /**
     * Lexes the given source string into a `LexResult`.
     * @param source - The source code to lex.
     * @returns A `LexResult` instance.
     * @throws Error if the backend is not loaded.
     */
    lex(source) {
        this.ensureBackend();
        return LexResult.from(this.backend.lex(ensureString(source)));
    }
    /**
     * Lexes a file.
     * @param path - The file path to lex.
     * @returns A `LexResult` instance.
     * @throws Error if the backend is not loaded.
     */
    lexFile(path) {
        this.ensureBackend();
        return LexResult.from(this.backend.lexFile(ensureString(path)));
    }
    /**
     * Parses the given source string into a `ParseResult`.
     * @param source - The source code to parse.
     * @param options - Optional parsing options.
     * @returns A `ParseResult` instance.
     * @throws Error if the backend is not loaded.
     */
    parse(source, options) {
        this.ensureBackend();
        const mergedOptions = { ...DEFAULT_PARSER_OPTIONS, ...options };
        return ParseResult$1.from(this.backend.parse(ensureString(source), mergedOptions));
    }
    /**
     * Parses a file.
     * @param path - The file path to parse.
     * @returns A `ParseResult` instance.
     * @throws Error if the backend is not loaded.
     */
    parseFile(path) {
        this.ensureBackend();
        return ParseResult$1.from(this.backend.parseFile(ensureString(path)));
    }
    /**
     * Extracts embedded Ruby code from the given source.
     * @param source - The source code to extract Ruby from.
     * @returns The extracted Ruby code as a string.
     * @throws Error if the backend is not loaded.
     */
    extractRuby(source) {
        this.ensureBackend();
        return this.backend.extractRuby(ensureString(source));
    }
    /**
     * Extracts HTML from the given source.
     * @param source - The source code to extract HTML from.
     * @returns The extracted HTML as a string.
     * @throws Error if the backend is not loaded.
     */
    extractHTML(source) {
        this.ensureBackend();
        return this.backend.extractHTML(ensureString(source));
    }
    /**
     * Gets the Herb version information, including the core and backend versions.
     * @returns A version string containing backend, core, and libherb versions.
     * @throws Error if the backend is not loaded.
     */
    get version() {
        this.ensureBackend();
        const backend = this.backendVersion();
        const core = `${packageJSON.name}@${packageJSON.version}`;
        const libherb = this.backend.version();
        return `${backend}, ${core}, ${libherb}`;
    }
    /**
     * Ensures that the backend is loaded.
     * @throws Error if the backend is not loaded.
     */
    ensureBackend() {
        if (!this.isLoaded) {
            throw new Error("Herb backend is not loaded. Call `await Herb.load()` first.");
        }
    }
    /**
     * Checks if the backend is loaded.
     * @returns True if the backend is loaded, false otherwise.
     */
    get isLoaded() {
        return this.backend !== undefined;
    }
}

var name$2 = "@herb-tools/node-wasm";
var version$2 = "0.7.5";

class HerbBackendNodeWASM extends HerbBackend {
    backendVersion() {
        return `${name$2}@${version$2}`;
    }
}

// This code implements the `-sMODULARIZE` settings by taking the generated
// JS program code (INNER_JS_CODE) and wrapping it in a factory function.

// When targetting node and ES6 we use `await import ..` in the generated code
// so the outer function needs to be marked as async.
async function Herb$1(moduleArg = {}) {
  var moduleRtn;

// include: shell.js
// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(moduleArg) => Promise<Module>
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = moduleArg;

{
  // When building an ES module `require` is not normally available.
  // We need to use `createRequire()` to construct the require()` function.
  const { createRequire } = await import('module');
  /** @suppress{duplicate} */
  var require$1 = createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('herb-lint.js', document.baseURI).href)));

}
var quit_ = (status, toThrow) => {
  throw toThrow;
};

var _scriptName = (typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('herb-lint.js', document.baseURI).href));

// Hooks that are implemented differently in different runtime environments.
var readBinary;

{
  const isNode = typeof process == 'object' && process.versions?.node && process.type != 'renderer';
  if (!isNode) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  var nodeVersion = process.versions.node;
  var numericVersion = nodeVersion.split('.').slice(0, 3);
  numericVersion = (numericVersion[0] * 10000) + (numericVersion[1] * 100) + (numericVersion[2].split('-')[0] * 1);
  if (numericVersion < 160000) {
    throw new Error('This emscripten-generated code requires node v16.0.0 (detected v' + nodeVersion + ')');
  }

  // These modules will usually be used on Node.js. Load them eagerly to avoid
  // the complexity of lazy-loading.
  var fs = require$1('fs');

  if (_scriptName.startsWith('file:')) {
    require$1('path').dirname(require$1('url').fileURLToPath(_scriptName)) + '/';
  }

// include: node_shell_read.js
readBinary = (filename) => {
  // We need to re-wrap `file://` strings to URLs.
  filename = isFileURI(filename) ? new URL(filename) : filename;
  var ret = fs.readFileSync(filename);
  assert(Buffer.isBuffer(ret));
  return ret;
};
// end include: node_shell_read.js
  if (process.argv.length > 1) {
    process.argv[1].replace(/\\/g, '/');
  }

  process.argv.slice(2);

  quit_ = (status, toThrow) => {
    process.exitCode = status;
    throw toThrow;
  };

}

var out = console.log.bind(console);
var err = console.error.bind(console);

// perform assertions in shell.js after we set up out() and err(), as otherwise
// if an assertion fails it cannot print the message

assert(true, 'web environment detected but not enabled at build time.  Add `web` to `-sENVIRONMENT` to enable.');

assert(true, 'worker environment detected but not enabled at build time.  Add `worker` to `-sENVIRONMENT` to enable.');

assert(true, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');

// end include: shell.js

// include: preamble.js
// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary;

if (typeof WebAssembly != 'object') {
  err('no native wasm support detected');
}

// Wasm globals

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we
// don't define it at all in release modes.  This matches the behaviour of
// MINIMAL_RUNTIME.
// TODO(sbc): Make this the default even without STRICT enabled.
/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed' + (text ? ': ' + text : ''));
  }
}

// We used to include malloc/free by default in the past. Show a helpful error in
// builds with assertions.

/**
 * Indicates whether filename is delivered via file protocol (as opposed to http/https)
 * @noinline
 */
var isFileURI = (filename) => filename.startsWith('file://');

// include: runtime_common.js
// include: runtime_stack_check.js
// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  var max = _emscripten_stack_get_end();
  assert((max & 3) == 0);
  // If the stack ends at address zero we write our cookies 4 bytes into the
  // stack.  This prevents interference with SAFE_HEAP and ASAN which also
  // monitor writes to address zero.
  if (max == 0) {
    max += 4;
  }
  // The stack grow downwards towards _emscripten_stack_get_end.
  // We write cookies to the final two words in the stack and detect if they are
  // ever overwritten.
  HEAPU32[((max)>>2)] = 0x02135467;
  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  HEAPU32[((0)>>2)] = 1668509029;
}

function checkStackCookie() {
  if (ABORT) return;
  var max = _emscripten_stack_get_end();
  // See writeStackCookie().
  if (max == 0) {
    max += 4;
  }
  var cookie1 = HEAPU32[((max)>>2)];
  var cookie2 = HEAPU32[(((max)+(4))>>2)];
  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {
    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
  }
  // Also test the global address 0 for integrity.
  if (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {
    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
  }
}

// Endianness check
(() => {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';
})();

function consumedModuleProp(prop) {
  if (!Object.getOwnPropertyDescriptor(Module, prop)) {
    Object.defineProperty(Module, prop, {
      configurable: true,
      set() {
        abort(`Attempt to set \`Module.${prop}\` after it has already been processed.  This can happen, for example, when code is injected via '--post-js' rather than '--pre-js'`);

      }
    });
  }
}

function makeInvalidEarlyAccess(name) {
  return () => assert(false, `call to '${name}' via reference taken before Wasm module initialization`);

}

function ignoredModuleProp(prop) {
  if (Object.getOwnPropertyDescriptor(Module, prop)) {
    abort(`\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`);
  }
}

// forcing the filesystem exports a few things by default
function isExportedByForceFilesystem(name) {
  return name === 'FS_createPath' ||
         name === 'FS_createDataFile' ||
         name === 'FS_createPreloadedFile' ||
         name === 'FS_unlink' ||
         name === 'addRunDependency' ||
         // The old FS has some functionality that WasmFS lacks.
         name === 'FS_createLazyFile' ||
         name === 'FS_createDevice' ||
         name === 'removeRunDependency';
}

/**
 * Intercept access to a global symbol.  This enables us to give informative
 * warnings/errors when folks attempt to use symbols they did not include in
 * their build, or no symbols that no longer exist.
 */
function hookGlobalSymbolAccess(sym, func) {
  if (typeof globalThis != 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
    Object.defineProperty(globalThis, sym, {
      configurable: true,
      get() {
        func();
        return undefined;
      }
    });
  }
}

function missingGlobal(sym, msg) {
  hookGlobalSymbolAccess(sym, () => {
    warnOnce(`\`${sym}\` is not longer defined by emscripten. ${msg}`);
  });
}

missingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');
missingGlobal('asm', 'Please use wasmExports instead');

function missingLibrarySymbol(sym) {
  hookGlobalSymbolAccess(sym, () => {
    // Can't `abort()` here because it would break code that does runtime
    // checks.  e.g. `if (typeof SDL === 'undefined')`.
    var msg = `\`${sym}\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;
    // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in
    // library.js, which means $name for a JS name with no prefix, or name
    // for a JS name like _name.
    var librarySymbol = sym;
    if (!librarySymbol.startsWith('_')) {
      librarySymbol = '$' + sym;
    }
    msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;
    if (isExportedByForceFilesystem(sym)) {
      msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
    }
    warnOnce(msg);
  });

  // Any symbol that is not included from the JS library is also (by definition)
  // not exported on the Module object.
  unexportedRuntimeSymbol(sym);
}

function unexportedRuntimeSymbol(sym) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Object.defineProperty(Module, sym, {
      configurable: true,
      get() {
        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;
        if (isExportedByForceFilesystem(sym)) {
          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
        }
        abort(msg);
      }
    });
  }
}

// end include: runtime_debug.js
var readyPromiseResolve, readyPromiseReject;

// Memory management

var wasmMemory;

var
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

// BigInt64Array type is not correctly defined in closure
var
/** not-@type {!BigInt64Array} */
  HEAP64,
/* BigUint64Array type is not correctly defined in closure
/** not-@type {!BigUint64Array} */
  HEAPU64;

var runtimeInitialized = false;



function updateMemoryViews() {
  var b = wasmMemory.buffer;
  HEAP8 = new Int8Array(b);
  HEAP16 = new Int16Array(b);
  HEAPU8 = new Uint8Array(b);
  HEAPU16 = new Uint16Array(b);
  HEAP32 = new Int32Array(b);
  HEAPU32 = new Uint32Array(b);
  HEAPF32 = new Float32Array(b);
  HEAPF64 = new Float64Array(b);
  HEAP64 = new BigInt64Array(b);
  HEAPU64 = new BigUint64Array(b);
}

// include: memoryprofiler.js
// end include: memoryprofiler.js
// end include: runtime_common.js
assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,
       'JS engine does not provide full typed array support');

function preRun() {
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  consumedModuleProp('preRun');
  // Begin ATPRERUNS hooks
  callRuntimeCallbacks(onPreRuns);
  // End ATPRERUNS hooks
}

function initRuntime() {
  assert(!runtimeInitialized);
  runtimeInitialized = true;

  checkStackCookie();

  // No ATINITS hooks

  wasmExports['__wasm_call_ctors']();

  // No ATPOSTCTORS hooks
}

function postRun() {
  checkStackCookie();
   // PThreads reuse the runtime from the main thread.

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  consumedModuleProp('postRun');

  // Begin ATPOSTRUNS hooks
  callRuntimeCallbacks(onPostRuns);
  // End ATPOSTRUNS hooks
}

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};
var runDependencyWatcher = null;

function addRunDependency(id) {
  runDependencies++;

  Module['monitorRunDependencies']?.(runDependencies);

  {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(() => {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err(`dependency: ${dep}`);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  }
}

function removeRunDependency(id) {
  runDependencies--;

  Module['monitorRunDependencies']?.(runDependencies);

  {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

/** @param {string|number=} what */
function abort(what) {
  Module['onAbort']?.(what);

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // definition for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  readyPromiseReject?.(e);
  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// show errors on likely calls to FS when it was not included
var FS = {
  error() {
    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');
  },
  init() { FS.error(); },
  createDataFile() { FS.error(); },
  createPreloadedFile() { FS.error(); },
  createLazyFile() { FS.error(); },
  open() { FS.error(); },
  mkdev() { FS.error(); },
  registerDevice() { FS.error(); },
  analyzePath() { FS.error(); },

  ErrnoError() { FS.error(); },
};


function createExportWrapper(name, nargs) {
  return (...args) => {
    assert(runtimeInitialized, `native function \`${name}\` called before runtime initialization`);
    var f = wasmExports[name];
    assert(f, `exported native function \`${name}\` not found`);
    // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.
    assert(args.length <= nargs, `native function \`${name}\` called with ${args.length} args but expects ${nargs}`);
    return f(...args);
  };
}

var wasmBinaryFile;

function findWasmBinary() {
  return base64Decode('AGFzbQEAAAABhwMzYAJ/fwF/YAAAYAJ/fwBgA39/fwBgAX8AYAR/f39/AGADf39/AX9gA39+fwF+YAZ/fH9/f38Bf2AGf39/f39/AGAFf39/f38AYAF/AX9gBX9/f39/AXxgCH9/f39/f39/AGAAAX9gBX9/f35+AGAEf39/fwF/YAR/fn9/AX9gBn9/f39/fgF/YAZ/f39/f38Bf2AFf39/f38Bf2AIf39/f39/f38Bf2AHf39/f39/fwF/YAl/f39/f39/f38Bf2AKf39/f39/f39/fwF/YAt/f39/f39/f39/fwF/YAF8AX9gAXwAYA1/f39/f39/f39/f39/AX9gAn9/AXxgBH9/f38BfmABfQF/YAF8AX5gAn9/AX5gBH9/fn4AYAN/fn4AYAR/f39+AGAFf39/f34AYAJ+fgF/YAJ/fgBgAnx/AXxgBX9+fn5+AGAEf35+fwBgB39/f39/f38AYAR/f39+AX5gA35/fwF/YAJ+fwF/YAR+fn5+AX9gAn98AGACf30AYAJ+fgF8ApcGHgNlbnYEZXhpdAAEA2VudhFfZW12YWxfZ2V0X2dsb2JhbAALA2VudhNfZW12YWxfc2V0X3Byb3BlcnR5AAMDZW52DV9lbXZhbF9kZWNyZWYABANlbnYVX2VtdmFsX2NyZWF0ZV9pbnZva2VyAAYDZW52DV9lbXZhbF9pbnZva2UADANlbnYWX2VtdmFsX3J1bl9kZXN0cnVjdG9ycwAEA2VudhJfZW12YWxfbmV3X2NzdHJpbmcACwNlbnYNX2VtdmFsX3R5cGVvZgALA2VudhNfZW12YWxfZ2V0X3Byb3BlcnR5AAADZW52DV9lbXZhbF9pbmNyZWYABANlbnYZX2VtYmluZF9yZWdpc3Rlcl9mdW5jdGlvbgANA2VudhFfZW12YWxfbmV3X29iamVjdAAOA2VudhBfZW12YWxfbmV3X2FycmF5AA4DZW52DV9fYXNzZXJ0X2ZhaWwABQNlbnYVX2VtYmluZF9yZWdpc3Rlcl92b2lkAAIDZW52FV9lbWJpbmRfcmVnaXN0ZXJfYm9vbAAFA2VudhhfZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIACgNlbnYXX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQADwNlbnYWX2VtYmluZF9yZWdpc3Rlcl9mbG9hdAADA2VudhtfZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmcAAgNlbnYcX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZwADA2VudhZfZW1iaW5kX3JlZ2lzdGVyX2VtdmFsAAQDZW52HF9lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcAAwNlbnYJX2Fib3J0X2pzAAEWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQhmZF9jbG9zZQALFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUAEBZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3NlZWsAEQNlbnYKX211bm1hcF9qcwASA2VudhZlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwAAsDlg2UDQELCwsLCwsLCwsLCwsLCwsLCwsAAAAAAAAAAAAACwsLCwsLCwsAAgAAAgsGCxMUExMAAAsEDgsCAAsCCwsECgsQEBUWFxYQExATExMTEBcTFhcVFhgYFRUVFRYZFxMWCwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAsECwsAAAACAgMCBAQLBRQJEAoGBQYFEAoQChQJBgUUCwQEBAQEBAQEBAQEAgICCwsABA4OCwsLABAAAAAAAAAAAAAAAAACAgsOAAsLCwsLBgALCwALBgYLBAICBAsKCwALAAYAAgALCwsLCwIEBQsDBQAGBgMADgALCwMCAwQLCwsLCwsACwsAAAILAgMDCwsCBAsGCwMQCwAABg4GCwsECwsGCwsDAwIEAgIDCwMDAwMACwMDAAsDAwMDAgMDAgICAgICAgICAwMLCwsLGgACCw4LBAsCAAsLAAsbAQ4LCwILCwICAwMDAwIDAwIDAwIAAwMDCwsDAwAFAwAFCwsACw4LAgsLAAsOCwsLCwALDgsCCwsLCwsLCwsLCwsCCwMLCwICAAADCwUDAxADBgICBAMAAQsBAAMDEAsLBgsaCw4LCwsCAgICAAsGCwsLAAsLCwsLCwsCBg4ODgsLAAsaDgsLDgACBAECBAIEAgMCAgMDAgIDAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwMDAwAFCwsACw4LAgAFCwsACw4LAgsQCwsUBAAABgYAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgIEAgIDAwAABAUGAAYCAAYDBQUGCgIFBAQEBAQECwsABAYCBQACCwMGFAQLAAQAAAQABAsEAgAGCwIECwALAAADAAsACwsAAxQLCwsACwYCCwsLBgsLCwsGCwALAAACAgICBQIAAgICAgIGBgAAEwUABAMLBgACBhAGAgsACxACAgYABgsAAgAEAAMWCwAAAAoLAwYJBQULCwAAAAAAAAULAAYGBhMLCxMUAgMAAAIQAhMGFxADAgICBAMCFAsDEAMQAAIQCxAAEAsLFAYAEBAAAAAAAAAACwILAgACAwIUFAACBgIQAgMABgYGBgAAAAYQEAsKEAACAwICAhAUEBAUAhACAgICBgkCFAoGAgYGAgYGFAIWFgULFwIDAAAAABULEAscFBQQFRQAAAIQFgAAAhYWEAIQAAIQFAIQAAIDEAICBhADFAQGEwILEBYQAAsQExAQExAQEAAQEAYTEAACAxAQEBAQEBMQEBAQEBAQExAQEBAQEBQUFBMGAAMQEAACAgYAAAYAAgAAEBAQEwAdAAsQBgYeEAAQFAAVAAAAAAICFAICAgICEAIDAgYCAAsGCwICAAYGBAIAAgAQAgAAAgYGAgYGAgAQAAAUFhQCAgILAwAFEwoCAAILBgYQAgACFAMDCxMLHyAAAAMGBgUGAgYGBhQQEBAGEAsCAgIAAwsCEBAQEBMQAAsGAwICCgAABgYQDQsLAAAFAAsAAAALBAMAAAAACwAUBhQGBgYGACELBAQKAx8gCwsACwsACwsCAAMDAwMCAAUABQQGBgAACwALBhAGAAYGAAYLAAsLCwIAAwAEAAsACwAGEAsGBgQFCwUDBQACAiIEIyQkBCUCFAYEAAYFBAMDAwQLCwAEBgsUFBQUFAMDCwQBAQ4mAQsLBAsGBwYLBgAGBgsLBhALCw4HBgYABAQAAAEADgEODg4OAQAQCwcAAAAACwsGBgYLJwsoKSopIwULCSsh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KAIsIAIoAiAoAhggAigCJBDJgICAACEEIAIoAiAgBDYCGCACQRxqENuAgIAACwJAIAIoAiwoAgBBBEZBAXFFDQAgAiACKAIsNgIYIAIgAigCGCgCIDYCFCACKAIsIAIoAhgoAiAgAigCJBDJgICAACEFIAIoAhggBTYCICACQRRqENuAgIAACwJAIAIoAiwoAgBBAkZBAXFFDQAgAiACKAIsNgIQIAIgAigCECgCJDYCDCACKAIsIAIoAhAoAiQgAigCJBDJgICAACEGIAIoAhAgBjYCJCACQQxqENuAgIAACwJAIAIoAiwoAgBBBUZBAXFFDQAgAiACKAIsNgIIIAIgAigCCCgCHDYCBCACKAIsIAIoAggoAhwgAigCJBDJgICAACEHIAIoAgggBzYCHCACQQRqENuAgIAACyACKAIsIQggAigCKCEJIAhBjICAgAAgCRDGgoCAAEEAQQFxIQogAkEwaiSAgICAACAKDwv2AgMCfwF+A38jgICAgABB4ANrIQIgAiSAgICAACACIAA2AtwDIAIgATYC2AMgAiACKALYAxDOgYCAADYC1AMgAkHAAGohA0IAIQQgAyAENwMAIAJBOGogBDcDACACQTBqIAQ3AwAgAkEoaiAENwMAIAJBIGogBDcDACACQRhqIAQ3AwAgAiAENwMQIAJBAToARCACKALUAyEFIAIoAtQDEOiLgIAAIQYgAkHIAGogBSAGIAJBEGoQpIaAgAAgAiACQcgAahC4hoCAADYCDCACIAIoAtQCNgIIAkADQCACKAIIQQBHQQFxRQ0BIAIgAigCCCACKALcAyACKALYAyACQcgAahC2goCAADYCBCACKALcAygCFCACKAIEENWAgIAAIAIgAigCCCgCADYCCAwACwsgAigCDCEHIAJByABqIAcQnYaAgAAgAkHIAGoQsoaAgAAgAkEQahCjhoCAACACKALUAxCWjICAACACQeADaiSAgICAAA8L6gMBFH8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABIAEoAgwQ0YCAgAA2AgggASgCCCgCjAMhAiABKAIIIQMgAkGBgICAACADEJ+GgIAAIAEoAggoAowDIQQgASgCCCEFIARBgoCAgAAgBRCfhoCAACABKAIIKAKMAyEGIAEoAgghByAGQYOAgIAAIAcQn4aAgAAgASgCCCgCjAMhCCABKAIIIQkgCEGEgICAACAJEJ+GgIAAIAEoAggoAowDIQogASgCCCELIApBhYCAgAAgCxCfhoCAACABKAIIKAKMAyEMIAEoAgghDSAMQYaAgIAAIA0Qn4aAgAAgASgCCCgCjAMhDiABKAIIIQ8gDkGHgICAACAPEJ+GgIAAIAEoAggoAowDIRAgASgCCCERIBBBiICAgAAgERCfhoCAACABKAIIKAKMAyESIAEoAgghEyASQYmAgIAAIBMQn4aAgAAgASgCCBC7gICAABogASgCCBC8gICAABogASgCCBC9gICAABogASgCCBC/gICAABogASgCCBDAgICAABogASgCCBDBgICAABogASgCCBDCgICAABogASgCCCgCjAMgASgCCBDDgICAABogASgCCBC+gICAABogASgCCCEUIAFBEGokgICAgAAgFA8L6wMBB38jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACNgIkIAMgAygCKBDagICAABDUgICAADYCICADQQA2AhwCQANAIAMoAhwgAygCKBDagICAAElBAXFFDQEgAyADKAIoIAMoAhwQ1oCAgAA2AhgCQCADKAIYQQBHQQFxDQAMAgsCQCADKAIYKAIAQQ5HQQFxRQ0AIAMoAiAgAygCGBDVgICAACADIAMoAhxBAWo2AhwMAQsgAyADKAIYNgIUIAMgAygCFBDKgICAADYCECADKAIQIQQCQAJAAkACQCAERQ0AIARBfGpBAkkNACAEQQhGDQAgBEF1akEFSQ0AIARBEUYNAQwCCyADIAMoAiwgAygCKCADKAIcIAMoAiAgAygCJCADKAIQEMuAgIAANgIcDAMLIAMoAhQhBUEIENSAgIAAIQYgAygCECEHQQAhCCADIAUgBiAIIAggBxDMgICAADYCDAJAAkAgAygCDEEAR0EBcUUNACADKAIgIAMoAgwQ1YCAgAAMAQsgAygCICADKAIYENWAgIAACyADIAMoAhxBAWo2AhwMAQsgAygCICADKAIYENWAgIAAIAMgAygCHEEBajYCHAsMAAsLIAMoAiAhCSADQTBqJICAgIAAIAkPC7YFAQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AggCQAJAAkAgASgCCEEAR0EBcUUNACABKAIIKAIAQQ5HQQFxRQ0BCyAB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IAM2AgACQAJAIAEoAgQoAgBBAEdBAXENACABKAIEEJaMgIAAIAFBADYCDAwBCyABIAEoAgQ2AgwLIAEoAgwhBCABQRBqJICAgIAAIAQPC6IDAQV/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYAkACQCACKAIcKAIEIAIoAhwoAghPQQFxRQ0AAkACQCACKAIcKAIIDQAgAkEBNgIUDAELAkACQCACKAIcKAIIQf////8BS0EBcUUNAEEAKALQ84iAAEHRuoaAAEEAEMOLgIAAGiACIAIoAhwoAghBgAJqNgIUAkAgAigCFCACKAIcKAIISUEBcUUNACACQf////8DNgIUCwwBCyACIAIoAhwoAghBAXQ2AhQLCwJAIAIoAhRB/////wNLQQFxRQ0AQQAoAtDziIAAQfa5hoAAQQAQw4uAgAAaDAILIAIgAigCFEECdDYCECACIAIoAhwoAgAgAigCEBCBgoCAADYCDAJAIAIoAgxBAEZBf3NBf3NBAXFFDQAMAgsgAigCDCEDIAIoAhwgAzYCACACKAIUIQQgAigCHCAENgIICyACKAIYIQUgAigCHCgCACACKAIcKAIEQQJ0aiAFNgIAIAIoAhwhBiAGIAYoAgRBAWo2AgQLIAJBIGokgICAgAAPC18BAX8jgICAgABBEGshAiACIAA2AgggAiABNgIEAkACQCACKAIEIAIoAggoAgRPQQFxRQ0AIAJBADYCDAwBCyACIAIoAggoAgAgAigCBEECdGooAgA2AgwLIAIoAgwPC2UBAX8jgICAgABBEGshASABIAA2AggCQAJAAkAgASgCCEEAR0EBcUUNACABKAIIKAIEDQELIAFBADYCDAwBCyABIAEoAggoAgAgASgCCCgCBEEBa0ECdGooAgA2AgwLIAEoAgwPC0EBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCACKAIIENWAgIAAIAJBEGokgICAgAAPC4sBAQN/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AggCQAJAAkAgASgCCEEAR0EBcUUNACABKAIIKAIEDQELIAFBADYCDAwBCyABIAEoAggQ14CAgAA2AgQgASgCCCECIAIgAigCBEF/ajYCBCABIAEoAgQ2AgwLIAEoAgwhAyABQRBqJICAgIAAIAMPC0YBAX8jgICAgABBEGshASABIAA2AggCQAJAIAEoAghBAEZBAXFFDQAgAUEANgIMDAELIAEgASgCCCgCBDYCDAsgASgCDA8LfAEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkACQAJAIAEoAgxBAEdBAXFFDQAgASgCDCgCAEEAR0EBcQ0BCwwBCyABKAIMKAIAKAIAEJaMgIAAIAEoAgwoAgAQloyAgAAgASgCDEEANgIACyABQRBqJICAgIAADwu5AQEEfyOAgICAAEEQayEFIAUkgICAgAAgBSAANgIMIAUgATYCCCAFIAQ2AgQCQAJAIAUoAgxBAEdBAXENAAwBCyAFKAIIIQYgBSgCDCAGNgIAIAUoAgxBBGogAikCADcCACAFKAIMQQRqQQhqIAMpAgA3AgACQCAFKAIEQQBGQQFxRQ0AQQgQ1ICAgAAhByAFKAIMIAc2AhQMAQsgBSgCBCEIIAUoAgwgCDYCFAsgBUEQaiSAgICAAA8LqQEBB38jgICAgABBIGshASABJICAgIAAIAEgADYCHCABQRwQlIyAgAA2AhggASgCGCECIAEoAhxBDGohAyABKAIcQQxqQQhqIQRBARogASADKQIANwMQIAEgBCkCADcDCEEAIQUgAkEBIAFBEGogAUEIaiAFENyAgIAAIAEoAhwoAgAQxIKAgAAhBiABKAIYIAY2AhggASgCGCEHIAFBIGokgICAgAAgBw8LkAEBBX8jgICAgABBIGshBCAEJICAgIAAIAQgADYCHCAEIAM2AhggBEEcEJSMgIAANgIUIAQoAhQhBSAEKAIYIQZBABogBCABKQIANwMIIAQgAikCADcDACAFQQAgBEEIaiAEIAYQ3ICAgAAgBCgCHCEHIAQoAhQgBzYCGCAEKAIUIQggBEEgaiSAgICAACAIDwuWAQEFfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgAzYCGCAEQRwQlIyAgAA2AhQgBCgCFCEFIAQoAhghBkEBGiAEIAEpAgA3AwggBCACKQIANwMAIAVBASAEQQhqIAQgBhDcgICAACAEKAIcEMSCgIAAIQcgBCgCFCAHNgIYIAQoAhQhCCAEQSBqJICAgIAAIAgPC4UCAQl/I4CAgIAAQTBrIQggCCSAgICAACAIIAA2AiwgCCABNgIoIAggAjYCJCAIIAM2AiAgCCAEOgAfIAggBzYCGCAIQSwQlIyAgAA2AhQgCCgCFCEJIAgoAhghCkECGiAIIAUpAgA3AwggCCAGKQIANwMAIAlBAiAIQQhqIAggChDcgICAACAIKAIsEL6CgIAAIQsgCCgCFCALNgIYIAgoAigQvoKAgAAhDCAIKAIUIAw2AhwgCCgCJBC+goCAACENIAgoAhQgDTYCICAIKAIgIQ4gCCgCFCAONgIkIAgtAB8hDyAIKAIUIA9BAXE6ACggCCgCFCEQIAhBMGokgICAgAAgEA8L7QEBCH8jgICAgABBMGshByAHJICAgIAAIAcgADYCLCAHIAE2AiggByACNgIkIAcgAzYCICAHIAY2AhwgB0EoEJSMgIAANgIYIAcoAhghCCAHKAIcIQlBAxogByAEKQIANwMQIAcgBSkCADcDCCAIQQMgB0EQaiAHQQhqIAkQ3ICAgAAgBygCLBC+goCAACEKIAcoAhggCjYCGCAHKAIoEL6CgIAAIQsgBygCGCALNgIcIAcoAiQhDCAHKAIYIAw2AiAgBygCIBC+goCAACENIAcoAhggDTYCJCAHKAIYIQ4gB0EwaiSAgICAACAODwuRAgEKfyOAgICAAEEwayEJIAkkgICAgAAgCSAANgIsIAkgATYCKCAJIAI2AiQgCSADNgIgIAkgBDoAHyAJIAU2AhggCSAINgIUIAlBMBCUjICAADYCECAJKAIQIQogCSgCFCELQQQaIAkgBikCADcDCCAJIAcpAgA3AwAgCkEEIAlBCGogCSALENyAgIAAIAkoAiwhDCAJKAIQIAw2AhggCSgCKBC+goCAACENIAkoAhAgDTYCHCAJKAIkIQ4gCSgCECAONgIgIAkoAiAhDyAJKAIQIA82AiQgCS0AHyEQIAkoAhAgEEEBcToAKCAJKAIYIREgCSgCECARNgIsIAkoAhAhEiAJQTBqJICAgIAAIBIPC+oBAQh/I4CAgIAAQTBrIQcgBySAgICAACAHIAA2AiwgByABNgIoIAcgAjYCJCAHIAM6ACMgByAGNgIcIAdBKBCUjICAADYCGCAHKAIYIQggBygCHCEJQQUaIAcgBCkCADcDECAHIAUpAgA3AwggCEEFIAdBEGogB0EIaiAJENyAgIAAIAcoAiwQvoKAgAAhCiAHKAIYIAo2AhggBygCKCELIAcoAhggCzYCHCAHKAIkEL6CgIAAIQwgBygCGCAMNgIgIActACMhDSAHKAIYIA1BAXE6ACQgBygCGCEOIAdBMGokgICAgAAgDg8LkAEBBX8jgICAgABBIGshBCAEJICAgIAAIAQgADYCHCAEIAM2AhggBEEcEJSMgIAANgIUIAQoAhQhBSAEKAIYIQZBBhogBCABKQIANwMIIAQgAikCADcDACAFQQYgBEEIaiAEIAYQ3ICAgAAgBCgCHCEHIAQoAhQgBzYCGCAEKAIUIQggBEEgaiSAgICAACAIDwvJAQEHfyOAgICAAEEwayEGIAYkgICAgAAgBiAANgIsIAYgATYCKCAGIAI2AiQgBiAFNgIgIAZBJBCUjICAADYCHCAGKAIcIQcgBigCICEIQQcaIAYgAykCADcDECAGIAQpAgA3AwggB0EHIAZBEGogBkEIaiAIENyAgIAAIAYoAiwhCSAGKAIcIAk2AhggBigCKBC+goCAACEKIAYoAhwgCjYCHCAGKAIkIQsgBigCHCALNgIgIAYoAhwhDCAGQTBqJICAgIAAIAwPC5YBAQV/I4CAgIAAQSBrIQQgBCSAgICAACAEIAA2AhwgBCADNgIYIARBHBCUjICAADYCFCAEKAIUIQUgBCgCGCEGQQgaIAQgASkCADcDCCAEIAIpAgA3AwAgBUEIIARBCGogBCAGENyAgIAAIAQoAhwQxIKAgAAhByAEKAIUIAc2AhggBCgCFCEIIARBIGokgICAgAAgCA8LzwEBB38jgICAgABBMGshBiAGJICAgIAAIAYgADYCLCAGIAE2AiggBiACNgIkIAYgBTYCICAGQSQQlIyAgAA2AhwgBigCHCEHIAYoAiAhCEEJGiAGIAMpAgA3AxAgBiAEKQIANwMIIAdBCSAGQRBqIAZBCGogCBDcgICAACAGKAIsEL6CgIAAIQkgBigCHCAJNgIYIAYoAighCiAGKAIcIAo2AhwgBigCJBC+goCAACELIAYoAhwgCzYCICAGKAIcIQwgBkEwaiSAgICAACAMDwvPAQEHfyOAgICAAEEwayEGIAYkgICAgAAgBiAANgIsIAYgATYCKCAGIAI2AiQgBiAFNgIgIAZBJBCUjICAADYCHCAGKAIcIQcgBigCICEIQQoaIAYgAykCADcDECAGIAQpAgA3AwggB0EKIAZBEGogBkEIaiAIENyAgIAAIAYoAiwQvoKAgAAhCSAGKAIcIAk2AhggBigCKCEKIAYoAhwgCjYCHCAGKAIkEL6CgIAAIQsgBigCHCALNgIgIAYoAhwhDCAGQTBqJICAgIAAIAwPC88BAQd/I4CAgIAAQTBrIQYgBiSAgICAACAGIAA2AiwgBiABNgIoIAYgAjYCJCAGIAU2AiAgBkEkEJSMgIAANgIcIAYoAhwhByAGKAIgIQhBCxogBiADKQIANwMQIAYgBCkCADcDCCAHQQsgBkEQaiAGQQhqIAgQ3ICAgAAgBigCLBC+goCAACEJIAYoAhwgCTYCGCAGKAIoIQogBigCHCAKNgIcIAYoAiQQvoKAgAAhCyAGKAIcIAs2AiAgBigCHCEMIAZBMGokgICAgAAgDA8LzwEBB38jgICAgABBMGshBiAGJICAgIAAIAYgADYCLCAGIAE2AiggBiACNgIkIAYgBTYCICAGQSQQlIyAgAA2AhwgBigCHCEHIAYoAiAhCEEMGiAGIAMpAgA3AxAgBiAEKQIANwMIIAdBDCAGQRBqIAZBCGogCBDcgICAACAGKAIsEL6CgIAAIQkgBigCHCAJNgIYIAYoAighCiAGKAIcIAo2AhwgBigCJBC+goCAACELIAYoAhwgCzYCICAGKAIcIQwgBkEwaiSAgICAACAMDwuWAQEFfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgAzYCGCAEQRwQlIyAgAA2AhQgBCgCFCEFIAQoAhghBkENGiAEIAEpAgA3AwggBCACKQIANwMAIAVBDSAEQQhqIAQgBhDcgICAACAEKAIcEL6CgIAAIQcgBCgCFCAHNgIYIAQoAhQhCCAEQSBqJICAgIAAIAgPC6ACAQp/I4CAgIAAQTBrIQkgCSSAgICAACAJIAA2AiwgCSABNgIoIAkgAjYCJCAJIAM2AiAgCSAEOgAfIAkgBToAHiAJIAg2AhggCUEsEJSMgIAANgIUIAkoAhQhCiAJKAIYIQtBDhogCSAGKQIANwMIIAkgBykCADcDACAKQQ4gCUEIaiAJIAsQ3ICAgAAgCSgCLBC+goCAACEMIAkoAhQgDDYCGCAJKAIoEL6CgIAAIQ0gCSgCFCANNgIcIAkoAiQQvoKAgAAhDiAJKAIUIA42AiAgCSgCICEPIAkoAhQgDzYCJCAJLQAfIRAgCSgCFCAQQQFxOgAoIAktAB4hESAJKAIUIBFBAXE6ACkgCSgCFCESIAlBMGokgICAgAAgEg8L1QEBB38jgICAgABBMGshBiAGJICAgIAAIAYgADYCLCAGIAE2AiggBiACNgIkIAYgBTYCICAGQSQQlIyAgAA2AhwgBigCHCEHIAYoAiAhCEEPGiAGIAMpAgA3AxAgBiAEKQIANwMIIAdBDyAGQRBqIAZBCGogCBDcgICAACAGKAIsEL6CgIAAIQkgBigCHCAJNgIYIAYoAigQvoKAgAAhCiAGKAIcIAo2AhwgBigCJBC+goCAACELIAYoAhwgCzYCICAGKAIcIQwgBkEwaiSAgICAACAMDwvtAQEIfyOAgICAAEEwayEHIAckgICAgAAgByAANgIsIAcgATYCKCAHIAI2AiQgByADNgIgIAcgBjYCHCAHQSgQlIyAgAA2AhggBygCGCEIIAcoAhwhCUEQGiAHIAQpAgA3AxAgByAFKQIANwMIIAhBECAHQRBqIAdBCGogCRDcgICAACAHKAIsEL6CgIAAIQogBygCGCAKNgIYIAcoAigQvoKAgAAhCyAHKAIYIAs2AhwgBygCJBC+goCAACEMIAcoAhggDDYCICAHKAIgIQ0gBygCGCANNgIkIAcoAhghDiAHQTBqJICAgIAAIA4PC5oCAQp/I4CAgIAAQTBrIQkgCSSAgICAACAJIAA2AiwgCSABNgIoIAkgAjYCJCAJIAM2AiAgCSAENgIcIAkgBTYCGCAJIAg2AhQgCUEwEJSMgIAANgIQIAkoAhAhCiAJKAIUIQtBERogCSAGKQIANwMIIAkgBykCADcDACAKQREgCUEIaiAJIAsQ3ICAgAAgCSgCLBC+goCAACEMIAkoAhAgDDYCGCAJKAIoEL6CgIAAIQ0gCSgCECANNgIcIAkoAiQQvoKAgAAhDiAJKAIQIA42AiAgCSgCICEPIAkoAhAgDzYCJCAJKAIcIRAgCSgCECAQNgIoIAkoAhghESAJKAIQIBE2AiwgCSgCECESIAlBMGokgICAgAAgEg8LggIBCX8jgICAgABBMGshCCAIJICAgIAAIAggADYCLCAIIAE2AiggCCACNgIkIAggAzYCICAIIAQ2AhwgCCAHNgIYIAhBLBCUjICAADYCFCAIKAIUIQkgCCgCGCEKQRIaIAggBSkCADcDCCAIIAYpAgA3AwAgCUESIAhBCGogCCAKENyAgIAAIAgoAiwQvoKAgAAhCyAIKAIUIAs2AhggCCgCKBC+goCAACEMIAgoAhQgDDYCHCAIKAIkEL6CgIAAIQ0gCCgCFCANNgIgIAgoAiAhDiAIKAIUIA42AiQgCCgCHCEPIAgoAhQgDzYCKCAIKAIUIRAgCEEwaiSAgICAACAQDwvtAQEIfyOAgICAAEEwayEHIAckgICAgAAgByAANgIsIAcgATYCKCAHIAI2AiQgByADNgIgIAcgBjYCHCAHQSgQlIyAgAA2AhggBygCGCEIIAcoAhwhCUETGiAHIAQpAgA3AxAgByAFKQIANwMIIAhBEyAHQRBqIAdBCGogCRDcgICAACAHKAIsEL6CgIAAIQogBygCGCAKNgIYIAcoAigQvoKAgAAhCyAHKAIYIAs2AhwgBygCJBC+goCAACEMIAcoAhggDDYCICAHKAIgIQ0gBygCGCANNgIkIAcoAhghDiAHQTBqJICAgIAAIA4PC7cCAQt/I4CAgIAAQcAAayEKIAokgICAgAAgCiAANgI8IAogATYCOCAKIAI2AjQgCiADNgIwIAogBDYCLCAKIAU2AiggCiAGNgIkIAogCTYCICAKQTQQlIyAgAA2AhwgCigCHCELIAooAiAhDEEUGiAKIAcpAgA3AxAgCiAIKQIANwMIIAtBFCAKQRBqIApBCGogDBDcgICAACAKKAI8EL6CgIAAIQ0gCigCHCANNgIYIAooAjgQvoKAgAAhDiAKKAIcIA42AhwgCigCNBC+goCAACEPIAooAhwgDzYCICAKKAIwIRAgCigCHCAQNgIkIAooAiwhESAKKAIcIBE2AiggCigCKCESIAooAhwgEjYCLCAKKAIkIRMgCigCHCATNgIwIAooAhwhFCAKQcAAaiSAgICAACAUDwu3AgELfyOAgICAAEHAAGshCiAKJICAgIAAIAogADYCPCAKIAE2AjggCiACNgI0IAogAzYCMCAKIAQ2AiwgCiAFNgIoIAogBjYCJCAKIAk2AiAgCkE0EJSMgIAANgIcIAooAhwhCyAKKAIgIQxBFRogCiAHKQIANwMQIAogCCkCADcDCCALQRUgCkEQaiAKQQhqIAwQ3ICAgAAgCigCPBC+goCAACENIAooAhwgDTYCGCAKKAI4EL6CgIAAIQ4gCigCHCAONgIcIAooAjQQvoKAgAAhDyAKKAIcIA82AiAgCigCMCEQIAooAhwgEDYCJCAKKAIsIREgCigCHCARNgIoIAooAighEiAKKAIcIBI2AiwgCigCJCETIAooAhwgEzYCMCAKKAIcIRQgCkHAAGokgICAgAAgFA8LggIBCX8jgICAgABBMGshCCAIJICAgIAAIAggADYCLCAIIAE2AiggCCACNgIkIAggAzYCICAIIAQ2AhwgCCAHNgIYIAhBLBCUjICAADYCFCAIKAIUIQkgCCgCGCEKQRYaIAggBSkCADcDCCAIIAYpAgA3AwAgCUEWIAhBCGogCCAKENyAgIAAIAgoAiwQvoKAgAAhCyAIKAIUIAs2AhggCCgCKBC+goCAACEMIAgoAhQgDDYCHCAIKAIkEL6CgIAAIQ0gCCgCFCANNgIgIAgoAiAhDiAIKAIUIA42AiQgCCgCHCEPIAgoAhQgDzYCKCAIKAIUIRAgCEEwaiSAgICAACAQDwuCAgEJfyOAgICAAEEwayEIIAgkgICAgAAgCCAANgIsIAggATYCKCAIIAI2AiQgCCADNgIgIAggBDYCHCAIIAc2AhggCEEsEJSMgIAANgIUIAgoAhQhCSAIKAIYIQpBFxogCCAFKQIANwMIIAggBikCADcDACAJQRcgCEEIaiAIIAoQ3ICAgAAgCCgCLBC+goCAACELIAgoAhQgCzYCGCAIKAIoEL6CgIAAIQwgCCgCFCAMNgIcIAgoAiQQvoKAgAAhDSAIKAIUIA02AiAgCCgCICEOIAgoAhQgDjYCJCAIKAIcIQ8gCCgCFCAPNgIoIAgoAhQhECAIQTBqJICAgIAAIBAPC4ICAQl/I4CAgIAAQTBrIQggCCSAgICAACAIIAA2AiwgCCABNgIoIAggAjYCJCAIIAM2AiAgCCAENgIcIAggBzYCGCAIQSwQlIyAgAA2AhQgCCgCFCEJIAgoAhghCkEYGiAIIAUpAgA3AwggCCAGKQIANwMAIAlBGCAIQQhqIAggChDcgICAACAIKAIsEL6CgIAAIQsgCCgCFCALNgIYIAgoAigQvoKAgAAhDCAIKAIUIAw2AhwgCCgCJBC+goCAACENIAgoAhQgDTYCICAIKAIgIQ4gCCgCFCAONgIkIAgoAhwhDyAIKAIUIA82AiggCCgCFCEQIAhBMGokgICAgAAgEA8LggIBCX8jgICAgABBMGshCCAIJICAgIAAIAggADYCLCAIIAE2AiggCCACNgIkIAggAzYCICAIIAQ2AhwgCCAHNgIYIAhBLBCUjICAADYCFCAIKAIUIQkgCCgCGCEKQRkaIAggBSkCADcDCCAIIAYpAgA3AwAgCUEZIAhBCGogCCAKENyAgIAAIAgoAiwQvoKAgAAhCyAIKAIUIAs2AhggCCgCKBC+goCAACEMIAgoAhQgDDYCHCAIKAIkEL6CgIAAIQ0gCCgCFCANNgIgIAgoAiAhDiAIKAIUIA42AiQgCCgCHCEPIAgoAhQgDzYCKCAIKAIUIRAgCEEwaiSAgICAACAQDwvtAQEIfyOAgICAAEEwayEHIAckgICAgAAgByAANgIsIAcgATYCKCAHIAI2AiQgByADNgIgIAcgBjYCHCAHQSgQlIyAgAA2AhggBygCGCEIIAcoAhwhCUEaGiAHIAQpAgA3AxAgByAFKQIANwMIIAhBGiAHQRBqIAdBCGogCRDcgICAACAHKAIsEL6CgIAAIQogBygCGCAKNgIYIAcoAigQvoKAgAAhCyAHKAIYIAs2AhwgBygCJBC+goCAACEMIAcoAhggDDYCICAHKAIgIQ0gBygCGCANNgIkIAcoAhghDiAHQTBqJICAgIAAIA4PC88CAQx/I4CAgIAAQcAAayELIAskgICAgAAgCyAANgI8IAsgATYCOCALIAI2AjQgCyADNgIwIAsgBDYCLCALIAU2AiggCyAGNgIkIAsgBzYCICALIAo2AhwgC0E4EJSMgIAANgIYIAsoAhghDCALKAIcIQ1BGxogCyAIKQIANwMQIAsgCSkCADcDCCAMQRsgC0EQaiALQQhqIA0Q3ICAgAAgCygCPBC+goCAACEOIAsoAhggDjYCGCALKAI4EL6CgIAAIQ8gCygCGCAPNgIcIAsoAjQQvoKAgAAhECALKAIYIBA2AiAgCygCMCERIAsoAhggETYCJCALKAIsIRIgCygCGCASNgIoIAsoAighEyALKAIYIBM2AiwgCygCJCEUIAsoAhggFDYCMCALKAIgIRUgCygCGCAVNgI0IAsoAhghFiALQcAAaiSAgICAACAWDwuaAgEKfyOAgICAAEEwayEJIAkkgICAgAAgCSAANgIsIAkgATYCKCAJIAI2AiQgCSADNgIgIAkgBDYCHCAJIAU2AhggCSAINgIUIAlBMBCUjICAADYCECAJKAIQIQogCSgCFCELQRwaIAkgBikCADcDCCAJIAcpAgA3AwAgCkEcIAlBCGogCSALENyAgIAAIAkoAiwQvoKAgAAhDCAJKAIQIAw2AhggCSgCKBC+goCAACENIAkoAhAgDTYCHCAJKAIkEL6CgIAAIQ4gCSgCECAONgIgIAkoAiAhDyAJKAIQIA82AiQgCSgCHCEQIAkoAhAgEDYCKCAJKAIYIREgCSgCECARNgIsIAkoAhAhEiAJQTBqJICAgIAAIBIPC9UBAQd/I4CAgIAAQTBrIQYgBiSAgICAACAGIAA2AiwgBiABNgIoIAYgAjYCJCAGIAU2AiAgBkEkEJSMgIAANgIcIAYoAhwhByAGKAIgIQhBHRogBiADKQIANwMQIAYgBCkCADcDCCAHQR0gBkEQaiAGQQhqIAgQ3ICAgAAgBigCLBC+goCAACEJIAYoAhwgCTYCGCAGKAIoEL6CgIAAIQogBigCHCAKNgIcIAYoAiQQvoKAgAAhCyAGKAIcIAs2AiAgBigCHCEMIAZBMGokgICAgAAgDA8L7QEBCH8jgICAgABBMGshByAHJICAgIAAIAcgADYCLCAHIAE2AiggByACNgIkIAcgAzYCICAHIAY2AhwgB0EoEJSMgIAANgIYIAcoAhghCCAHKAIcIQlBHhogByAEKQIANwMQIAcgBSkCADcDCCAIQR4gB0EQaiAHQQhqIAkQ3ICAgAAgBygCLBC+goCAACEKIAcoAhggCjYCGCAHKAIoEL6CgIAAIQsgBygCGCALNgIcIAcoAiQQvoKAgAAhDCAHKAIYIAw2AiAgBygCICENIAcoAhggDTYCJCAHKAIYIQ4gB0EwaiSAgICAACAODwvRBAECfyOAgICAAEEQayEBIAEgADYCCCABKAIIKAIAIQIgAkEeSxoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg4fAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8LIAFBhIOGgAA2AgwMHwsgAUH0h4aAADYCDAweCyABQbCIhoAANgIMDB0LIAFBx4iGgAA2AgwMHAsgAUGsg4aAADYCDAwbCyABQe+IhoAANgIMDBoLIAFBh4qGgAA2AgwMGQsgAUGhiYaAADYCDAwYCyABQdyChoAANgIMDBcLIAFBloOGgAA2AgwMFgsgAUHxiYaAADYCDAwVCyABQZOHhoAANgIMDBQLIAFB74qGgAA2AgwMEwsgAUG3ioaAADYCDAwSCyABQe+ChoAANgIMDBELIAFBy4qGgAA2AgwMEAsgAUG5iYaAADYCDAwPCyABQd+IhoAANgIMDA4LIAFBhYiGgAA2AgwMDQsgAUHPh4aAADYCDAwMCyABQcuJhoAANgIMDAsLIAFBmIiGgAA2AgwMCgsgAUGkioaAADYCDAwJCyABQeGHhoAANgIMDAgLIAFB1oOGgAA2AgwMBwsgAUGNiYaAADYCDAwGCyABQd2JhoAANgIMDAULIAFBvIeGgAA2AgwMBAsgAUHCg4aAADYCDAwDCyABQdyKhoAANgIMDAILIAFBrIeGgAA2AgwMAQsgAUHu6oWAADYCDAsgASgCDA8L1wEBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAAkAgASgCDEEARkEBcUUNAAwBCwJAIAEoAgwoAhRBAEdBAXFFDQAgAUEANgIIAkADQCABKAIIIAEoAgwoAhQQ2oCAgABJQQFxRQ0BIAEgASgCDCgCFCABKAIIENaAgIAANgIEAkAgASgCBEEAR0EBcUUNACABKAIEEMGBgIAACyABIAEoAghBAWo2AggMAAsLIAEoAgxBFGoQ24CAgAALIAEoAgwQloyAgAALIAFBEGokgICAgAAPC+EEAQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQAJAIAEoAgxBAEdBAXENAAwBCyABKAIMKAIAIQIgAkEeSxoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDh8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHwsgASgCDBCAgYCAAAweCyABKAIMEIGBgIAADB0LIAEoAgwQgoGAgAAMHAsgASgCDBCDgYCAAAwbCyABKAIMEISBgIAADBoLIAEoAgwQhYGAgAAMGQsgASgCDBCGgYCAAAwYCyABKAIMEIeBgIAADBcLIAEoAgwQiIGAgAAMFgsgASgCDBCJgYCAAAwVCyABKAIMEIqBgIAADBQLIAEoAgwQi4GAgAAMEwsgASgCDBCMgYCAAAwSCyABKAIMEI2BgIAADBELIAEoAgwQjoGAgAAMEAsgASgCDBCPgYCAAAwPCyABKAIMEJCBgIAADA4LIAEoAgwQkYGAgAAMDQsgASgCDBCSgYCAAAwMCyABKAIMEJOBgIAADAsLIAEoAgwQlIGAgAAMCgsgASgCDBCVgYCAAAwJCyABKAIMEJaBgIAADAgLIAEoAgwQl4GAgAAMBwsgASgCDBCYgYCAAAwGCyABKAIMEJmBgIAADAULIAEoAgwQmoGAgAAMBAsgASgCDBCbgYCAAAwDCyABKAIMEJyBgIAADAILIAEoAgwQnYGAgAAMAQsgASgCDBCegYCAAAsgAUEQaiSAgICAAA8LwQEBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAIAEoAgwoAhhBAEdBAXFFDQAgAUEANgIIAkADQCABKAIIIAEoAgwoAhgQ2oCAgABJQQFxRQ0BIAEgASgCDCgCGCABKAIIENaAgIAANgIEAkAgASgCBEEAR0EBcUUNACABKAIEEP+AgIAACyABIAEoAghBAWo2AggMAAsLIAEoAgxBGGoQ24CAgAALIAEoAgwQ/oCAgAAgAUEQaiSAgICAAA8LVwEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCGEEAR0EBcUUNACABKAIMKAIYEJaMgIAACyABKAIMEP6AgIAAIAFBEGokgICAgAAPC6cCAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQCABKAIMKAIYQQBHQQFxRQ0AIAEoAgwoAhgQv4KAgAALAkAgASgCDCgCHEEAR0EBcUUNACABKAIMKAIcEL+CgIAACwJAIAEoAgwoAiBBAEdBAXFFDQAgASgCDCgCIBC/goCAAAsCQCABKAIMKAIkQQBHQQFxRQ0AIAFBADYCCAJAA0AgASgCCCABKAIMKAIkENqAgIAASUEBcUUNASABIAEoAgwoAiQgASgCCBDWgICAADYCBAJAIAEoAgRBAEdBAXFFDQAgASgCBBD/gICAAAsgASABKAIIQQFqNgIIDAALCyABKAIMQSRqENuAgIAACyABKAIMEP6AgIAAIAFBEGokgICAgAAPC6cCAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQCABKAIMKAIYQQBHQQFxRQ0AIAEoAgwoAhgQv4KAgAALAkAgASgCDCgCHEEAR0EBcUUNACABKAIMKAIcEL+CgIAACwJAIAEoAgwoAiBBAEdBAXFFDQAgAUEANgIIAkADQCABKAIIIAEoAgwoAiAQ2oCAgABJQQFxRQ0BIAEgASgCDCgCICABKAIIENaAgIAANgIEAkAgASgCBEEAR0EBcUUNACABKAIEEP+AgIAACyABIAEoAghBAWo2AggMAAsLIAEoAgxBIGoQ24CAgAALAkAgASgCDCgCJEEAR0EBcUUNACABKAIMKAIkEL+CgIAACyABKAIMEP6AgIAAIAFBEGokgICAgAAPC/8BAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDCgCGBD/gICAAAJAIAEoAgwoAhxBAEdBAXFFDQAgASgCDCgCHBC/goCAAAsCQCABKAIMKAIgQQBHQQFxRQ0AIAFBADYCCAJAA0AgASgCCCABKAIMKAIgENqAgIAASUEBcUUNASABIAEoAgwoAiAgASgCCBDWgICAADYCBAJAIAEoAgRBAEdBAXFFDQAgASgCBBD/gICAAAsgASABKAIIQQFqNgIIDAALCyABKAIMQSBqENuAgIAACyABKAIMKAIkEP+AgIAAIAEoAgwQ/oCAgAAgAUEQaiSAgICAAA8LhQIBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAIAEoAgwoAhhBAEdBAXFFDQAgASgCDCgCGBC/goCAAAsCQCABKAIMKAIcQQBHQQFxRQ0AIAFBADYCCAJAA0AgASgCCCABKAIMKAIcENqAgIAASUEBcUUNASABIAEoAgwoAhwgASgCCBDWgICAADYCBAJAIAEoAgRBAEdBAXFFDQAgASgCBBD/gICAAAsgASABKAIIQQFqNgIIDAALCyABKAIMQRxqENuAgIAACwJAIAEoAgwoAiBBAEdBAXFFDQAgASgCDCgCIBC/goCAAAsgASgCDBD+gICAACABQRBqJICAgIAADwvBAQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCGEEAR0EBcUUNACABQQA2AggCQANAIAEoAgggASgCDCgCGBDagICAAElBAXFFDQEgASABKAIMKAIYIAEoAggQ1oCAgAA2AgQCQCABKAIEQQBHQQFxRQ0AIAEoAgQQ/4CAgAALIAEgASgCCEEBajYCCAwACwsgASgCDEEYahDbgICAAAsgASgCDBD+gICAACABQRBqJICAgIAADwtzAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDCgCGBD/gICAAAJAIAEoAgwoAhxBAEdBAXFFDQAgASgCDCgCHBC/goCAAAsgASgCDCgCIBD/gICAACABKAIMEP6AgIAAIAFBEGokgICAgAAPC1cBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAIAEoAgwoAhhBAEdBAXFFDQAgASgCDCgCGBCWjICAAAsgASgCDBD+gICAACABQRBqJICAgIAADwuFAgEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCGEEAR0EBcUUNACABKAIMKAIYEL+CgIAACwJAIAEoAgwoAhxBAEdBAXFFDQAgAUEANgIIAkADQCABKAIIIAEoAgwoAhwQ2oCAgABJQQFxRQ0BIAEgASgCDCgCHCABKAIIENaAgIAANgIEAkAgASgCBEEAR0EBcUUNACABKAIEEP+AgIAACyABIAEoAghBAWo2AggMAAsLIAEoAgxBHGoQ24CAgAALAkAgASgCDCgCIEEAR0EBcUUNACABKAIMKAIgEL+CgIAACyABKAIMEP6AgIAAIAFBEGokgICAgAAPC4UCAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQCABKAIMKAIYQQBHQQFxRQ0AIAEoAgwoAhgQv4KAgAALAkAgASgCDCgCHEEAR0EBcUUNACABQQA2AggCQANAIAEoAgggASgCDCgCHBDagICAAElBAXFFDQEgASABKAIMKAIcIAEoAggQ1oCAgAA2AgQCQCABKAIEQQBHQQFxRQ0AIAEoAgQQ/4CAgAALIAEgASgCCEEBajYCCAwACwsgASgCDEEcahDbgICAAAsCQCABKAIMKAIgQQBHQQFxRQ0AIAEoAgwoAiAQv4KAgAALIAEoAgwQ/oCAgAAgAUEQaiSAgICAAA8LhQIBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAIAEoAgwoAhhBAEdBAXFFDQAgASgCDCgCGBC/goCAAAsCQCABKAIMKAIcQQBHQQFxRQ0AIAFBADYCCAJAA0AgASgCCCABKAIMKAIcENqAgIAASUEBcUUNASABIAEoAgwoAhwgASgCCBDWgICAADYCBAJAIAEoAgRBAEdBAXFFDQAgASgCBBD/gICAAAsgASABKAIIQQFqNgIIDAALCyABKAIMQRxqENuAgIAACwJAIAEoAgwoAiBBAEdBAXFFDQAgASgCDCgCIBC/goCAAAsgASgCDBD+gICAACABQRBqJICAgIAADwuFAgEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCGEEAR0EBcUUNACABKAIMKAIYEL+CgIAACwJAIAEoAgwoAhxBAEdBAXFFDQAgAUEANgIIAkADQCABKAIIIAEoAgwoAhwQ2oCAgABJQQFxRQ0BIAEgASgCDCgCHCABKAIIENaAgIAANgIEAkAgASgCBEEAR0EBcUUNACABKAIEEP+AgIAACyABIAEoAghBAWo2AggMAAsLIAEoAgxBHGoQ24CAgAALAkAgASgCDCgCIEEAR0EBcUUNACABKAIMKAIgEL+CgIAACyABKAIMEP6AgIAAIAFBEGokgICAgAAPC1cBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAIAEoAgwoAhhBAEdBAXFFDQAgASgCDCgCGBC/goCAAAsgASgCDBD+gICAACABQRBqJICAgIAADwu9AQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCGEEAR0EBcUUNACABKAIMKAIYEL+CgIAACwJAIAEoAgwoAhxBAEdBAXFFDQAgASgCDCgCHBC/goCAAAsCQCABKAIMKAIgQQBHQQFxRQ0AIAEoAgwoAiAQv4KAgAALAkAgASgCDCgCJEEAR0EBcUUNACABKAIMKAIkENKAgIAACyABKAIMEP6AgIAAIAFBEGokgICAgAAPC5sBAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQCABKAIMKAIYQQBHQQFxRQ0AIAEoAgwoAhgQv4KAgAALAkAgASgCDCgCHEEAR0EBcUUNACABKAIMKAIcEL+CgIAACwJAIAEoAgwoAiBBAEdBAXFFDQAgASgCDCgCIBC/goCAAAsgASgCDBD+gICAACABQRBqJICAgIAADwunAgEBfyOAgICAAEEQayEBIAEkgICAgAAgASAA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KAKsASEFIAMoArABIQYgAygCtAEhByADQSBqIQggAygCvAEoAgwhCSADIAMoArwBKAIQNgIIIAMgCTYCBCADIAg2AgAgBSAGIAcgAxDgi4CAABogAygCrAEQxIKAgAAhCiADKAK4ASAKNgIUIAMoAqwBEJaMgIAADAELQbuihoAAEMSCgIAAIQsgAygCuAEgCzYCFAsgAygCvAEQvoKAgAAhDCADKAK4ASAMNgIYIAMoArgBIQ0gA0HAAWokgICAgAAgDQ8LbQEDfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgAzYCGCAEKAIYIQUgBCgCHCEGIAQgASkCADcDECAEIAIpAgA3AwggBSAGIARBEGogBEEIahCygYCAABDVgICAACAEQSBqJICAgIAADwuyAwEMfyOAgICAAEHQAmshAyADJICAgIAAIAMgADYCzAIgA0EcEJSMgIAANgLIAiADKALIAiEEQQMaIAMgASkCADcDGCADIAIpAgA3AxAgBEEDIANBGGogA0EQahCtgYCAACADQaOjhoAANgLEAiADQe0CNgLAAiADIAMoAsACEJSMgIAANgK8AgJAAkAgAygCvAJBAEdBAXFFDQAgA0GwAWogAygCzAIoAgBBgAEQ64uAgAAaIANBADoAsAIgA0EgaiADKALMAigCAEGAARDri4CAABogA0EAOgCgASADKAK8AiEFIAMoAsACIQYgAygCxAIhByADQbABaiEIIAMoAswCKAIMIQkgAygCzAIoAhAhCiADIANBIGo2AgwgAyAKNgIIIAMgCTYCBCADIAg2AgAgBSAGIAcgAxDgi4CAABogAygCvAIQxIKAgAAhCyADKALIAiALNgIUIAMoArwCEJaMgIAADAELQaOjhoAAEMSCgIAAIQwgAygCyAIgDDYCFAsgAygCzAIQvoKAgAAhDSADKALIAiANNgIYIAMoAsgCIQ4gA0HQAmokgICAgAAgDg8LbQEDfyOAgICAAEEgayEEIAQkgICAgAAgBCAANgIcIAQgAzYCGCAEKAIYIQUgBCgCHCEGIAQgASkCADcDECAEIAIpAgA3AwggBSAGIARBEGogBEEIahC0gYCAABDVgICAACAEQSBqJICAgIAADwuBBAEQfyOAgICAAEHgAmshBCAEJICAgIAAIAQgADYC3AIgBCABNgLYAiAEQSAQ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AAwBCyACKAI4IQUgAiACKAIoQQRqKQIANwMYIAUgAkEYahC3goCAABCpgYCAAAsMAgsgAkEAOgAzIAIoAjghBiACIAIoAihBBGopAgA3AyAgBiACQSBqELeCgIAAEKmBgIAADAELIAIoAjghByACIAIoAihBBGopAgA3AwggByACQQhqELeCgIAAEKmBgIAACyACIAIoAixBAWo2AiwMAAsLIAJBNGoQ0YGAgAAgAkHAAGokgICAgAAPC+YBAQJ/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYIAIgAigCHBDPgYCAADYCFCACQQA2AhACQANAIAIoAhAgAigCFBDagICAAElBAXFFDQEgAiACKAIUIAIoAhAQ1oCAgAA2AgwCQAJAIAIoAgwoAhxBcWpBAksNACACKAIYIQMgAiACKAIMQQRqKQIANwMAIAMgAhC3goCAABCpgYCAAAwBCyACKAIYIAIoAgwoAgAQpoGAgAALIAIgAigCEEEBajYCEAwACwsgAkEUahDRgYCAACACQSBqJICAgIAADwtJAQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgARCfgYCAABogASgCDCABEMuBgIAAIAEoAgAhAiABQRBqJICAgIAAIAIPC60BAQN/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASABKAIMEOeBgIAANgIIIAFBADYCBCABQYABENSAgIAANgIAAkADQCABKAIIEOqBgIAAIQIgASACNgIEIAIoAhxBIkdBAXFFDQEgASgCACABKAIEENWAgIAADAALCyABKAIAIAEoAgQQ1YCAgAAgASgCCBD7gYCAACABKAIAIQMgAUEQaiSAgICAACADDwt6AQJ/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYIAIgAigCHBDngYCAADYCFCACIAIoAhQgAigCGBCXgoCAADYCECACIAIoAhAQmIKAgAA2AgwgAigCEBCdgoCAACACKAIMIQMgAkEgaiSAgICAACADDwvIAQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkACQAJAIAEoAgxBAEdBAXFFDQAgASgCDCgCAEEAR0EBcQ0BCwwBCyABQQA2AggCQANAIAEoAgggASgCDCgCABDagICAAElBAXFFDQEgASABKAIMKAIAIAEoAggQ1oCAgAA2AgQCQCABKAIEQQBHQQFxRQ0AIAEoAgQQv4KAgAALIAEgASgCCEEBajYCCAwACwsgASgCDBDbgICAAAsgAUEQaiSAgICAAA8LCQBB95mGgAAPCwkAQfOdhoAADwvPAgMCfwV+A38jgICAgABB0ABrIQEgASSAgICAACABIAA2AkgCQAJAIAEoAkhBAEZBAXFFDQAgAUEAQQFxOgBPDAELQQAhAiACKQOwvIaAACEDIAFBwABqIAM3AwAgAikDqLyGgAAhBCABQThqIAQ3AwAgAikDoLyGgAAhBSABQTBqIAU3AwAgAikDmLyGgAAhBiABQShqIAY3AwAgAikDkLyGgAAhByABQSBqIAc3AwAgASACKQOIvIaAADcDGCABIAIpA4C8hoAANwMQIAFBADYCDAJAA0AgASgCDEEOSUEBcUUNASABKAJIIQggASgCDCEJAkAgCCABQRBqIAlBAnRqKAIAEOOLgIAADQAgAUEBQQFxOgBPDAMLIAEgASgCDEEBajYCDAwACwsgAUEAQQFxOgBPCyABLQBPQQFxIQogAUHQAGokgICAgAAgCg8LhQIBBX8jgICAgABBEGshASABJICAgIAAIAEgADYCCAJAAkAgASgCCEEARkEBcUUNACABQb6VhoAAEMSCgIAANgIMDAELIAEgASgCCBDoi4CAADYCBCABIAEoAgRBBGoQlIyAgAA2AgACQCABKAIAQQBGQQFxRQ0AIAFBADYCDAwBCyABKAIAQTw6AAAgASgCAEEvOgABIAEoAgBBAmohAiABKAIIIQMgASgCBCEEAkAgBEUNACACIAMgBPwKAAALIAEoAgAgASgCBEECampBPjoAACABKAIAIAEoAgRBA2pqQQA6AAAgASABKAIANgIMCyABKAIMIQUgAUEQaiSAgICAACAFDwuhAgEFfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIAkACQCABKAIIQQBGQQFxRQ0AIAFBwpWGgAAQxIKAgAA2AgwMAQsgASABKAIIEOiLgIAANgIEIAEgASgCBEEFahCUjICAADYCAAJAIAEoAgBBAEZBAXFFDQAgAUEANgIMDAELIAEoAgBBPDoAACABKAIAQQFqIQIgASgCCCEDIAEoAgQhBAJAIARFDQAgAiADIAT8CgAACyABKAIA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AkEBcSEEIAMhBQJAIAQNACABKAIMQQlrQQVJIQULIAVBAXEPC8ACARV/I4CAgIAAQSBrIQEgASSAgICAACABIAA2AhwgAUEQahCggYCAAANAIAEoAhwtACAhAkEYIQMgAiADdCADdRDxgYCAACEEQQAhBQJAIARFDQAgASgCHC0AICEGQRghByAGIAd0IAd1QQpHIQhBACEJIAhBAXEhCiAJIQUgCkUNACABKAIcLQAgIQtBGCEMIAsgDHQgDHVBDUchDUEAIQ4gDUEBcSEPIA4hBSAPRQ0AIAEoAhwQ64GAgABBf3MhBQsCQCAFQQFxRQ0AIAEoAhwtACAhECABQRBqIRFBGCESIBEgECASdCASdRCngYCAACABKAIcEPiBgIAADAELCyABKAIQIRMgASgCHCEUIAEgE0EAIBQQvIKAgAA2AgwgAUEQahCrgYCAACABKAIMIRUgAUEgaiSAgICAACAVDwusAwEDfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIYIAIgATYCFCACIAIoAhgoAgAgAigCGCgCECACKAIYKAIEEMKCgIAANgIQAkACQCACKAIQQQFMQQFxRQ0AIAIgAigCGCACKAIUEPCBgIAANgIcDAELIAIgAigCEEEBahCUjICAADYCDAJAIAIoAgxBAEdBAXENACACIAIoAhggAigCFBDwgYCAADYCHAwBCyACQQA2AggCQANAIAIoAgggAigCEEhBAXFFDQECQCACKAIYKAIQIAIoAghqIAIoAhgoAgRPQQFxRQ0AIAIoAgwQloyAgAAgAiACKAIYIAIoAhQQ8IGAgAA2AhwMAwsgAigCGCgCACACKAIYKAIQIAIoAghqai0AACEDIAIoAgwgAigCCGogAzoAACACIAIoAghBAWo2AggMAAsLIAIoAgwgAigCEGpBADoAACACKAIYIAIoAhAQ+YGAgAAgAiACKAIMIAIoAhQgAigCGBC8goCAADYCBCACKAIMEJaMgIAAIAIgAigCBDYCHAsgAigCHCEEIAJBIGokgICAgAAgBA8LmAIDA38BfgN/I4CAgIAAQcAAayEBIAEkgICAgAAgASAANgI4QQAhAiACKALYvIaAACEDIAFBKGogAzYCACACKQPQvIaAACEEIAFBIGogBDcDACABIAIpA8i8hoAANwMYIAEgAikDwLyGgAA3AxAgASgCOEEBNgIkIAFBADYCDAJAAkADQCABKAIMQQdJQQFxRQ0BIAEoAjghBSABKAIMIQYgASAFIAFBEGogBkECdGooAgBBDxD2gYCAADYCCAJAIAEoAghBAEdBAXFFDQAgASABKAIINgI8DAMLIAEgASgCDEEBajYCDAwACwsgASABKAI4QZ2PhIAAEOmBgIAANgI8CyABKAI8IQcgAUHAAGokgICAgAAgBw8LZwECfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAygCDCADKAIIEOiLgIAAEPqBgIAAIAMoAgggAygCBCADKAIMELyCgIAAIQQgA0EQaiSAgICAACAEDwuTAQECfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIIIAMgATYCBCADIAI2AgACQAJAIAMoAggoAgAgAygCCCgCEGogAygCBCADKAIEEOiLgIAAEOmLgIAADQAgAyADKAIIIAMoAgQgAygCABD1gYCAADYCDAwBCyADQQA2AgwLIAMoAgwhBCADQRBqJICAgIAAIAQPC+oCARZ/I4CAgIAAQSBrIQEgASSAgICAACABIAA2AhwgAUEQahCggYCAAANAIAEoAhwtACAhAkEYIQMCQAJAIAIgA3QgA3UQy4uAgAANACABKAIcLQAgIQRBGCEFIAQgBXQgBXVBLUZBAXENACABKAIcLQAgIQZBGCEHIAYgB3QgB3VB3wBGQQFxDQAgASgCHC0AICEIQRghCSAIIAl0IAl1QTpGIQpBACELIApBAXEhDCALIQ0gDEUNAQsgASgCHEEAEN2BgIAAIQ5BACEPIA5BAXEhECAPIQ0gEA0AIAEoAhwQ64GAgABBf3MhDQsCQCANQQFxRQ0AIAEoAhwtACAhESABQRBqIRJBGCETIBIgESATdCATdRCngYCAACABKAIcEPiBgIAADAELCyABKAIQIRQgASgCHCEVIAEgFEEDIBUQvIKAgAA2AgwgAUEQahCrgYCAACABKAIMIRYgAUEgaiSAgICAACAWDwu3AQEGfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDBD8gYCAAEEBcUUNACABKAIMEOuBgIAAQQFxDQAgASgCDC0AICECQRghAwJAIAIgA3QgA3UQw4KAgAANACABKAIMIQQgBCAEKAIMQQFqNgIMCyABKAIMIQUgBSAFKAIQQQFqNgIQIAEoAgwoAgAgASgCDCgCEGotAAAhBiABKAIMIAY6ACALIAFBEGokgICAgAAPC5UCAQh/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIAkACQCACKAIIQQBMQQFxRQ0ADAELIAIoAgwQ/IGAgABBAXFFDQAgAigCDBDrgYCAAEEBcQ0AIAIoAgwtACAhA0EYIQQCQCADIAR0IAR1EMOCgIAADQAgAigCDCEFIAUgBSgCDEEBajYCDAsgAigCCCEGIAIoAgwhByAHIAYgBygCEGo2AhACQAJAIAIoAgwoAhAgAigCDCgCBE9BAXFFDQAgAigCDCgCBCEIIAIoAgwgCDYCECACKAIMQQA6ACAMAQsgAigCDCgCACACKAIMKAIQai0AACEJIAIoAgwgCToAIAsLIAJBEGokgICAgAAPC2kBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAkEANgIEAkADQCACKAIEIAIoAghJQQFxRQ0BIAIoAgwQ+IGAgAAgAiACKAIEQQFqNgIEDAALCyACQRBqJICAgIAADwtLAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQAJAIAEoAgxBAEZBAXFFDQAMAQsgASgCDBCWjICAAAsgAUEQaiSAgICAAA8LKwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMKAIQIAEoAgwoAgRJQQFxDwuAAQEDfyOAgICAAEEwayEFIAUgADYCLCAFIAE2AiggBSACNgIkIAUgAzYCICAFIAQ2AhwgBSgCLCEGIAUgBSgCKDYCFCAFIAUoAiQ2AhggBiAFKQIUNwIAIAUoAixBCGohByAFIAUoAiA2AgwgBSAFKAIcNgIQIAcgBSkCDDcCAA8LPgECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgxBAUEBcRD/gYCAACECIAFBEGokgICAgAAgAg8L0AEBA38jgICAgABBIGshAiACJICAgIAAIAIgADYCGCACIAE6ABcCQAJAIAIoAhgNACACQQA2AhwMAQsgAiACKAIYEJSMgIAANgIQAkAgAigCEEEAR0EBcQ0AQQAoAtDziIAAIQMgAiACKAIYNgIAIANBq7qGgAAgAhDDi4CAABpBACgC0POIgAAQvouAgAAaAkAgAi0AF0EBcUUNAEEBEICAgIAAAAsgAkEANgIcDAELIAIgAigCEDYCHAsgAigCHCEEIAJBIGokgICAgAAgBA8LPgECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgxBAEEBcRD/gYCAACECIAFBEGokgICAgAAgAg8LSgECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIAIoAghBAUEBcRCCgoCAACEDIAJBEGokgICAgAAgAw8LhgIBA38jgICAgABBIGshAyADJICAgIAAIAMgADYCGCADIAE2AhQgAyACOgATAkACQCADKAIUDQAgA0EANgIcDAELAkAgAygCGEEAR0EBcQ0AIAMgAygCFCADLQATQQFxEP+BgIAANgIcDAELIAMgAygCGCADKAIUEJeMgIAANgIMAkAgAygCDEEAR0EBcQ0AQQAoAtDziIAAIQQgAyADKAIUNgIAIARBlbuGgAAgAxDDi4CAABpBACgC0POIgAAQvouAgAAaAkAgAy0AE0EBcUUNAEEBEICAgIAAAAsgA0EANgIcDAELIAMgAygCDDYCHAsgAygCHCEFIANBIGokgICAgAAgBQ8LSgECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIAIoAghBAEEBcRCCgoCAACEDIAJBEGokgICAgAAgAw8LVAEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACIAIoAggQvoKAgAA2AgQgAigCDCgCCCACKAIEENiAgIAAIAJBEGokgICAgAAPC8ABAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABNgIEAkACQCACKAIIKAIIENqAgIAADQAgAkEAQQFxOgAPDAELIAIgAigCCCgCCBDXgICAADYCAAJAAkAgAigCAEEARkEBcQ0AIAIoAgAoAgBBAEZBAXFFDQELIAJBAEEBcToADwwBCyACIAIoAgAoAgAgAigCBBDji4CAAEEARkEBcToADwsgAi0AD0EBcSEDIAJBEGokgICAgAAgAw8LZQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIAkACQCABKAIIKAIIENqAgIAADQAgAUEANgIMDAELIAEg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akEIaiEGIAMoAiQhByADIAUpAgA3AwggAyAGKQIANwMAIAQgA0EIaiADIAcQtYGAgAAgAygCLCEIIAMoAiwoAhwhCSADKAIoIQogAygCLEEEaiELIAMoAixBBGpBCGohDCADKAIkIQ1BABpBABogAyALKQIANwMYIAMgDCkCADcDEEEAIQ4gCCAJIAogDiAOIA4gA0EYaiADQRBqIA0Q4oCAgAAhDyADQTBqJICAgIAAIA8PC6UCAQp/I4CAgIAAQcAAayEDIAMkgICAgAAgAyAANgI8IAMgATYCOCADIAI2AjQCQAJAIAMoAjwoAggQ2oCAgABBAEtBAXFFDQAgAyADKAI8KAIIENeAgIAANgIwIAMgAygCOCgCHDYCLCADKAIwIQQgAygCLCEFIAMoAixBDGohBiADKAIsQQxqQQhqIQcgAygCNCEIIAMgBikCADcDECADIAcpAgA3AwggBCAFIANBEGogA0EIaiAIELeBgIAADAELIAMoAjgoAhwhCSADKAI4KAIcQQxqIQogAygCOCgCHEEMakEIaiELIAMoAjQhDCADIAopAgA3AyAgAyALKQIANwMYIAkgA0EgaiADQRhqIAwQs4GAgAALIANBwABqJICAgIAADwuYAQECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgATYCBCACIAIoAgQQioKAgAA2AgACQAJAAkAgAigCAEEARkEBcQ0AIAIoAghBAEZBAXFFDQELIAJBAEEBcToADwwBCyACIAIoAgggAigCABDmi4CAAEEARkEBcToADwsgAi0AD0EBcSEDIAJBEGokgICAgAAgAw8LBQBBGA8L9QEBCX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggQloKAgAAhAyACQQEgAxCdjICAADYCBCACKAIMIQQgAigCBCAENgIAIAIoAgwQ6oGAgAAhBSACKAIEIAU2AgRBEBDUgICAACEGIAIoAgQgBjYCCCACKAIEQQA2AgwgAigCBEEANgIQAkACQCACKAIIQQBHQQFxRQ0AQQEhByAHIAcQnYyAgAAhCCACKAIEIAg2AhQgAigCCC0AACEJIAIoAgQoAhQgCUEBcToAAAwBCyACKAIEQQA2AhQLIAIoAgQhCiACQRBqJICAgIAAIAoPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEJmCgIAAIQIgAUEQaiSAgICAACACDwuJAgEHfyOAgICAAEEwayEBIAEkgICAgAAgASAANgIsIAFBCBDUgICAADYCKCABQQgQ1ICAgAA2AiQgASABKAIsKAIEQQxqKQIANwMYIAEoAiwgASgCKCABKAIkEJqCgIAAIAEoAiwgASgCJBCbgoCAACABKAIsIAEoAiggASgCJBCcgoCAACABKAIsIQIgASgCJCEDIAEgAkEiIAMQkoKAgAA2AhQgASgCKCEEIAEoAhRBDGpBCGohBSABKAIkIQYgASABKQIYNwMIIAEgBSkCADcDACABIAQgAUEIaiABIAYQ3oCAgAA2AhAgASgCFBC/goCAACABKAIQIQcgAUEwaiSAgICAACAHDwuiBQEJfyOAgICAAEHwAGshAyADJICAgIAAIAMgADYCbCADIAE2AmggAyACNgJkAkADQCADKAJsKAIEKAIcIQQgA0H/wdcvNgJUIANBIjYCUCAEQQogA0HQAGoQuoKAgABBf3NBAXFFDQECQCADKAJsQQ8QuIKAgABBAXFFDQAgAygCaCADKAJsEJ6CgIAAENWAgIAADAELAkAgAygCbEEEELiCgIAAQQFxRQ0AIAMoAmggAygCbBCfgoCAABDVgICAAAwBCwJAIAMoAmxBBRC4goCAAEEBcUUNACADKAJoIAMoAmwQoIKAgAAQ1YCAgAAMAQsCQCADKAJsQQcQuIKAgABBAXFFDQAgAygCaCADKAJsEKGCgIAAENWAgIAADAELAkAgAygCbEENELiCgIAAQQFxRQ0AIAMoAmggAygCbBCigoCAABDVgICAAAwBCwJAIAMoAmxBCRC4goCAAEEBcUUNACADKAJoIAMoAmwQo4KAgAAQ1YCAgAAMAQsgAygCbCgCBCgCHCEFIANBwABqQf/B1y82AgAgA0E8akEANgIAIANBOGpBGTYCACADQTRqQRM2AgAgA0EwakEbNgIAIANBLGpBFTYCACADQShqQR42AgAgA0EkakECNgIAQSAhBiADIAZqQQE2AgBBHCEHIAMgB2pBAzYCAEEYIQggAyAIakEaNgIAQRQhCSADIAlqIAk2AgAgA0EQaiAINgIAIAMgBzYCDCADIAY2AgggA0EWNgIEIANBHTYCAAJAIAVBHyADELqCgIAAQQFxRQ0AIAMoAmggAygCbCADKAJkEKSCgIAAENWAgIAADAELIAMoAmwhCiADKAJkIQsgCkHB7oSAAEGygIaAACALEI2CgIAADAALCyADQfAAaiSAgICAAA8LuwEBBX8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhgCQANAIAIoAhwoAggQ2oCAgABBAEtBAXFFDQEgAiACKAIcEIaCgIAANgIUIAIoAhQhAyACKAIcKAIEQQxqIQQgAigCHCgCBEEMakEIaiEFIAIoAhghBiACIAQpAgA3AwggAiAFKQIANwMAIAMgAkEIaiACIAYQvYGAgAAgAigCFBC/goCAAAwACwsgAkEgaiSAgICAAA8LwQIBB38jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACNgIkAkADQCADKAIsQSIQuYKAgABBAXFFDQECQCADKAIsQQoQuYKAgABBAXFFDQAgAygCLCEEIAMoAiQhBSAEQQogBRCPgoCAACADIAMoAiwQjoKAgAA2AiAgAygCIBC/goCAAAwBCyADIAMoAiwQpYKAgAA2AhwCQCADKAIcKAIcKAIAENSBgIAAQQFxDQAgAygCHCgCHCEGIAMoAhxBBGohByADKAIcQQRqQQhqIQggAygCHCgCFCEJIAMgBykCADcDECADIAgpAgA3AwggBiADQRBqIANBCGogCRCzgYCAAAsgAygCKCADKAIcENWAgIAAIAMoAiwgAygCKCADKAIkEJqCgIAADAALCyADQTBqJICAgIAADwvTAQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkACQCABKAIMQQBGQQFxRQ0ADAELAkAgASgCDCgCAEEAR0EBcUUNACABKAIMKAIAEPuBgIAACwJAIAEoAgwoAgRBAEdBAXFFDQAgASgCDCgCBBC/goCAAAsCQCABKAIMKAIIQQBHQQFxRQ0AIAEoAgxBCGoQ24CAgAALAkAgASgCDCgCFEEAR0EBcUUNACABKAIMKAIUEJaMgIAACyABKAIMEJaMgIAACyABQRBqJICAgIAADwuyAgEPfyOAgICAAEEwayEBIAEkgICAgAAgASAANgIsIAFBCBDUgICAADYCKCABKAIsIQIgASgCKCEDIAEgAkEPIAMQkoKAgAA2AiQgASgCLCEEIAEoAighBSABIARBECAFEJKCgIAANgIgIAEoAiwhBiABKAIoIQcgASAGQREgBxCSgoCAADYCHCABKAIkIQggASgCICEJIAEoAhwhCiABKAIkQQxqIQsgASgCHEEMakEIaiEMIAEoAighDUEAGkEAGiABIAspAgA3AxAgASAMKQIANwMIQQAhDiABIAggCSAKIA4gDiAOIAFBEGogAUEIaiANEOyAgIAANgIYIAEoAiQQv4KAgAAgASgCIBC/goCAACABKAIcEL+CgIAAIAEoAhghDyABQTBqJICAgIAAIA8PC9AEARJ/I4CAgIAAQeAAayEBIAEkgICAgAAgASAANgJcIAFBCBDUgICAADYCWCABQQgQ1ICAgAA2AlQgAUHIAGoQoIGAgAAgASgCXCECIAEoAlghAyABIAJBBCADEJKCgIAANgJEIAEgASgCXCgCBEEMaikCADcDOAJAA0AgASgCXCgCBCgCHCEEIAFB/8HXLzYCJCABQSI2AiAgBEELIAFBIGoQuoKAgABBf3NBAXFFDQECQCABKAJcQQ8QuIKAgABBAXFFDQAgASgCXCEFIAEoAlQhBiABQcgAahogASABKQM4NwMAIAUgAUHIAGogBiABEJCCgIAAIAEgASgCXBCegoCAADYCNCABKAJUIAEoAjQQ1YCAgAAMAQsgASABKAJcIAEoAlwoAgQoAhwgASgCWBCSgoCAADYCMCABKAIwKAIAIQcgAUHIAGogBxCmgYCAACABKAIwEL+CgIAADAALCyABKAJcIQggASgCVCEJIAFByABqGiABIAEpAzg3AwggCCABQcgAaiAJIAFBCGoQkIKAgAAgASgCXCEKIAEoAlghCyABIApBCyALEJKCgIAANgIsIAEoAkQhDCABKAJUIQ0gASgCLCEOIAEoAkRBDGohDyABKAIsQQxqQQhqIRAgASgCWCERIAEgDykCADcDGCABIBApAgA3AxAgASAMIA0gDiABQRhqIAFBEGogERDogICAADYCKCABKAJEEL+CgIAAIAEoAiwQv4KAgAAgAUHIAGoQq4GAgAAgASgCKCESIAFB4ABqJICAgIAAIBIPC9MEARJ/I4CAgIAAQeAAayEBIAEkgICAgAAgASAANgJcIAFBCBDUgICAADYCWCABQQgQ1ICAgAA2AlQgAUHIAGoQoIGAgAAgASgCXCECIAEoAlghAyABIAJBBSADEJKCgIAANgJEIAEgASgCXCgCBEEMaikCADcDOAJAA0AgASgCXCgCBCgCHCEEIAFB/8HXLzYCJCABQSI2AiAgBEEGIAFBIGoQuoKAgABBf3NBAXFFDQECQCABKAJcQQ8QuIKAgABBAXFFDQAgASgCXCEFIAEoAlQhBiABQcgAahogASABKQM4NwMAIAUgAUHIAGogBiABEJCCgIAAIAEgASgCXBCegoCAADYCNCABKAJUIAEoAjQQ1YCAgAAgASABKAJcKAIEQQxqKQIANwM4DAELIAEgASgCXBCOgoCAADYCMCABKAIwKAIAIQcgAUHIAGogBxCmgYCAACABKAIwEL+CgIAADAALCyABKAJcIQggASgCVCEJIAFByABqGiABIAEpAzg3AwggCCABQcgAaiAJIAFBCGoQkIKAgAAgASgCXCEKIAEoAlghCyABIApBBiALEJKCgIAANgIsIAEoAkQhDCABKAJUIQ0gASgCLCEOIAEoAkRBDGohDyABKAIsQQxqQQhqIRAgASgCWCERIAEgDykCADcDGCABIBApAgA3AxAgASAMIA0gDiABQRhqIAFBEGogERDpgICAADYCKCABKAJEEL+CgIAAIAEoAiwQv4KAgAAgAUHIAGoQq4GAgAAgASgCKCESIAFB4ABqJICAgIAAIBIPC9MEARJ/I4CAgIAAQeAAayEBIAEkgICAgAAgASAANgJcIAFBCBDUgICAADYCWCABQQgQ1ICAgAA2AlQgAUHIAGoQoIGAgAAgASgCXCECIAEoAlghAyABIAJBByADEJKCgIAANgJEIAEgASgCXCgCBEEMaikCADcDOAJAA0AgASgCXCgCBCgCHCEEIAFB/8HXLzYCJCABQSI2AiAgBEEIIAFBIGoQuoKAgABBf3NBAXFFDQECQCABKAJcQQ8QuIKAgABBAXFFDQAgASgCXCEFIAEoAlQhBiABQcgAahogASABKQM4NwMAIAUgAUHIAGogBiABEJCCgIAAIAEgASgCXBCegoCAADYCNCABKAJUIAEoAjQQ1YCAgAAgASABKAJcKAIEQQxqKQIANwM4DAELIAEgASgCXBCOgoCAADYCMCABKAIwKAIAIQcgAUHIAGogBxCmgYCAACABKAIwEL+CgIAADAALCyABKAJcIQggASgCVCEJIAFByABqGiABIAEpAzg3AwggCCABQcgAaiAJIAFBCGoQkIKAgAAgASgCXCEKIAEoAlghCyABIApBCCALEJKCgIAANgIsIAEoAkQhDCABKAJUIQ0gASgCLCEOIAEoAkRBDGohDyABKAIsQQxqQQhqIRAgASgCWCERIAEgDykCADcDGCABIBApAgA3AxAgASAMIA0gDiABQRhqIAFBEGogERDqgICAADYCKCABQcgAahCrgYCAACABKAJEEL+CgIAAIAEoAiwQv4KAgAAgASgCKCESIAFB4ABqJICAgIAAIBIPC8wEARJ/I4CAgIAAQeAAayEBIAEkgICAgAAgASAANgJcIAFBCBDUgICAADYCWCABQQgQ1ICAgAA2AlQgASgCXCECIAEoAlghAyABIAJBDSADEJKCgIAANgJQIAEgASgCXCgCBEEMaikCADcDSCABQTxqEKCBgIAAAkADQCABKAJcKAIEKAIcIQQgAUH/wdcvNgIkIAFBIjYCICAEQQ4gAUEgahC6goCAAEF/c0EBcUUNAQJAIAEoAlxBDxC4goCAAEEBcUUNACABKAJcIQUgASgCVCEGIAFBPGoaIAEgASkDSDcDACAFIAFBPGogBiABEJCCgIAAIAEgASgCXBCegoCAADYCOCABKAJUIAEoAjgQ1YCAgAAgASABKAJcKAIEQQxqKQIANwNIDAELIAEgASgCXBCOgoCAADYCNCABKAI0KAIAIQcgAUE8aiAHEKaBgIAAIAEoAjQQv4KAgAAMAAsLIAEoAlwhCCABKAJUIQkgAUE8ahogASABKQNINwMIIAggAUE8aiAJIAFBCGoQkIKAgAAgASgCXCEKIAEoAlghCyABIApBDiALEJKCgIAANgIwIAEoAlAhDCABKAJUIQ0gASgCMCEOIAEoAlBBDGohDyABKAIwQQxqQQhqIRAgASgCWCERIAEgDykCADcDGCABIBApAgA3AxAgASAMIA0gDiABQRhqIAFBEGogERDngICAADYCLCABQTxqEKuBgIAAIAEoAlAQv4KAgAAgASgCMBC/goCAACABKAIsIRIgAUHgAGokgICAgAAgEg8LjwMBCn8jgICAgABBMGshASABJICAgIAAIAEgADYCKCABIAEoAigQpoKAgAA2AiQCQAJAIAEoAiQtAChBAXFFDQAgASABKAIoIAEoAiQQp4KAgAA2AiwMAQsCQCABKAIkLQAoQQFxDQAgASgCJCgCHCgCABDUgYCAAEEBcUUNACABKAIoEIeCgIAAQQFxDQAgASABKAIoIAEoAiQQp4KAgAA2AiwMAQsgASABKAIoIAEoAiQQqIKAgAA2AiACQCABKAIgQQBHQQFxRQ0AIAEgASgCIDYCLAwBCyABQQgQ1ICAgAA2AhwgASgCKCECIAEoAhwhAyACQYiqhYAAQZuMhYAAIAMQjYKAgAAgASgCJCEEIAEoAiQoAhwhBSABKAIkQQRqIQYgASgCJEEEakEIaiEHIAEoAhwhCEEAGkEAGiABIAYpAgA3AxAgASAHKQIANwMIQQAhCSABIAQgBSAJIAkgCSAJIAFBEGogAUEIaiAIEOKAgIAANgIsCyABKAIsIQogAUEwaiSAgICAACAKDwuhBQEQfyOAgICAAEGAAWshAiACJICAgIAAIAIgADYCeCACIAE2AnQgAiACKAJ4KAIEQQxqKQIANwNoIAJB3ABqEKCBgIAAAkACQANAIAIoAngoAgQoAhwhAyACQcQAakH/wdcvNgIAIAJBwABqQSI2AgAgAkEPNgI8IAJBDTYCOCACQQQ2AjQgAkEKNgIwIANBCSACQTBqELqCgIAAQX9zQQFxRQ0BAkAgAigCeEEhELiCgIAAQQFxRQ0AIAJB3ABqEKuBgIAAIAIoAnghBCACKAJ0IQUgAiAEQSEgBRCSgoCAADYCWCACKAJYKAIAIQYgAigCWEEMaiEHIAIoAlhBDGpBCGohCCACKAJ0IQlBusuEgAAaQZrwhYAAGiACIAcpAgA3AwggAiAIKQIANwMAQZrwhYAAIQpBusuEgAAgCiAGIAJBCGogAiAJEK+BgIAAIAIoAlgQv4KAgAAgAkEANgJ8DAMLIAIgAigCeBCOgoCAADYCVCACKAJUKAIAIQsgAkHcAGogCxCmgYCAACACKAJUEL+CgIAADAALCyACQQgQ1ICAgAA2AlACQCACQdwAahCigYCAAEEAS0EBcUUNACACQdwAahChgYCAACEMIAIoAngoAgRBDGohDSACKAJQIQ4gAiACKQNoNwMYIAIgDSkCADcDECACIAwgAkEYaiACQRBqIA4Q5oCAgAA2AkwgAkHcAGoQq4GAgAAgAiACKAJMNgJ8DAELIAIoAngoAgRBDGohDyACKAJQIRBB/7uGgAAaIAIgAikDaDcDKCACIA8pAgA3AyAgAkH/u4aAACACQShqIAJBIGogEBDmgICAADYCSCACQdwAahCrgYCAACACIAIoAkg2AnwLIAIoAnwhESACQYABaiSAgICAACARDwuqBAEVfyOAgICAAEHQAGshASABJICAgIAAIAEgADYCTCABQQgQ1ICAgAA2AkggAUEIENSAgIAANgJEIAEoAkwhAiABKAJIIQMgASACQQogAxCSgoCAADYCQCABKAJMIAEoAkQQsIKAgAAgASgCTCEEIAEoAkghBSABIARBAyAFEJKCgIAANgI8IAEoAkwgASgCRBCwgoCAACABKAJMIQYgASgCSCEHIAEgBkELIAcQkoKAgAA2AjgCQCABKAI8QQBHQQFxRQ0AIAEoAjwoAgAQ1IGAgABBAXFFDQAgASgCTBCHgoCAAEEBcQ0AIAEgASgCPCgCABDWgYCAADYCNCABIAEoAjwoAgAQ1YGAgAA2AjAgASgCPCEIIAEoAjQhCSABKAIwIQogASgCQEEMaiELIAEoAjhBDGpBCGohDCABKAJIIQ0gASALKQIANwMgIAEgDCkCADcDGCAIIAkgCiABQSBqIAFBGGogDRC7gYCAACABKAI0EJaMgIAAIAEoAjAQloyAgAALIAEoAkAhDiABKAI8IQ8gASgCRCEQIAEoAjghESABKAJAQQxqIRIgASgCOEEMakEIaiETIAEoAkghFCABIBIpAgA3AxAgASATKQIANwMIIAEgDiAPIBAgESABQRBqIAFBCGogFBDhgICAADYCLCABKAJAEL+CgIAAIAEoAjwQv4KAgAAgASgCOBC/goCAACABKAIsIRUgAUHQAGokgICAgAAgFQ8L6wgLC38BfgF/AX4BfwF+AX8BfgF/AX4NfyOAgICAAEGQAWshASABJICAgIAAIAEgADYCiAEgAUEIENSAgIAANgKEASABQQgQ1ICAgAA2AoABIAEoAogBIQIgASgChAEhAyABIAJBCSADEJKCgIAANgJ8IAEoAogBIQQgASgChAEhBSABIARBAyAFEJKCgIAANgJ4AkADQCABKAKIASgCBCgCHCEGIAFB/8HXLzYCKCABQSI2AiQgAUEMNgIgIAZBCyABQSBqELqCgIAAQX9zQQFxRQ0BIAEoAogBKAIEKAIcIQcgAUH/wdcvNgIEIAFBAjYCAAJAIAdBACABELqCgIAAQQFxRQ0AIAEoAogBIAEoAoABEKmCgIAADAELAkAgASgCiAEoAgQoAhxBA0ZBAXFFDQAgASgCgAEgASgCiAEQqoKAgAAQ1YCAgAAMAQsCQCABKAKIASgCBCgCHEEPRkEBcUUNACABKAKIASABKAKAARCrgoCAAAwBCwJAIAEoAogBKAIEKAIcQR1GQQFxRQ0AIAEoAoABIAEoAogBEKqCgIAAENWAgIAADAELAkAgASgCiAEoAgQoAhxBHEZBAXFFDQAgASgCiAEoAgAhCEEwIQkgCCAJaigCACEKIAkgAUHAAGpqIAo2AgBBKCELIAggC2opAgAhDCALIAFBwABqaiAMNwMAQSAhDSAIIA1qKQIAIQ4gDSABQcAAamogDjcDAEEYIQ8gCCAPaikCACEQIA8gAUHAAGpqIBA3AwBBECERIAggEWopAgAhEiARIAFBwABqaiASNwMAQQghEyAIIBNqKQIAIRQgEyABQcAAamogFDcDACABIAgpAgA3A0AgASABQcAAahDqgYCAADYCPAJAIAEoAjxBAEdBAXFFDQAgASgCPCgCHEEDRkEBcUUNACABKAI8EL+CgIAAIAEoAoABIAEoAogBEKqCgIAAENWAgIAADAILIAEoAjwQv4KAgAALIAEoAogBIRUgASgChAEhFiAVQeXuhIAAQbyBhoAAIBYQjYKAgAAMAAsLIAFBADoAOyABIAEoAogBQQsQkYKAgAA2AjQCQAJAIAEoAjRBAEZBAXFFDQAgASgCiAEhFyABKAKEASEYIAEgF0EMIBgQkoKAgAA2AjQCQCABKAI0QQBGQQFxRQ0AIAEoAnwQv4KAgAAgASgCeBC/goCAACABQYABahDbgICAACABQYQBahDbgICAACABQQA2AowBDAILIAFBAToAOwsgASgCfCEZIAEoAnghGiABKAI0IRsgASgCgAEhHCABLQA7IR0gASgCfEEMaiEeIAEoAjRBDGpBCGohHyABKAKEASEgIAEgHikCADcDGCABIB8pAgA3AxAgASAZIBogGyAcIB1BAXEgAUEYaiABQRBqICAQ4ICAgAA2AjAgASgCfBC/goCAACABKAJ4EL+CgIAAIAEoAjQQv4KAgAAgASABKAIwNgKMAQsgASgCjAEhISABQZABaiSAgICAACAhDwudAQEIfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGCACKAIYIQMgAigCGCgCHCEEIAIoAhhBBGohBSACKAIYQQRqQQhqIQZBABpBARogAiAFKQIANwMQIAIgBikCADcDCEEBIQdBACEIIAMgBCAIIAggByAIIAJBEGogAkEIaiAIEOKAgIAAIQkgAkEgaiSAgICAACAJDwvuBAEKfyOAgICAAEHAAGshAiACJICAgIAAIAIgADYCOCACIAE2AjQgAkEIENSAgIAANgIwIAJBCBDUgICAADYCLCACKAI4IAIoAjQoAhwQhIKAgAACQAJAIAIoAjQoAhwoAgBBAEdBAXFFDQAgAigCNCgCHCgCABCJgoCAAEEBcUUNACACIAIoAjQoAhwoAgAQiIKAgAA2AiggAigCOCACKAIoEIuCgIAAIAIoAjggAigCLCACKAIwEKyCgIAADAELIAIoAjggAigCLCACKAIwEJqCgIAACwJAAkAgAigCOEEKELiCgIAAQQFxDQAgAiACKAI0IAIoAiwgAigCMBCTgoCAADYCPAwBCyACIAIoAjgQpYKAgAA2AiQCQCACKAI4EIeCgIAAQQFxDQAgAigCJCgCHCgCABDUgYCAAEEBcUUNACACKAIsIAIoAiQQ2ICAgAAgAigCOCACKAIsIAIoAjAQmoKAgAAgAiACKAI4EKWCgIAANgIkCyACIAIoAjggAigCJCgCHCgCABCFgoCAAEEBcToAIwJAAkAgAi0AI0EBcUUNACACIAIoAjgQhoKAgAA2AhwgAigCHBC/goCAAAwBCyACKAI4IAIoAiQgAigCMBCUgoCAAAsgAigCNCEDIAIoAjQoAhwhBCACKAIsIQUgAigCJCEGIAIoAjRBBGohByACKAIkQQRqQQhqIQggAigCMCEJQQAaQQAaIAIgBykCADcDECACIAgpAgA3AwhBACEKIAIgAyAEIAUgBiAKIAogAkEQaiACQQhqIAkQ4oCAgAA2AjwLIAIoAjwhCyACQcAAaiSAgICAACALDwujAQEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACIAIoAgxBABCRgoCAADYCBAJAAkAgAigCBEEAR0EBcUUNACACKAIMIAIoAgQgAigCCBCtgoCAAAwBCyACIAIoAgxBAhCRgoCAADYCACACKAIAQQBHQQFxRQ0AIAIoAgwgAigCACACKAIIEK2CgIAACyACQRBqJICAgIAADwuBCwEjfyOAgICAAEHQAWshASABJICAgIAAIAEgADYCyAEgASABKALIARCugoCAADYCxAECQAJAIAEoAsgBKAIUQQBHQQFxRQ0AIAEoAsgBKAIULQAAQQFxRQ0AIAEoAsgBKAIEKAIcQRRGIQJBASEDIAJBAXEhBCADIQUCQCAEDQAgASgCyAEoAgBBFBDjgYCAACEFCyABIAVBAXE6AMMBAkAgAS0AwwFBAXFFDQAgAUG0AWoQoIGAgAAgAUIANwOoASABQgA3A6ABIAFBADYCnAEgAUEANgKYASABQQA6AJcBAkADQCABKALIASgCBCgCHCEGIAFB/8HXLzYCJCABQQI2AiAgBkEAIAFBIGoQuoKAgABBAXFFDQEgASABKALIARCOgoCAADYCkAECQCABLQCXAUEBcQ0AIAFBAToAlwEgASABKAKQAUEMaikCADcDqAEgASABKAKQASgCBDYCnAELIAEoApABKAIAIQcgAUG0AWogBxCmgYCAACABKAKQARC/goCAAAwACwsgASABKALIARCOgoCAADYCjAECQCABLQCXAUEBcQ0AIAFBAToAlwEgASABKAKMAUEMaikCADcDqAEgASABKAKMASgCBDYCnAELIAEoAowBKAIAIQggAUG0AWogCBCmgYCAACABIAEoAowBQQxqQQhqKQIANwOgASABIAEoAowBKAIINgKYASABKAKMARC/goCAAAJAA0AgASgCyAEoAgQoAhwhCSABQf/B1y82AhQgAUECNgIQIAlBACABQRBqELqCgIAAQQFxRQ0BIAEgASgCyAEQjoKAgAA2AogBIAEoAogBKAIAIQogAUG0AWogChCmgYCAACABIAEoAogBQQxqQQhqKQIANwOgASABIAEoAogBKAIINgKYASABKAKIARC/goCAAAwACwsgAUEBQSAQnYyAgAA2AoQBIAEoAoQBQRQ2AhwgASgCtAEQxIKAgAAhCyABKAKEASALNgIAIAEoAoQBQQxqIQwgAUH0AGogASkDqAE3AgAgAUH0AGpBCGogASkDoAE3AgAgDCABKQJ0NwIAQQghDSAMIA1qIA0gAUH0AGpqKQIANwIAIAEoAoQBQQRqIQ4gASABKAKcATYCbCABIAEoApgBNgJwIA4gASkCbDcCACABQbQBahCrgYCAACABIAEoAsgBEK+CgIAANgJoIAEoAsQBIQ8gASgChAEhECABKAJoIREgASgCxAFBBGohEiABKAJoQQRqQQhqIRMgASASKQIANwMIIAEgEykCADcDAEEAIRQgASAPIBAgESABQQhqIAEgFBDlgICAADYCzAEMAgsgASgCxAEhFSABKALEAUEEaiEWIAEoAsQBQQRqQQhqIRdBABogASAWKQIANwMwIAEgFykCADcDKEEAIRggASAVIBggGCABQTBqIAFBKGogGBDlgICAADYCzAEMAQsgASgCyAFBABCwgoCAACABIAEoAsgBQRQQkYKAgAA2AmQCQCABKAJkQQBHQQFxRQ0AIAEoAsgBQQAQsIKAgAAgASABKALIARCvgoCAADYCYCABKALEASEZIAEoAmQhGiABKAJgIRsgASgCxAFBBGohHCABKAJgQQRqQQhqIR0gASAcKQIANwNAIAEgHSkCADcDOEEAIR4gASAZIBogGyABQcAAaiABQThqIB4Q5YCAgAA2AlwgASgCZBC/goCAACABIAEoAlw2AswBDAELIAEoAsQBIR8gASgCxAFBBGohICABKALEAUEEakEIaiEhQQAaIAEgICkCADcDUCABICEpAgA3A0hBACEiIAEgHyAiICIgAUHQAGogAUHIAGogIhDlgICAADYCzAELIAEoAswBISMgAUHQAWokgICAgAAgIw8LkQQKDH8BfgF/AX4BfwF+AX8BfgF/AX4jgICAgABB0ABrIQIgAiSAgICAACACIAA2AkwgAiABNgJIIAIoAkwoAgQoAgBBAEchA0EAIQQgA0EBcSEFIAQhBgJAIAVFDQAgAigCTCgCBCgCABDoi4CAAEEDTyEHQQAhCCAHQQFxIQkgCCEGIAlFDQAgAigCTCgCBCgCAEHGloaAAEEDEOmLgIAAQQBGIQYLIAIgBkEBcToARwJAAkAgAi0AR0EBcQ0AIAIoAkggAigCTBCegoCAABDVgICAAAwBCyACKAJMKAIAIQpBMCELIAogC2ooAgAhDCALIAJBEGpqIAw2AgBBKCENIAogDWopAgAhDiANIAJBEGpqIA43AwBBICEPIAogD2opAgAhECAPIAJBEGpqIBA3AwBBGCERIAogEWopAgAhEiARIAJBEGpqIBI3AwBBECETIAogE2opAgAhFCATIAJBEGpqIBQ3AwBBCCEVIAogFWopAgAhFiAVIAJBEGpqIBY3AwAgAiAKKQIANwMQIAIgAkEQahDqgYCAADYCDCACKAIMEL+CgIAAIAJBEGoQsYKAgAAgAiACQRBqELKCgIAAQQFxOgALAkAgAi0AC0EBcUUNACACKAJIIAIoAkwQqoKAgAAQ1YCAgAAMAQsgAigCSCACKAJMEJ6CgIAAENWAgIAACyACQdAAaiSAgICAAA8LzAYBDX8jgICAgABBkAFrIQMgAySAgICAACADIAA2AowBIAMgATYCiAEgAyACNgKEASADQfgAahCggYCAACADIAMoAowBKAIEQQxqKQIANwNwIAMgAygCjAEoAhAQioKAgAA2AmwCQAJAIAMoAmxBAEZBAXFFDQAgAygCjAEQjIKAgAAgA0H4AGoQq4GAgAAMAQsCQANAIAMoAowBQSIQuIKAgABBf3NBAXFFDQECQCADKAKMAUEPELiCgIAAQQFxRQ0AIAMoAowBIQQgAygCiAEhBSADQfgAahogAyADKQNwNwMAIAQgA0H4AGogBSADEJCCgIAAIAMgAygCjAEQnoKAgAA2AmggAygCiAEgAygCaBDVgICAACADIAMoAowBKAIEQQxqKQIANwNwDAELAkAgAygCjAFBChC4goCAAEEBcUUNACADKAKMASgCACEGIANByABqIAYQ5YGAgAAgAyADKAKMASgCABDqgYCAADYCRCADQQA6AEMCQCADKAJEQQBHQQFxRQ0AIAMoAkQoAhxBA0ZBAXFFDQAgAygCRCgCAEEAR0EBcUUNACADIAMoAkQoAgAgAygCjAEoAhAQlYKAgABBAXE6AEMLIAMoAowBKAIAIQdBGCEIIAggA0EQamogCCADQcgAamopAgA3AwBBECEJIAkgA0EQamogCSADQcgAamopAgA3AwBBCCEKIAogA0EQamogCiADQcgAamopAgA3AwAgAyADKQJINwMQIAcgA0EQahDmgYCAAAJAIAMoAkRBAEdBAXFFDQAgAygCRBC/goCAAAsCQCADLQBDQQFxRQ0AIAMoAowBIQsgAygCiAEhDCADQfgAahogAyADKQNwNwMIIAsgA0H4AGogDCADQQhqEJCCgIAAIAMoAowBEIyCgIAAIANB+ABqEKuBgIAADAQLCyADIAMoAowBEI6CgIAANgI8IAMoAjwoAgAhDSADQfgAaiANEKaBgIAAIAMoAjwQv4KAgAAMAAsLIAMoAowBIQ4gAygCiAEhDyADQfgAahogAyADKQNwNwMwIA4gA0H4AGogDyADQTBqEJCCgIAAIAMoAowBEIyCgIAAIANB+ABqEKuBgIAACyADQZABaiSAgICAAA8L1wEBBX8jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACNgIkAkAgAygCLCgCFEEAR0EBcUUNACADKAIsKAIULQAAQQFxRQ0AIANBCBDUgICAADYCICADKAIoIQQgAygCKEEMaiEFIAMoAihBDGpBCGohBiADKAIgIQcgAyAFKQIANwMQIAMgBikCADcDCCADIAQgA0EQaiADQQhqIAcQ64CAgAA2AhwgAygCJCADKAIcENWAgIAACyADKAIoEL+CgIAAIANBMGokgICAgAAPC5wFAQt/I4CAgIAAQYABayEBIAEkgICAgAAgASAANgJ8IAFBCBDUgICAADYCeCABQQgQ1ICAgAA2AnQgAUHoAGoQoIGAgAAgASABKAJ8KAIEQQxqKQIANwNgAkADQCABKAJ8KAIEKAIcIQJBFCEDIAMgAUEgampB/8HXLzYCACABQTBqQSI2AgAgAUEMNgIsIAFBCzYCKCABQQI2AiQgAUEANgIgIAIgAyABQSBqELqCgIAAQX9zQQFxRQ0BAkAgASgCfEEPELiCgIAAQQFxRQ0AIAEoAnwhBCABKAJ0IQUgAUHoAGoaIAEgASkDYDcDACAEIAFB6ABqIAUgARCQgoCAACABIAEoAnwQnoKAgAA2AlwgASgCdCABKAJcENWAgIAAIAEgASgCfCgCBEEMaikCADcDYAwBCyABIAEoAnwQjoKAgAA2AlggASgCWCgCACEGIAFB6ABqIAYQpoGAgAAgASgCWBC/goCAAAwACwsgASgCfCEHIAEoAnQhCCABQegAahogASABKQNgNwMYIAcgAUHoAGogCCABQRhqEJCCgIAAIAFCADcDUCABQgA3A0gCQAJAIAEoAnQoAgRBAEtBAXFFDQAgASABKAJ0QQAQ1oCAgAA2AkQgASABKAJ0IAEoAnQoAgRBAWsQ1oCAgAA2AkAgASABKAJEQQRqKQIANwNQIAEgASgCQEEEakEIaikCADcDSAwBCyABIAEoAnwoAgRBDGopAgA3A1AgASABKAJ8KAIEQQxqKQIANwNICyABKAJ0IQkgASgCeCEKIAEgASkDUDcDECABIAEpA0g3AwggASAJIAFBEGogAUEIaiAKEOSAgIAANgI8IAFB6ABqEKuBgIAAIAEoAjwhCyABQYABaiSAgICAACALDwuRCAEefyOAgICAAEGgAWshASABJICAgIAAIAEgADYCmAEgAUEIENSAgIAANgKUASABQQgQ1ICAgAA2ApABAkACQCABKAKYAUEPELiCgIAAQQFxRQ0AIAEgASgCmAEQnoKAgAA2AowBIAEoApQBIAEoAowBENWAgIAAIAEoApQBIQIgASgCjAFBBGohAyABKAKMAUEEakEIaiEEIAEoApABIQVBABpBABogASADKQIANwMQIAEgBCkCADcDCEEAIQYgASAGIAIgBiAGIAFBEGogAUEIaiAFEOOAgIAANgKcAQwBCwJAIAEoApgBQQMQuIKAgABBAXFFDQAgASgCmAEhByABKAKQASEIIAEgB0EDIAgQkoKAgAA2AogBIAEgASgCiAEQ3YCAgAA2AoQBIAEoAogBEL+CgIAAIAEoApQBIAEoAoQBENWAgIAAIAEoApQBIQkgASgChAFBBGohCiABKAKEAUEEakEIaiELIAEoApABIQxBABpBABogASAKKQIANwMgIAEgCykCADcDGEEAIQ0gASANIAkgDSANIAFBIGogAUEYaiAMEOOAgIAANgKcAQwBCwJAIAEoApgBQRUQuIKAgABBAXFFDQAgASABKAKYASABKAKUASABKAKQARCzgoCAADYCnAEMAQsCQCABKAKYAUEWELiCgIAAQQFxRQ0AIAEgASgCmAEQjoKAgAA2AoABIAEgASgCgAFBDGopAgA3A3ggASABKAKAAUEMakEIaikCADcDcCABKAKQASEOQZWRhYAAGkGDr4aAABpB86aGgAAaIAEgASkCeDcDMCABIAEpAnA3AyhB86aGgAAhD0GDr4aAACEQQZWRhYAAIBAgDyABQTBqIAFBKGogDhCvgYCAACABKAKUASERIAEoApABIRJBABpBABogASABKQJ4NwNAIAEgASkCcDcDOEEAIRMgASATIBEgEyATIAFBwABqIAFBOGogEhDjgICAADYCbCABKAKAARC/goCAACABIAEoAmw2ApwBDAELIAEoApgBKAIEKAIcEL2CgIAAIRQgASgCmAEoAgRBDGohFSABKAKYASgCBEEMakEIaiEWIAEoApABIRdB5e6EgAAaQdvrhYAAGiABIBUpAgA3A1AgASAWKQIANwNIQdvrhYAAIRhB5e6EgAAgGCAUIAFB0ABqIAFByABqIBcQr4GAgAAgASgClAEhGSABKAKYASgCBEEMaiEaIAEoApgBKAIEQQxqQQhqIRsgASgCkAEhHEEAGkEAGiABIBopAgA3A2AgASAbKQIANwNYQQAhHSABIB0gGSAdIB0gAUHgAGogAUHYAGogHBDjgICAADYCaCABIAEoAmg2ApwBCyABKAKcASEeIAFBoAFqJICAgIAAIB4PC9EBAQJ/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYAkADQCACKAIcKAIEKAIcIQMgAkH/wdcvNgIEIAJBAjYCACADQQAgAhC6goCAAEEBcUUNASACIAIoAhwQjoKAgAA2AhQCQAJAIAIoAhwoAhRBAEdBAXFFDQAgAigCHCgCFC0AAEEBcUUNACACKAIYQQBHQQFxRQ0AIAIoAhwgAigCFCACKAIYEK2CgIAADAELIAIoAhQQv4KAgAALDAALCyACQSBqJICAgIAADwt6AQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgAUEANgIIAkADQCABIAEoAgwQ6oGAgAA2AggCQCABKAIIKAIcQRFGQQFxRQ0AIAEoAggQv4KAgAAMAgsgASgCCBC/goCAAEEBQQFxDQALCyABQRBqJICAgIAADwvRAgECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIIAFBADYCBAJAA0AgASABKAIIEOqBgIAANgIEAkAgASgCBCgCHEEURkEBcUUNACABKAIEEL+CgIAAIAFBAUEBcToADwwCCwJAAkACQCABKAIEKAIcRQ0AIAEoAgQoAhxBAkZBAXFFDQELIAEoAgQQv4KAgAAMAQsCQAJAIAEoAgQoAhxBA0ZBAXENACABKAIEKAIcQSBGQQFxDQAgASgCBCgCHEEYRkEBcQ0AIAEoAgQoAhxBD0ZBAXFFDQELAkACQCABKAIEKAIcQQ9GQQFxRQ0AIAEoAgQQv4KAgAAgASgCCBCxgoCAAAwBCyABKAIEEL+CgIAACwwBCyABKAIEEL+CgIAAIAFBAEEBcToADwwCC0EBQQFxDQALCyABLQAPQQFxIQIgAUEQaiSAgICAACACDwuXEgFMfyOAgICAAEGgAmshAyADJICAgIAAIAMgADYCnAIgAyABNgKYAiADIAI2ApQCIANBiAJqEKCBgIAAIAMoApwCIQQgAygClAIhBSADIARBFSAFEJKCgIAANgKEAiADIAMoApwCKAIEQQxqKQIANwP4AQNAIAMoApwCQSIQuIKAgAAhBkEAIQcgBkEBcSEIIAchCQJAIAgNACADKAKcAkEVELiCgIAAIQpBACELIApBAXEhDCALIQ0CQCAMRQ0AIAMoAoQCQQBHIQ5BACEPIA5BAXEhECAPIQ0gEEUNACADKAKcAigCBCgCACADKAKEAigCABDmi4CAAEEARiENCyANQX9zIQkLAkAgCUEBcUUNAAJAIAMoApwCQQ8QuIKAgABBAXFFDQAgAygCnAIhESADKAKYAiESIANBiAJqGiADIAMpA/gBNwMAIBEgA0GIAmogEiADEJCCgIAAIAMoApgCIAMoApwCEJ6CgIAAENWAgIAAIAMgAygCnAIoAgRBDGopAgA3A/gBDAILAkAgAygCnAJBFxC4goCAAEEBcUUNACADKAKcAigCACETIANB2AFqIBMQ5YGAgAAgAyADKAKcAigCABDqgYCAADYC1AECQCADKALUAUEAR0EBcUUNACADKALUASgCHEEVRkEBcUUNACADKAKEAkEAR0EBcUUNACADKALUASgCACADKAKEAigCABDmi4CAAA0AIAMoApwCKAIEKAIAIRQgA0GIAmogFBCmgYCAACADKALUASgCACEVIANBiAJqIBUQpoGAgAAgAygCnAIoAgQQv4KAgAAgAygC1AEQv4KAgAAgAygCnAIoAgAQ6oGAgAAhFiADKAKcAiAWNgIEDAMLIAMoApwCKAIAIRdBGCEYIBggA0EIamogGCADQdgBamopAgA3AwBBECEZIBkgA0EIamogGSADQdgBamopAgA3AwBBCCEaIBogA0EIamogGiADQdgBamopAgA3AwAgAyADKQLYATcDCCAXIANBCGoQ5oGAgAACQCADKALUAUEAR0EBcUUNACADKALUARC/goCAAAsLIAMoApwCKAIEKAIAIRsgA0GIAmogGxCmgYCAACADKAKcAigCBBC/goCAACADKAKcAigCABDqgYCAACEcIAMoApwCIBw2AgQMAQsLAkAgAygCnAJBFRC4goCAAEEBcUUNACADKAKEAkEAR0EBcUUNACADKAKcAigCBCgCACADKAKEAigCABDmi4CAAA0AIAMoApwCKAIAIR0gA0G0AWogHRDlgYCAACADIAMoApwCKAIENgKwASADKAKcAigCABDqgYCAACEeIAMoApwCIB42AgQCQAJAAkAgAygCnAJBAxC4goCAAEEBcQ0AIAMoApwCQSAQuIKAgABBAXFFDQELIAMoAoQCKAIAIR8gAygCsAFBDGohICADKAKwAUEMakEIaiEhIAMoApQCISJB/4+FgAAaQaivhoAAGiADICApAgA3A2AgAyAhKQIANwNYQaivhoAAISNB/4+FgAAgIyAfIANB4ABqIANB2ABqICIQr4GAgAAgAygCnAIoAgAhJEEYISUgJSADQegAamogJSADQbQBamopAgA3AwBBECEmICYgA0HoAGpqICYgA0G0AWpqKQIANwMAQQghJyAnIANB6ABqaiAnIANBtAFqaikCADcDACADIAMpArQBNwNoICQgA0HoAGoQ5oGAgAAgAygCnAIoAgQQv4KAgAAgAygCsAEhKCADKAKcAiAoNgIEIAMoApwCKAIEKAIAISkgA0GIAmogKRCmgYCAACADKAKcAigCBBC/goCAACADKAKcAigCABDqgYCAACEqIAMoApwCICo2AgQDQCADKAKcAkEiELiCgIAAIStBACEsICtBAXEhLSAsIS4CQCAtDQAgAygCnAJBFRC4goCAACEvQQAhMCAvQQFxITEgMCEyAkAgMUUNACADKAKEAkEARyEzQQAhNCAzQQFxITUgNCEyIDVFDQAgAygCnAIoAgQoAgAgAygChAIoAgAQ5ouAgABBAEYhMgsgMkF/cyEuCwJAIC5BAXFFDQACQCADKAKcAkEPELiCgIAAQQFxRQ0AIAMoApwCITYgAygCmAIhNyADQYgCahogAyADKQP4ATcDKCA2IANBiAJqIDcgA0EoahCQgoCAACADKAKYAiADKAKcAhCegoCAABDVgICAACADIAMoApwCKAIEQQxqKQIANwP4AQwCCyADKAKcAigCBCgCACE4IANBiAJqIDgQpoGAgAAgAygCnAIoAgQQv4KAgAAgAygCnAIoAgAQ6oGAgAAhOSADKAKcAiA5NgIEDAELCwwBCyADKAKcAigCBBC/goCAACADKAKwASE6IAMoApwCIDo2AgQgAygCnAIoAgAhO0EYITwgPCADQYgBamogPCADQbQBamopAgA3AwBBECE9ID0gA0GIAWpqID0gA0G0AWpqKQIANwMAQQghPiA+IANBiAFqaiA+IANBtAFqaikCADcDACADIAMpArQBNwOIASA7IANBiAFqEOaBgIAACwsgAygCnAIhPyADKAKYAiFAIANBiAJqGiADIAMpA/gBNwNQID8gA0GIAmogQCADQdAAahCQgoCAACADQYgCahCrgYCAACADKAKcAiFBIAMoApQCIUIgAyBBQRUgQhCSgoCAADYCrAECQCADKAKEAkEAR0EBcUUNACADKAKsAUEAR0EBcUUNACADKAKEAigCACADKAKsASgCABDmi4CAAEUNACADKAKEAiFDIAMoAqwBIUQgAygCrAFBDGohRSADKAKsAUEMakEIaiFGIAMoApQCIUcgAyBFKQIANwNIIAMgRikCADcDQCBDIEQgA0HIAGogA0HAAGogRxC5gYCAAAsgAygChAIhSCADKAKYAiFJIAMoAqwBIUogAygChAJBDGohSyADKAKsAUEMakEIaiFMIAMoApQCIU1BARogAyBLKQIANwM4IAMgTCkCADcDMCADIEggSSBKQQEgA0E4aiADQTBqIE0Q44CAgAA2AqgBIAMoAoQCEL+CgIAAIAMoAqwBEL+CgIAAIAMoAqgBIU4gA0GgAmokgICAgAAgTg8LcgECfyOAgICAAEEQayEBIAEgADYCCCABKAIIIQIgAkECSxoCQAJAAkACQAJAIAIOAwABAgMLIAFBuIiEgAA2AgwMAwsgAUHQlISAADYCDAwCCyABQfvLhYAANgIMDAELIAFBjauEgAA2AgwLIAEoAgwPC7oBAQN/I4CAgIAAQRBrIQMgAySAgICAACADIAE2AgwgAyACNgIIIABBACkC3LyGgAA3AgAgA0EANgIEAkADQCADKAIEIAMoAghJQQFxRQ0BIAMoAgwgAygCBGotAAAhBEEYIQUCQAJAIAQgBXQgBXUQw4KAgABFDQAgACAAKAIAQQFqNgIAIABBADYCBAwBCyAAIAAoAgRBAWo2AgQLIAMgAygCBEEBajYCBAwACwsgA0EQaiSAgICAAA8LhQIBCX8jgICAgABBwABrIQQgBCSAgICAACAEIAA2AjwgBCABNgI4IAQgAjYCNCAEIAM2AjAgBCAEKAI8KAIEIAQoAjAo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gAAgAyAANgIMIAMgATYCCCADIAI2AgQgAygCCCEEAkAgAygCDCADKAIEIAQRgICAgACAgICAAEEBcUUNACADKAIMQQBHQQFxRQ0AIAMoAgwgAygCCCADKAIEEMaCgIAACyADQRBqJICAgIAADwuLIwECfyOAgICAAEHgAWshAyADJICAgIAAIAMgADYC3AEgAyABNgLYASADIAI2AtQBAkACQCADKALcAUEARkEBcUUNAAwBCyADKALcASgCACEEIARBHksaAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAEDh8AGQECAwQFBhkHCAkKGRkZCwwNDg8QERITFBUWFxkYGQsgAyADKALcATYC0AECQCADKALQASgCGEEAR0EBcUUNACADQQA2AswBAkADQCADKALMASADKALQASgCGBDagICAAElBAXFFDQEgAygC0AEoAhggAygCzAEQ1oCAgAAgAygC2AEgAygC1AEQxYKAgAAgAyADKALMAUEBajYCzAEMAAsLCwwZCyADIAMoAtwBNgLIAQJAIAMoAsgBKAIkQQBHQQFxRQ0AIANBADYCxAECQANAIAMoAsQBIAMoAsgBKAIkENqAgIAASUEBcUUNASADKALIASgCJCADKALEARDWgICAACADKALYASADKALUARDFgoCAACADIAMoAsQBQQFqNgLEAQwACwsLDBgLIAMgAygC3AE2AsABAkAgAygCwAEoAiBBAEdBAXFFDQAgA0EANgK8AQJAA0AgAygCvAEgAygCwAEoAiAQ2oCAgABJQQFxRQ0BIAMoAsABKAIgIAMoArwBENaAgIAAIAMoAtgBIAMoAtQBEMWCgIAAIAMgAygCvAFBAWo2ArwBDAALCwsMFwsgAyADKALcATYCuAECQCADKAK4ASgCGEEAR0EBcUUNACADKAK4ASgCGCADKALYASADKALUARDFgoCAAAsCQCADKAK4ASgCIEEAR0EBcUUNACADQQA2ArQBAkADQCADKAK0ASADKAK4ASgCIBDagICAAElBAXFFDQEgAygCuAEoAiAgAygCtAEQ1oCAgAAgAygC2AEgAygC1AEQxYKAgAAgAyADKAK0AUEBajYCtAEMAAsLCwJAIAMoArgBKAIkQQBHQQFxRQ0AIAMoArgBKAIkIAMoAtgBIAMoAtQBEMWCgIAACwwWCyADIAMoAtwBNgKwAQJAIAMoArABKAIcQQBHQQFxRQ0AIANBADYCrAECQANAIAMoAqwBIAMoArABKAIcENqAgIAASUEBcUUNASADKAKwASgCHCADKAKsARDWgICAACADKALYASADKALUARDFgoCAACADIAMoAqwBQQFqNgKsAQwACwsLDBULIAMgAygC3AE2AqgBAkAgAygCqAEoAhhBAEdBAXFFDQAgA0EANgKkAQJAA0AgAygCpAEgAygCqAEoAhgQ2oCAgABJQQFxRQ0BIAMoAqgBKAIYIAMoAqQBENaAgIAAIAMoAtgBIAMoAtQBEMWCgIAAIAMgAygCpAFBAWo2AqQBDAALCwsMFAsgAyADKALcATYCoAECQCADKAKgASgCGEEAR0EBcUUNACADKAKgASgCGCADKALYASADKALUARDFgoCAAAsCQCADKAKgASgCIEEAR0EBcUUNACADKAKgASgCICADKALYASADKALUARDFgoCAAAsMEwsgAyADKALcATYCnAECQCADKAKcASgCHEEAR0EBcUUNACADQQA2ApgBAkADQCADKAKYASADKAKcASgCHBDagICAAElBAXFFDQEgAygCnAEoAhwgAygCmAEQ1oCAgAAgAygC2AEgAygC1AEQxYKAgAAgAyADKAKYAUEBajYCmAEMAAsLCwwSCyADIAMoAtwBNgKUAQJAIAMoApQBKAIcQQBHQQFxRQ0AIANBADYCkAECQANAIAMoApABIAMoApQBKAIcENqAgIAASUEBcUUNASADKAKUASgCHCADKAKQARDWgICAACADKALYASADKALUARDFgoCAACADIAMoApABQQFqNgKQAQwACwsLDBELIAMgAygC3AE2AowBAkAgAygCjAEoAhxBAEdBAXFFDQAgA0EANgKIAQJAA0AgAygCiAEgAygCjAEoAhwQ2oCAgABJQQFxRQ0BIAMoAowBKAIcIAMoAogBENaAgIAAIAMoAtgBIAMoAtQBEMWCgIAAIAMgAygCiAFBAWo2AogBDAALCwsMEAsgAyADKALcATYChAECQCADKAKEASgCHEEAR0EBcUUNACADQQA2AoABAkADQCADKAKAASADKAKEASgCHBDagICAAElBAXFFDQEgAygChAEoAhwgAygCgAEQ1oCAgAAgAygC2AEgAygC1AEQxYKAgAAgAyADKAKAAUEBajYCgAEMAAsLCwwPCyADIAMoAtwBNgJ8AkAgAygCfCgCJEEAR0EBcUUNACADQQA2AngCQANAIAMoAnggAygCfCgCJBDagICAAElBAXFFDQEgAygCfCgCJCADKAJ4ENaAgIAAIAMoAtgBIAMoAtQBEMWCgIAAIAMgAygCeEEBajYCeAwACwsLDA4LIAMgAygC3AE2AnQCQCADKAJ0KAIkQQBHQQFxRQ0AIANBADYCcAJAA0AgAygCcCADKAJ0KAIkENqAgIAASUEBcUUNASADKAJ0KAIkIAMoAnAQ1oCAgAAgAygC2AEgAygC1AEQxYKAgAAgAyADKAJwQQFqNgJwDAALCwsCQCADKAJ0KAIoQQBHQQFxRQ0AIAMoAnQoAiggAygC2AEgAygC1AEQxYKAgAALAkAgAygCdCgCLEEAR0EBcUUNACADKAJ0KAIsIAMoAtgBIAMoAtQBEMWCgIAACwwNCyADIAMoAtwBNgJsAkAgAygCbCgCJEEAR0EBcUUNACADQQA2AmgCQANAIAMoAmggAygCbCgCJBDagICAAElBAXFFDQEgAygCbCgCJCADKAJoENaAgIAAIAMoAtgBIAMoAtQBEMWCgIAAIAMgAygCaEEBajYCaAwACwsLAkAgAygCbCgCKEEAR0EBcUUNACADKAJsKAIoIAMoAtgBIAMoAtQBEMWCgIAACwwMCyADIAMoAtwBNgJkAkAgAygCZCgCJEEAR0EBcUUNACADQQA2AmACQANAIAMoAmAgAygCZCgCJBDagICAAElBAXFFDQEgAygCZCgCJCADKAJgENaAgIAAIAMoAtgBIAMoAtQBEMWCgIAAIAMgAygCYEEBajYCYAwACwsLDAsLIAMgAygC3AE2AlwCQCADKAJcKAIkQQBHQQFxRQ0AIANBADYCWAJAA0AgAygCWCADKAJcKAIkENqAgIAASUEBcUUNASADKAJcKAIkIAMoAlgQ1oCAgAAgAygC2AEgAygC1AEQxYKAgAAgAyADKAJYQQFqNgJYDAALCwsCQCADKAJcKAIoQQBHQQFxRQ0AIANBADYCVAJAA0AgAygCVCADKAJcKAIoENqAgIAASUEBcUUNASADKAJcKAIoIAMoAlQQ1oCAgAAgAygC2AEgAygC1AEQxYKAgAAgAyADKAJUQQFqNgJUDAALCwsCQCADKAJcKAIsQQBHQQFxRQ0AIAMoAlwoAiwgAygC2AEgAygC1AEQxYKAgAALAkAgAygCXCgCMEEAR0EBcUUNACADKAJcKAIwIAMoAtgBIAMoAtQBEMWCgIAACwwKCyADIAMoAtwBNgJQAkAgAygCUCgCJEEAR0EBcUUNACADQQA2AkwCQANAIAMoAkwgAygCUCgCJBDagICAAElBAXFFDQEgAygCUCgCJCADKAJMENaAgIAAIAMoAtgBIAMoAtQBEMWCgIAAIAMgAygCTEEBajYCTAwACwsLAkAgAygCUCgCKEEAR0EBcUUNACADQQA2AkgCQANAIAMoAkggAygCUCgCKBDagICAAElBAXFFDQEgAygCUCgCKCADKAJIENaAgIAAIAMoAtgBIAMoAtQBEMWCgIAAIAMgAygCSEEBajYCSAwACwsLAkAgAygCUCgCLEEAR0EBcUUNACADKAJQKAIsIAMoAtgBIAMoAtQBEMWCgIAACwJAIAMoAlAoAjBBAEdBAXFFDQAgAygCUCgCMCADKALYASADKALUARDFgoCAAAsMCQsgAyADKALcATYCRAJAIAMoAkQoAiRBAEdBAXFFDQAgA0EANgJAAkADQCADKAJAIAMoAkQoAiQQ2oCAgABJQQFxRQ0BIAMoAkQoAiQgAygCQBDWgICAACADKALYASADKALUARDFgoCAACADIAMoAkBBAWo2AkAMAAsLCwJAIAMoAkQoAihBAEdBAXFFDQAgAygCRCgCKCADKALYASADKALUARDFgoCAAAsMCAsgAyADKALcATYCPAJAIAMoAjwoAiRBAEdBAXFFDQAgA0EANgI4AkADQCADKAI4IAMoAjwoAiQQ2oCAgABJQQFxRQ0BIAMoAjwoAiQgAygCOBDWgICAACADKALYASADKALUARDFgoCAACADIAMoAjhBAWo2AjgMAAsLCwJAIAMoAjwoAihBAEdBAXFFDQAgAygCPCgCKCADKALYASADKALUARDFgoCAAAsMBwsgAyADKALcATYCNAJAIAMoAjQoAiRBAEdBAXFFDQAgA0EANgIwAkADQCADKAIwIAMoAjQoAiQQ2oCAgABJQQFxRQ0BIAMoAjQoAiQgAygCMBDWgICAACADKALYASADKALUARDFgoCAACADIAMoAjBBAWo2AjAMAAsLCwJAIAMoAjQoAihBAEdBAXFFDQAgAygCNCgCKCADKALYASADKALUARDFgoCAAAsMBgsgAyADKALcATYCLAJAIAMoAiwoAiRBAEdBAXFFDQAgA0EANgIoAkADQCADKAIoIAMoAiwoAiQQ2oCAgABJQQFxRQ0BIAMoAiwoAiQgAygCKBDWgICAACADKALYASADKALUARDFgoCAACADIAMoAihBAWo2AigMAAsLCwJAIAMoAiwoAihBAEdBAXFFDQAgAygCLCgCKCADKALYASADKALUARDFgoCAAAsMBQsgAyADKALcATYCJAJAIAMoAiQoAiRBAEdBAXFFDQAgA0EANgIgAkADQCADKAIgIAMoAiQoAiQQ2oCAgABJQQFxRQ0BIAMoAiQoAiQgAygCIBDWgICAACADKALYASADKALUARDFgoCAACADIAMoAiBBAWo2AiAMAAsLCwwECyADIAMoAtwBNgIcAkAgAygCHCgCJEEAR0EBcUUNACADQQA2AhgCQANAIAMoAhggAygCHCgCJBDagICAAElBAXFFDQEgAygCHCgCJCADKAIYENaAgIAAIAMoAtgBIAMoAtQBEMWCgIAAIAMgAygCGEEBajYCGAwACwsLAkAgAygCHCgCKEEAR0EBcUUNACADKAIcKAIoIAMoAtgBIAMoAtQBEMWCgIAACwJAIAMoAhwoAixBAEdBAXFFDQAgAygCHCgCLCADKALYASADKALUARDFgoCAAAsCQCADKAIcKAIwQQBHQQFxRQ0AIAMoAhwoAjAgAygC2AEgAygC1AEQxYKAgAALAkAgAygCHCgCNEEAR0EBcUUNACADKAIcKAI0IAMoAtgBIAMoAtQBEMWCgIAACwwDCyADIAMoAtwBNgIUAkAgAygCFCgCJEEAR0EBcUUNACADQQA2AhACQANAIAMoAhAgAygCFCgCJBDagICAAElBAXFFDQEgAygCFCgCJCADKAIQENaAgIAAIAMoAtgBIAMoAtQBEMWCgIAAIAMgAygCEEEBajYCEAwACwsLAkAgAygCFCgCKEEAR0EBcUUNACADKAIUKAIoIAMoAtgBIAMoAtQBEMWCgIAACwJAIAMoAhQoAixBAEdBAXFFDQAgAygCFCgCLCADKALYASADKALUARDFgoCAAAsMAgsgAyADKALcATYCDAJAIAMoAgwoAiRBAEdBAXFFDQAgA0EANgIIAkADQCADKAIIIAMoAgwoAiQQ2oCAgABJQQFxRQ0BIAMoAgwoAiQgAygCCBDWgICAACADKALYASADKALUARDFgoCAACADIAMoAghBAWo2AggMAAsLCwwBCwsgA0HgAWokgICAgAAPC84EAwV/AX4EfyOAgICAAEHwAGshAiACJICAgIAAIAIgADYCbCACIAE2AmgCQAJAIAIoAmhBAEdBAXENACAAEMiCgIAADAELIAJB4ABqQe2phIAAEMmCgIAAIAJBAEEBcToAXyAAIAJB4ABqEMqCgIAAIAIoAmgQv4GAgAAhAyACQdQAaiADEIODgIAAIABBnqqFgAAgAkHUAGoQy4KAgAAgAkHUAGoQzIKAgAAaIAIoAmgoAhQhBCACQcwAaiAEEIODgIAAIABBy7iFgAAgAkHMAGoQzYKAgAAgAkHMAGoQzIKAgAAaIAIoAmhBBGohBUEIIQYgBSAGaikCACEHIAYgAkEwamogBzcDACACIAUpAgA3AzAgAkHEAGoaQQghCCAIIAJBCGpqIAggAkEwamopAgA3AwAgAiACKQIwNwMIIAJBxABqIAJBCGoQiYOAgAAgAEGF5oSAACACQcQAahDOgoCAACACQcQAahDMgoCAABogAigCaCgCGCEJIAJBKGogCRCDg4CAACAAQcLghIAAIAJBKGoQz4KAgAAgAkEoahDMgoCAABogAigCaCgCHCEKIAJBIGogChCDg4CAACAAQezFhYAAIAJBIGoQzoKAgAAgAkEgahDMgoCAABogAigCaCgCICELIAJBGGogCxCDg4CAACAAQbe+hYAAIAJBGGoQ0IKAgAAgAkEYahDMgoCAABogAkEBQQFxOgBfAkAgAi0AX0EBcQ0AIAAQzIKAgAAaCyACQeAAahDMgoCAABoLIAJB8ABqJICAgIAADws1AQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgAEEEENGCgIAAGiABQRBqJICAgIAADwtFAQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAAgAigCCBCBgICAABDRgoCAABogAkEQaiSAgICAAA8LRgEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCAAIAIoAggQ0oKAgABBABDTgoCAACACQRBqJICAgIAADwuRAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ0oKAgAAhBSADKAIYIQYgA0EMaiAEIAYQ1IKAgAAgBSADQQxqENKCgIAAIAQgAygCFBDVgoCAABDSgoCAABCCgICAACADQQxqEMyCgIAAGiADQSBqJICAgIAADwtnAQN/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgggASgCCCECIAEgAjYCDAJAIAIQ1oKAgABBAXFFDQAgAhDSgoCAABCDgICAACACQQA2AgQLIAEoAgwhAyABQRBqJICAgIAAIAMPC5EBAQR/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIcIQQgBBDSgoCAACEFIAMoAhghBiADQQxqIAQgBhDXgoCAACAFIANBDGoQ0oKAgAAgBCADKAIUENWCgIAAENKCgIAAEIKAgIAAIANBDGoQzIKAgAAaIANBIGokgICAgAAPC5EBAQR/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIcIQQgBBDSgoCAACEFIAMoAhghBiADQQxqIAQgBhDYgoCAACAFIANBDGoQ0oKAgAAgBCADKAIUENWCgIAAENKCgIAAEIKAgIAAIANBDGoQzIKAgAAaIANBIGokgICAgAAPC5EBAQR/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIcIQQgBBDSgoCAACEFIAMoAhghBiADQQxqIAQgBhDZgoCAACAFIANBDGoQ0oKAgAAgBCADKAIUENWCgIAAENKCgIAAEIKAgIAAIANBDGoQzIKAgAAaIANBIGokgICAgAAPC5EBAQR/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIcIQQgBBDSgoCAACEFIAMoAhghBiADQQxqIAQgBhDagoCAACAFIANBDGoQ0oKAgAAgBCADKAIUENWCgIAAENKCgIAAEIKAgIAAIANBDGoQzIKAgAAaIANBIGokgICAgAAPC08BAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCEDIAMQ2ouAgAA2AgAgAyACKAIINgIEIAJBEGokgICAgAAgAw8LHwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMKAIEDwuhAgEKfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIsIAMgATYCKCADIAI2AiRBAC0A6KSJgABBAXEhBEEAIQUCQCAEQf8BcSAFQf8BcUZBAXFFDQBB5LyGgAAQ6YKAgABB5LyGgAAQ6oKAgABBAhCEgICAACEGQQAgBjYC5KSJgABBASEHQQAgBzoA6KSJgAALIANBGGoQ64KAgAAaIANBADYCFEEAKALkpImAACEIIAMoAighCSADKAIkIQogA0EYahDsgoCAACELIAMgCCAJIAogA0EUaiALEIWAgIAAEO2CgIAANgIQIAMoAhQhDCADQQxqIAwQ7oKAgAAaIAAgAygCEBDvgoCAACADQQxqEPCCgIAAGiADQTBqJICAgIAADwtGAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCAAIAMoAgQQ9oKAgAAaIANBEGokgICAgAAPCyMBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAggPCyUBAX8jgICAgABBEGshASABIAA2AgwgASgCDCgCBEEIS0EBcQ8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACADKAIEEPaCgIAAGiADQRBqJICAgIAADwtGAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCAAIAMoAgQQ9oKAgAAaIANBEGokgICAgAAPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBD2goCAABogA0EQaiSAgICAAA8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACADKAIEEPaCgIAAGiADQRBqJICAgIAADwuRBAMFfwF+A38jgICAgABB4ABrIQIgAiSAgICAACACIAA2AlwgAiABNgJYAkACQCACKAJYQQBHQQFxDQAgABDIgoCAAAwBCyACQdAAakHtqYSAABDJgoCAACACQQBBAXE6AE8gACACQdAAahDKgoCAACACKAJYEL+BgIAAIQMgAkHEAGogAxCDg4CA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AWo2AhgMAAsLCyACQQFBAXE6AB8CQCACLQAfQQFxDQAgABDMgoCAABoLIAJBIGoQzIKAgAAaIAJBMGokgICAgAAPC5kCAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIAkACQCACKAIIQQBHQQFxDQAgABDIgoCAAAwBCyACKAIIKAIAIQMgA0EISxoCQAJAAkACQAJAAkACQAJAAkACQCADDgkAAQIDBAUGBwgJCyAAIAIoAggQx4KAgAAMCQsgACACKAIIENuCgIAADAgLIAAgAigCCBDegoCAAAwHCyAAIAIoAggQ34KAgAAMBgsgACACKAIIEOCCgIAADAULIAAgAigCCBDhgoCAAAwECyAAIAIoAggQ4oKAgAAMAwsgACACKAIIEOOCgIAADAILIAAgAigCCBDkgoCAAAwBCyAAEMiCgIAACyACQRBqJICAgIAADwtTAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADKAIMENKCgIAAIAMoAgggAygCBBDogoCAACADQRBqJICAgIAADwueAgELfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIsIAMgATYCKCADIAI2AiRBAC0A8KSJgABBAXEhBEEAIQUCQCAEQf8BcSAFQf8BcUZBAXFFDQBBh72GgAAQ94KAgABBh72GgAAQ+IKAgABBARCEgICAACEGQQAgBjYC7KSJgABBASEHQQAgBzoA8KSJgAALIAMoAiQhCCADQRhqIAgQ+YKAgAAaIANBADYCFEEAKALspImAACEJIAMoAiwhCiADKAIoIQsgA0EYahD6goCAACEMIAkgCiALIANBFGogDBCFgICAABD7goCAACADKAIUIQ0gA0EMaiANEO6CgIAAGhD8goCAACADQQxqEPCCgIAAGiADQTBqJICAgIAADwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQEPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBDxgoCAACECIAFBEGokgICAgAAgAg8LSwECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwhAiABIAIQ8oKAgAA2AgggAUEIahDzgoCAACABQRBqJICAgIAAIAIPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEPSCgIAAIQIgAUEQaiSAgICAACACDwseAQF/I4CAgIAAQRBrIQEgASAAOQMIIAErAwj8Aw8LMQECfyOAgICAAEEQayECIAIgADYCDCACIAE2AgggAigCDCEDIAMgAigCCDYCACADDws+AQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAAgAigCCBD1goCAACACQRBqJICAgIAADwtdAQN/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgggASgCCCECIAEgAjYCDAJAIAIoAgBBAEdBAXFFDQAgAigCABCGgICAAAsgASgCDCEDIAFBEGokgICAgAAgAw8LCQBB6LyGgAAPCxkBAX8jgICAgABBEGshASABIAA2AgxBAA8LFwEBfyOAgICAAEEQayEBIAEgADYCDA8LGQEBfyOAgICAAEEQayEBIAEgADYCDEEADws/AQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAAgAigCCBDRgoCAABogAkEQaiSAgICAAA8LTgECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIQMgAyACKAIIEIeAgIAAENGCgIAAGiACQRBqJICAgIAAIAMPCxkBAX8jgICAgABBEGshASABIAA2AgxBAg8LNAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMEP2CgIAAIQIgAUEQaiSAgICAACACDwuAAQEDfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIUIAIgATYCECACKAIUIQMgAiADEP6CgIAANgIMIAIoAhAhBCACIAJBDGo2AhwgAiAENgIYIAIoAhwgAigCGBD/goCAABCAg4CAACACKAIcEPOCgIAAIAJBIGokgICAgAAgAw8LOQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQgYOAgAAhAiABQRBqJICAgIAAIAIPCxcBAX8jgICAgABBEGshASABIAA5AwgPCw0AI4CAgIAAQRBrGg8LCQBBiL2GgAAPCxwBAX8jgICAgABBEGshASABIAA2AgwgASgCDA8LOQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIIIAEoAggQgoOAgAAhAiABQRBqJICAgIAAIAIPC0YBA38jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgghAyACKAIMKAIAIAM2AgAgAigCDCEEIAQgBCgCAEEIajYCAA8LHAEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMDwtOAQN/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDCECIAEgAhDSgoCAADYCCCACQQA2AgQgASgCCCEDIAFBEGokgICAgAAgAw8LXQEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCAJAAkAgAigCCEEAR0EBcUUNACAAIAIoAggQ9oKAgAAaDAELIAAQyIKAgAALIAJBEGokgICAgAAPC6UBAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAkEEakHtqYSAABDJgoCAACACQQBBAXE6AAMgACACQQRqEMqCgIAAIABB2KyFgAAgARCFg4CAACABQQRqIQMgAEGI64SAACADEIaDgIAAIAJBAUEBcToAAwJAIAItAANBAXENACAAEMyCgIAAGgsgAkEEahDMgoCAABogAkEQaiSAgICAAA8LrwEBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENKCgIAAIQUgAygCGCEGIANBDGogBCAGENSCgIAAIANBDGoQ0oKAgAAhByADKAIUIQggA0EEaiAEIAgQh4OAgAAgBSAHIANBBGoQ0oKAgAAQgoCAgAAgA0EEahDMgoCAABogA0EMahDMgoCAABogA0EgaiSAgICAAA8LrwEBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENKCgIAAIQUgAygCGCEGIANBDGogBCAGEIiDgIAAIANBDGoQ0oKAgAAhByADKAIUIQggA0EEaiAEIAgQh4OAgAAgBSAHIANBBGoQ0oKAgAAQgoCAgAAgA0EEahDMgoCAABogA0EMahDMgoCAABogA0EgaiSAgICAAA8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACADKAIEEJuDgIAAGiADQRBqJICAgIAADwtGAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCAAIAMoAgQQ9oKAgAAaIANBEGokgICAgAAPC5ICAQF/I4CAgIAAQcAAayECIAIkgICAgAAgAiAANgI8IAJBNGpB7amEgAAQyYKAgAAgAkEAQQFxOgAzIAAgAkE0ahDKgoCAACACIAEpAgA3AyAgAkEoahogAiACKQIgNwMAIAJBKGogAhCEg4CAACAAQbmPhIAAIAJBKGoQ0IKAgAAgAkEoahDMgoCAABogAiABQQhqKQIANwMQIAJBGGoaIAIgAikCEDcDCCACQRhqIAJBCGoQhIOAgAAgAEHQwYWAACACQRhqEIqDgIAAIAJBGGoQzIKAgAAaIAJBAUEBcToAMwJAIAItADNBAXENACAAEMyCgIAAGgsgAkE0ahDMgoCAABogAkHAAGokgICAgAAPC5EBAQR/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIcIQQgBBDSgoCAACEFIAMoAhghBiADQQxqIAQgBhCLg4CAACAFIANBDGoQ0oKAgAAgBCADKAIUENWCgIAAENKCgIAAEIKAgIAAIANBDGoQzIKAgAAaIANBIGokgICAgAAPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBD2goCAABogA0EQaiSAgICAAA8LpQEBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACQQRqQZqGhIAAEMmCgIAAIAJBAEEBcToAAyAAIAJBBGoQyoKAgAAgAEHahIWAACABEI2DgIAAIAFBBGohAyAAQdqEhYAAIAMQjYOAgAAgAkEBQQFxOgADAkAgAi0AA0EBcQ0AIAAQzIKAgAAaCyACQQRqEMyCgIAAGiACQRBqJICAgIAADwtTAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADKAIMENKCgIAAIAMoAgggAygCBBCOg4CAACADQRBqJICAgIAADwueAgELfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIsIAMgATYCKCADIAI2AiRBAC0AgKWJgABBAXEhBEEAIQUCQCAEQf8BcSAFQf8BcUZBAXFFDQBBnL2GgAAQpIOAgABBnL2GgAAQpYOAgABBARCEgICAACEGQQAgBjYC/KSJgABBASEHQQAgBzoAgKWJgAALIAMoAiQhCCADQRhqIAgQpoOAgAAaIANBADYCFEEAKAL8pImAACEJIAMoAiwhCiADKAIoIQsgA0EYahCng4CAACEMIAkgCiALIANBFGogDBCFgICAABD7goCAACADKAIUIQ0gA0EMaiANEO6CgIAAGhD8goCAACADQQxqEPCCgIAAGiADQTBqJICAgIAADwvGBAMFfwF+AX8jgICAgABBgAFrIQIgAiSAgICAACACIAA2AnwgAiABNgJ4AkACQCACKAJ4QQBHQQFxDQAgABDIgoCAAAwBCyACQfAAakHtqYSAABDJgoCAACACQQBBAXE6AG8gACACQfAAahDKgoCAAAJAAkAgAigCeCgCAEEAR0EBcUUNACACKAJ4KAIAIQMgAkHgAGogAxCQg4CAABogAEHVkIWAACACQeAAahCRg4CAACACQeAAahDzjICAABoMAQsgAkHYAGoQyIKAgAAgAEHVkIWAACACQdgAahDQgoCAACACQdgAahDMgoCAABoLIAIoAngoAhwQvYKAgAAhBCACQcwAaiAEEJCDgIAAGiAAQZ6qhYAAIAJBzABqEJKDgIAAIAJBzABqEPOMgIAAGiACIAIoAnhBBGopAgA3AzggAkHEAGoaIAIgAikCODcDCCACQcQAaiACQQhqEIyDgIAAIABBmriFgAAgAkHEAGoQ0IKAgAAgAkHEAGoQzIKAgAAaIAIoAnhBDGohBUEIIQYgBSAGaikCACEHIAYgAkEgamogBzcDACACIAUpAgA3AyAgAkEwahpBCCEIIAggAkEQamogCCACQSBqaikCADcDACACIAIpAiA3AxAgAkEwaiACQRBqEImDgIAAIABBheaEgAAgAkEwahDOgoCAACACQTBqEMyCgIAAGiACQQFBAXE6AG8CQCACLQBvQQFxDQAgABDMgoCAABoLIAJB8ABqEMyCgIAAGgsgAkGAAWokgICAgAAPC1sBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCEDIAMQlIOAgAAaIAMgAigCCCACKAIIEJWDgIAAEPWMgIAAIAJBEGokgICAgAAgAw8LrwEBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENKCgIAAIQUgAygCGCEGIANBDGogBCAGENqCgIAAIANBDGoQ0oKAgAAhByADKAIUIQggA0EEaiAEIAgQk4OAgAAgBSAHIANBBGoQ0oKAgAAQgoCAgAAgA0EEahDMgoCAABogA0EMahDMgoCAABogA0EgaiSAgICAAA8LrwEBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENKCgIAAIQUgAygCGCEGIANBDGogBCAGENSCgIAAIANBDGoQ0oKAgAAhByADKAIUIQggA0EEaiAEIAgQk4OAgAAgBSAHIANBBGoQ0oKAgAAQgoCAgAAgA0EEahDMgoCAABogA0EMahDMgoCAABogA0EgaiSAgICAAA8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACADKAIEEJiDgIAAGiADQRBqJICAgIAADws8AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDCECIAIQqYOAgAAaIAFBEGokgICAgAAgAg8LOQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQqoOAgAAhAiABQRBqJICAgIAAIAIPC4MEAQN/I4CAgIAAQdAAayEDIAMkgICAgAAgAyAANgJMIAMgATYCSCADIAI2AkQgA0E8akHtqYSAABDJgoCAACADQTRqQZqGhIAAEMmCgIAAIANBAEEBcToAMyAAIANBPGoQyoKAgAAgA0EoaiADQTRqEMqCgIAAIANBIGogA0E0ahDKgoCAACADQRhqIANBNGoQyoKAgAACQCADKAJIQQBHQQFxRQ0AIANBADYCFAJAA0AgAygCFCADKAJIENqAgIAASUEBcUUNASADIAMoAkggAygCFBDWgICAADYCEAJAIAMoAhBBAEdBAXFFDQAgAygCECEEIANBCGogBBCPg4CAACADQShqQdqEhYAAIANBCGoQ54KAgAAgA0EIahDMgoCAABoLIAMgAygCFEEBajYCFAwACwsLIABBoriEgAAgA0EoahCXg4CAACADKAJEIQUgAyAFEJiDgIAAGiAAQY26hYAAIAMQl4OAgAAgAxDMgoCAABogAEHVuoSAACADQRhqEM6CgIAAIABBzbKEgAAgA0EgahCXg4CAACADQQFBAXE6ADMgA0EYahDMgoCAABogA0EgahDMgoCAABogA0EoahDMgoCAABoCQCADLQAzQQFxDQAgABDMgoCAABoLIANBNGoQzIKAgAAaIANBPGoQzIKAgAAaIANB0ABqJICAgIAADwuRAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ0oKAgAAhBSADKAIYIQYgA0EMaiAEIAYQiIOAgAAgBSADQQxqENKCgIAAIAQgAygCFBDVgoCAABDSgoCAABCCgICAACADQQxqEMyCgIAAGiADQSBqJICAgIAADwtTAQR/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgwhAyACKAIIIQRBACEFIAMgBSAFIAQQmYOAgAAgAkEQaiSAgICAACADDwuxAgELfyOAgICAAEEwayEEIAQkgICAgAAgBCAANgIsIAQgATYCKCAEIAI2AiQgBCADNgIgQQAtAIiliYAAQQFxIQVBACEGAkAgBUH/AXEgBkH/AXFGQQFxRQ0AQai9hoAAEKuDgIAAQai9hoAAEKyDgIAAQQMQhICAgAAhB0EAIAc2AoSliYAAQQEhCEEAIAg6AIiliYAACyAEKAIgIQkgBEEYaiAJEK2DgIAAGiAEQQA2AhRBACgChKWJgAAhCiAEKAIoIQsgBCgCJCEMIARBGGoQroOAgAAhDSAEIAogCyAMIARBFGogDRCFgICAABDtgoCAADYCECAEKAIUIQ4gBEEMaiAOEO6CgIAAGiAAIAQoAhAQ74KAgAAgBEEMahDwgoCAABogBEEwaiSAgICAAA8L5wIBA38jgICAgABBwABrIQMgAySAgICAACADIAA2AjwgAyABNgI4IAMgAjYCNCADQSxqQe2phIAAEMmCgIAAIANBJGpBmoaEgAAQyYKAgAAgA0EAQQFxOgAjIAAgA0EsahDKgoCAACADKAI4IQQgA0EYaiAEEIyEgIAAIANBEGogA0EkahDKgoCAACADQQhqIANBJGoQyoKAgAAgAEHVkIWAACADQRhqENCCgIAAIAMoAjQhBSADIAUQmIOAgAAaIABBjbqFgAAgAxCXg4CAACADEMyCgIAAGiAAQdW6hIAAIANBCGoQzoKAgAAgAEHNsoSAACADQRBqEJeDgIAAIANBAUEBcToAIyADQQhqEMyCgIAAGiADQRBqEMyCgIAAGiADQRhqEMyCgIAAGgJAIAMtACNBAXENACAAEMyCgIAAGgsgA0EkahDMgoCAABogA0EsahDMgoCAABogA0HAAGokgICAgAAPC1MBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCEDIAIoAgghBEEAIQUgAyAFIAUgBBCcg4CAACACQRBqJICAgIAAIAMPC7ECAQt/I4CAgIAAQTBrIQQgBCSAgICAACAEIAA2AiwgBCABNgIoIAQgAjYCJCAEIAM2AiBBAC0A+KSJgABBAXEhBUEAIQYCQCAFQf8BcSAGQf8BcUZBAXFFDQBBkL2GgAAQnYOAgABBkL2GgAAQnoOAgABBAxCEgICAACEHQQAgBzYC9KSJgABBASEIQQAgCDoA+KSJgAALIAQoAiAhCSAEQRhqIAkQn4OAgAAaIARBADYCFEEAKAL0pImAACEKIAQoAighCyAEKAIkIQwgBEEYahCgg4CAACENIAQgCiALIAwgBEEUaiANEIWAgIAAEO2CgIAANgIQIAQoAhQhDiAEQQxqIA4Q7oKAgAAaIAAgBCgCEBDvgoCAACAEQQxqEPCCgIAAGiAEQTBqJICAgIAADwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBChg4CAACECIAFBEGokgICAgAAgAg8LgAEBA38jgICAgABBIGshAiACJICAgIAAIAIgADYCFCACIAE2AhAgAigCFCEDIAIgAxD+goCAADYCDCACKAIQIQQgAiACQQxqNgIcIAIgBDYCGCACKAIcIAIoAhgQooOAgAAQo4OAgAAgAigCHBDzgoCAACACQSBqJICAgIAAIAMPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEIGDgIAAIQIgAUEQaiSAgICAACACDwsJAEGUvYaAAA8LHwEBfyOAgICAAEEQayEBIAEgADYCCCABKAIIKAIADwtGAQN/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCCACKAIIIQMgAigCDCgCACADNgIAIAIoAgwhBCAEIAQoAgBBCGo2AgAPCxkBAX8jgICAgABBEGshASABIAA2AgxBAg8LNAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMEKiDgIAAIQIgAUEQaiSAgICAACACDwuAAQEDfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIUIAIgATYCECACKAIUIQMgAiADEP6CgIAANgIMIAIoAhAhBCACIAJBDGo2AhwgAiAENgIYIAIoAhwgAigCGBCig4CAABCjg4CAACACKAIcEPOCgIAAIAJBIGokgICAgAAgAw8LOQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQgYOAgAAhAiABQRBqJICAgIAAIAIPCwkAQaC9hoAADwscAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEOiLgIAAIQIgAUEQaiSAgICAACACDwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCvg4CAACECIAFBEGokgICAgAAgAg8LgAEBA38jgICAgABBIGshAiACJICAgIAAIAIgADYCFCACIAE2AhAgAigCFCEDIAIgAxD+goCAADYCDCACKAIQIQQgAiACQQxqNgIcIAIgBDYCGCACKAIcIAIoAhgQsIOAgAAQsYOAgAAgAigCHBDzgoCAACACQSBqJICAgIAAIAMPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEIGDgIAAIQIgAUEQaiSAgICAACACDwsJAEGsvYaAAA8LnwEBBn8jgICAgABBEGshASABJICAgIAAIAEgADYCCCABIAEoAggQsoOAgABBAHRBBGoQlIyAgAA2AgQgASgCCBCyg4CAACECIAEoAgQgAjYCACABKAIEQQRqIQMgASgCCBCzg4CAACEEIAEoAggQsoOAgABBAHQhBQJAIAVFDQAgAyAEIAX8CgAACyABKAIEIQYgAUEQaiSAgICAACAGDwtGAQN/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCCACKAIIIQMgAigCDCgCACADNgIAIAIoAgwhBCAEIAQoAgBBCGo2AgAPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMELSDgIAAIQIgAUEQaiSAgICAACACDws/AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBC1g4CAABC2g4CAACECIAFBEGokgICAgAAgAg8LYQEEfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwhAgJAAkAgAhC3g4CAAEEBcUUNACACELiDgIAAIQMMAQsgAhC5g4CAACEDCyADIQQgAUEQaiSAgICAACAEDwthAQR/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDCECAkACQCACELeDgIAAQQFxRQ0AIAIQuoOAgAAhAwwBCyACELuDgIAAIQMLIAMhBCABQRBqJICAgIAAIAQPCxwBAX8jgICAgABBEGshASABIAA2AgwgASgCDA8LOAEDfyOAgICAAEEQayEBIAEgADYCDCABKAIMLQALQQd2IQJBACEDIAJB/wFxIANB/wFxR0EBcQ8LHwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMKAIEDwsnAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwtAAtB/wBxQf8BcQ8LHwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMKAIADws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBC8g4CAACECIAFBEGokgICAgAAgAg8LHAEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMDwuOAQEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACIAIoAggQvoOAgAAQz4GAgAA2AgQgAkEAQQFxOgADIAAgAigCBCACKAIIEJaDgIAAIAJBBGoQ0YGAgAAgAkEBQQFxOgADAkAgAi0AA0EBcQ0AIAAQzIKAgAAaCyACQRBqJICAgIAADws5AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBCzg4CAACECIAFBEGokgICAgAAgAg8LhAQBCn8jgICAgABBwABrIQMgAySAgICAACADIAA2AjwgAyABNgI4IAMgAjYCNCADQQA2AjAgA0EAOgAvIAIQwIOAgAAhBCADQQBBAXE6ABcgA0EAQQFxOgAWQQAhBSAEQQFxIQYgBSEHAkAgBg0AIAIQwYOAgAAhCEEAIQkgCEEBcSEKIAkhByAKDQAgA0EYaiACEMKDgIAAIANBAUEBcToAFyADQSBqIANBGGoQw4OAgAAgA0EBQQFxOgAWIANBIGpB5qmEgAAQxIOAgAAhBwsgByELAkAgAy0AFkEBcUUNACADQSBqEPOMgIAAGgsCQCADLQAXQQFxRQ0AIANBGGoQzIKAgAAaCwJAIAtBAXFFDQACQCACQaa8hYAAEMWDgIAAQQFxRQ0AIANBDGogAkGmvIWAABDGg4CAACADQQxqEMeDgIAAIQwgA0EMahDMgoCAABogAyAMQQFxOgAVAkAgAy0AFUEBcUUNACADQQE6AC8gAyADQS9qNgIwCwsLIAMgAygCOBC+g4CAACADKAIwENCBgIAANgIIIAMoAgggAygCOBC+g4CAABDEgICAACADQQBBAXE6AAcgACADKAIIIAMoAjgQmoOAgAAgAygCCBD/gICAACADQQFBAXE6AAcCQCADLQAHQQFxDQAgABDMgoCAABoLIANBwABqJICAgIAADws/AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDBDSgoCAAEECRkEBcSECIAFBEGokgICAgAAgAg8LPwECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQ0oKAgABBBEZBAXEhAiABQRBqJICAgIAAIAIPC0sBAX8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggACACKAIIENKCgIAAEIiAgIAAENGCgIAAGiACQRBqJICAgIAADwtMAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgghAyAAIAMQ0oKAgABBACADEMiDgIAAIAJBEGokgICAgAAPC6YBAQV/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABNgIEIAIgAigCBBCVg4CAADYCAAJAAkAgAigCACACKAIIELSDgIAAR0EBcUUNACACQQBBAXE6AA8MAQsgAigCCCEDIAIoAgQhBCACKAIAIQUgAiADQQBBfyAEIAUQ+oyAgABBAEZBAXE6AA8LIAItAA9BAXEhBiACQRBqJICAgIAAIAYPC90BAQV/I4CAgIAAQTBrIQIgAiSAgICAACACIAA2AiwgAiABNgIoIAIoAiwhAyACQRBqQe2phIAAEMmCgIAAIAJBGGogAkEQakHwqYWAABDJg4CAACACQSBqIAJBGGpBgoCEgAAQyoOAgAAgAigCKCEEIAJBCGogBBD2goCAABogAkEgakHt9YSAACADIAJBCGoQy4OAgAAhBSACQQhqEMyCgIAAGiACQSBqEMyCgIAAGiACQRhqEMyCgIAAGiACQRBqEMyCgIAAGiAFQQFxIQYgAkEwaiSAgICAACAGDwuHAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCGCEEIAQQ0oKAgAAhBSADKAIUIQYgA0EMaiAEIAYQzIOAgAAgACAFIANBDGoQ0oKAgAAQiYCAgAAQ0YKAgAAaIANBDGoQzIKAgAAaIANBIGokgICAgAAPC0oBA38jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMIQIgAhDSgoCAAEEAIAIQzYOAgABBAXEhAyABQRBqJICAgIAAIAMPC7ECAQt/I4CAgIAAQTBrIQQgBCSAgICAACAEIAA2AiwgBCABNgIoIAQgAjYCJCAEIAM2AiBBAC0AoKWJgABBAXEhBUEAIQYCQCAFQf8BcSAGQf8BcUZBAXFFDQBBs76GgAAQ+4OAgABBs76GgAAQ/IOAgABBAxCEgICAACEHQQAgBzYCnKWJgABBASEIQQAgCDoAoKWJgAALIAQoAiAhCSAEQRhqIAkQ/YOAgAAaIARBADYCFEEAKAKcpYmAACEKIAQoAighCyAEKAIkIQwgBEEYahD+g4CAACENIAQgCiALIAwgBEEUaiANEIWAgIAAEP+DgIAANgIQIAQoAhQhDiAEQQxqIA4Q7oKAgAAaIAAgBCgCEBD2g4CAACAEQQxqEPCCgIAAGiAEQTBqJICAgIAADwuHAQEEfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCGCEEIAQQ0oKAgAAhBSADKAIUIQYgA0EMaiAEIAYQ14OAgAAgACAFIANBDGoQ0oKAgAAQiYCAgAAQ0YKAgAAaIANBDGoQzIKAgAAaIANBIGokgICAgAAPC4cBAQR/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIYIQQgBBDSgoCAACEFIAMoAhQhBiADQQxqIAQgBhDYg4CAACAAIAUgA0EMahDSgoCAABCJgICAABDRgoCAABogA0EMahDMgoCAABogA0EgaiSAgICAAA8LZgECfyOAgICAAEEQayEEIAQkgICAgAAgBCAANgIMIAQgATYCCCAEIAI2AgQgBCADNgIAIAQoAgwQ0oKAgAAgBCgCCCAEKAIEIAQoAgAQ2YOAgABBAXEhBSAEQRBqJICAgIAAIAUPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBD2goCAABogA0EQaiSAgICAAA8LuQIBDX8jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACNgIkQQAtAKiliYAAQQFxIQRBACEFAkAgBEH/AXEgBUH/AXFGQQFxRQ0AQby+hoAAEIGEgIAAQby+hoAAEIKEgIAAQQMQhICAgAAhBkEAIAY2AqSliYAAQQEhB0EAIAc6AKiliYAACyADKAIkIQggA0EYaiAIEP2DgIAAGiADQQA2AhRBACgCpKWJgAAhCSADKAIsIQogAygCKCELIANBGGoQ/oOAgAAhDCADIAkgCiALIANBFGogDBCFgICAABDeg4CAAEEBcToAEyADKAIUIQ0gA0EMaiANEO6CgIAAGiADLQATQQFxEN+DgIAAIQ4gA0EMahDwgoCAABogDkEBcSEPIANBMGokgICAgAAgDw8LnAEBAX8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhggAkEMahCfgYCAABogAigCGBC+g4CAACACQQxqEMyBgIAAIAJBAEEBcToACyAAIAJBDGoQoYGAgAAQkIOAgAAaIAJBDGoQq4GAgAAgAkEBQQFxOgALAkAgAi0AC0EBcQ0AIAAQ84yAgAAaCyACQSBqJICAgIAADwucAQEBfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGCACQQxqEJ+BgIAAGiACKAIYEL6DgIAAIAJBDGoQzYGAgAAgAkEAQQFxOgALIAAgAkEMahChgYCAABCQg4CAABogAkEMahCrgYCAACACQQFBAXE6AAsCQCACLQALQQFxDQAgABDzjICAABoLIAJBIGokgICAgAAPC4ACAQN/I4CAgIAAQcAAayEBIAEkgICAgAAgASAANgI8IAEQ0oGAgAA2AjggARDTgYCAADYCNCABQQBBAXE6ADMgAUGyj4aAABCQg4CAABogASgCNCECIAFBDGogASACENGDgIAAIAFBGGogAUEMakG8j4aAABDRg4CAACABKAI4IQMgAUEkaiABQRhqIAMQ0YOAgAAgACABQSRqQb6mhoAAENGDgIAAIAFBJGoQ84yAgAAaIAFBGGoQ84yAgAAaIAFBDGoQ84yAgAAaIAEQ84yAgAAaIAFBAUEBcToAMwJAIAEtADNBAXENACAAEPOMgIAAGgsgAUHAAGokgICAgAAPC1EBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCCCADKAIEEPyMgIAAENKDgIAAGiADQRBqJICAgIAADwvfAQEIfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIYIAIgATYCFCACKAIYIQMgAiADNgIcIAIoAhQhBCACQRNqIAQQhISAgAAhBSADIAUpAgA3AgBBCCEGIAMgBmogBSAGaigCADYCACACQQhqQQA2AgAgAkIANwMAIAIoAhQhByAHIAIpAgA3AgBBCCEIIAcgCGogAiAIaigCADYCACACKAIUQQAQhYSAgAACQCADELeDgIAAQQFxDQAgAyADELSDgIAAEIWEgIAACyACKAIcIQkgAkEgaiSAgICAACAJDwsQAEGMpYmAABDUg4CAABoPC0IBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMIQIgAkGNgICAABDWg4CAABogAUEQaiSAgICAACACDwtdAEGCiISAAEGOgICAABDkg4CAAEG/poWAAEGPgICAABDlg4CAAEGNhYSAAEGQgICAABDmg4CAAEGY9oWAAEGRgICAABDmg4CAAEHr6oSAAEGSgICAABDng4CAAA8LYwECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIQMgAyACKAIINgIAIANBADYCBCACKAIIEYGAgIAAgICAgAAgAxC1i4CAACACQRBqJICAgIAAIAMPC0YBAX8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAAgAygCBBD2goCAABogA0EQaiSAgICAAA8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACAD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74KAgAAgA0EcaiADQRBqIANBCGogBBGDgICAAICAgIAAIANBHGoQ/4KAgAAhByADQRxqEMyCgIAAGiADQQhqEMyCgIAAGiADQRBqEPOMgIAAGiADQTBqJICAgIAAIAcPCxkBAX8jgICAgABBEGshASABIAA2AgxBAw8LNAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMEPiDgIAAIQIgAUEQaiSAgICAACACDwsdAQF/I4CAgIAAQRBrIQEgASAANgIMQZi+hoAADwuKAQEEfyOAgICAAEEwayECIAIkgICAgAAgAiAANgIsIAIgATYCKCACKAIsIQMgAigCKCEEIAJBEGogBBD2g4CAACACQRxqIAJBEGogAxGCgICAAICAgIAAIAJBHGoQsIOAgAAhBSACQRxqEPOMgIAAGiACQRBqEPOMgIAAGiACQTBqJICAgIAAIAUPCxkBAX8jgICAgABBEGshASABIAA2AgxBAg8LNAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMEPmDgIAAIQIgAUEQaiSAgICAACACDwsdAQF/I4CAgIAAQRBrIQEgASAANgIMQai+hoAADwteAQN/I4CAgIAAQSBrIQEgASSAgICAACABIAA2AhwgASgCHCECIAFBEGogAhGEgICAAICAgIAAIAFBEGoQsIOAgAAhAyABQRBqEPOMgIAAGiABQSBqJICAgIAAIAMPCxkBAX8jgICAgABBEGshASABIAA2AgxBAQ8LNAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMEPqDgIAAIQIgAUEQaiSAgICAACACDwsdAQF/I4CAgIAAQRBrIQEgASAANgIMQbC+hoAADwtKAQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAAgAigCCEEEaiACKAIIKAIAEPeDgIAAGiACQRBqJICAgIAADwtcAQJ/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADKAIMIQQgBBCUg4CAABogBCADKAIIIAMoAgQQ9YyAgAAgA0EQaiSAgICAACAEDwsJAEGMvoaAAA8LCQBBoL6GgAAPCwkAQay+hoAADwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBCAhICAACECIAFBEGokgICAgAAgAg8LgAEBA38jgICAgABBIGshAiACJICAgIAAIAIgADYCFCACIAE2AhAgAigCFCEDIAIgAxD+goCAADYCDCACKAIQIQQgAiACQQxqNgIcIAIgBDYCGCACKAIcIAIoAhgQ4oOAgAAQgIOAgAAgAigCHBDzgoCAACACQSBqJICAgIAAIAMPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEIGDgIAAIQIgAUEQaiSAgICAACACDwseAQF/I4CAgIAAQRBrIQEgASAAOQMIIAErAwj8Aw8LCQBBtL6GgAAPCxkBAX8jgICAgABBEGshASABIAA2AgxBAg8LNAECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMEIOEgIAAIQIgAUEQaiSAgICAACACDwsJAEHAvoaAAA8LWAECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCAJAIAIoAggQt4OAgABBAXENACACKAIIEIaEgIAACyACKAIIIQMgAkEQaiSAgICAACADDwseAQF/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCA8LFwEBfyOAgICAAEEQayEBIAEgADYCDA8LCQAQ04OAgAAPC60DAwR/AX4DfyOAgICAAEHQAGshAiACJICAgIAAIAIgADYCTCACIAE2AkgCQAJAIAIoAkhBAEdBAXENACAAEMiCgIAADAELIAJBAEEBcToARyAAEImEgIAAIAIoAkgQ/YCAgAAhAyACQTxqIAMQg4OAgAAgAEGeqoWAACACQTxqEMuCgIAAIAJBPGoQzIKAgAAaIAIoAkhBBGohBEEIIQUgBCAFaikCACEGIAUgAkEgamogBjcDACACIAQpAgA3AyAgAkE0ahpBCCEHIAIgB2ogByACQSBqaikCADcDACACIAIpAiA3AwAgAkE0aiACEImDgIAAIABBheaEgAAgAkE0ahDOgoCAACACQTRqEMyCgIAAGiACKAJIKAIUIQggAkEYaiAIEOWCgIAAIABBzbKEgAAgAkEYahCXg4CAACACQRhqEMyCgIAAGiACKAJIKAIYIQkgAkEQaiAJEIqEgIAAIABB9uyEgAAgAkEQahDOgoCAACACQRBqEMyCgIAAGiACQQFBAXE6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gIAAIQMgAkHcAGogAxCDg4CAACAAQZ6qhYAAIAJB3ABqEMuCgIAAIAJB3ABqEMyCgIAAGiACKAJoQQRqIQRBCCEFIAQgBWopAgAhBiAFIAJBwABqaiAGNwMAIAIgBCkCADcDQCACQdQAahpBCCEHIAIgB2ogByACQcAAamopAgA3AwAgAiACKQJANwMAIAJB1ABqIAIQiYOAgAAgAEGF5oSAACACQdQAahDOgoCAACACQdQAahDMgoCAABogAigCaCgCFCEIIAJBOGogCBDlgoCAACAAQc2yhIAAIAJBOGoQl4OAgAAgAkE4ahDMgoCAABogAigCaCgCGCEJIAJBMGogCRCPg4CAACAAQc6JhYAAIAJBMGoQz4KAgAAgAkEwahDMgoCAABogAigCaCgCHCEKIAJBKGogChCPg4CAACAAQfOshYAAIAJBKGoQzoKAgAAgAkEoahDMgoCAABogAigCaCgCICELIAJBIGogCxCPg4CAACAAQayHhYAAIAJBIGoQz4KAgAAgAkEgahDMgoCAABogAigCaCgCJCEMIAJBGGogDBCKhICAACAAQfbshIAAIAJBGGoQzoKAgAAgAkEYahDMgoCAABogAigCaC0AKCENIAJBAUEAIA1BAXEbQQFxOgAXIABB38KFgAAgAkEXahCQhICAACACQQFBAXE6AGcCQCACLQBnQQFxDQAgABDMgoCAABoLCyACQfAAaiSAgICAAA8LrwEBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENKCgIAAIQUgAygCGCEGIANBDGogBCAGENeCgIAAIANBDGoQ0oKAgAAhByADKAIUIQggA0EEaiAEIAgQkYSAgAAgBSAHIANBBGoQ0oKAgAAQgoCAgAAgA0EEahDMgoCAABogA0EMahDMgoCAABogA0EgaiSAgICAAA8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACADKAIEELSEgIAAGiADQRBqJICAgIAADwveBAMEfwF+Bn8jgICAgABB8ABrIQIgAiSAgICAACACIAA2AmwgAiABNgJoAkACQCACKAJoQQBHQQFxDQAgABDIgoCAAAwBCyACQQBBAXE6AGcgABCJhICAACACKAJoEP2AgIAA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AkEwamopAgA3AwAgAiACKQIwNwMAIAJBxABqIAIQiYOAgAAgAEGF5oSAACACQcQAahDOgoCAACACQcQAahDMgoCAABogAigCWCgCFCEIIAJBKGogCBDlgoCAACAAQc2yhIAAIAJBKGoQl4OAgAAgAkEoahDMgoCAABogAigCWCgCGCEJIAJBIGogCRCPg4CAACAAQfmOhIAAIAJBIGoQ3IKAgAAgAkEgahDMgoCAABogAigCWCgCHCEKIAJBGGogChCKhICAACAAQfbshIAAIAJBGGoQzoKAgAAgAkEYahDMgoCAABogAigCWCgCICELIAJBEGogCxCPg4CAACAAQYbAhYAAIAJBEGoQz4KAgAAgAkEQahDMgoCAABogAkEBQQFxOgBXAkAgAi0AV0EBcQ0AIAAQzIKAgAAaCwsgAkHgAGokgICAgAAPC6AEAwR/AX4FfyOAgICAAEHgAGshAiACJICAgIAAIAIgADYCXCACIAE2AlgCQAJAIAIoAlhBAEdBAXENACAAEMiCgIAADAELIAJBAEEBcToAVyAAEImEgIAAIAIoAlgQ/YCAgAAhAyACQcwAaiADEIODgIAAIABBnqqFgAAgAkHMAGoQy4KAgAAgAkHMAGoQzIKAgAAaIAIoAlhBBGohBEEIIQUgBCAFaikCACEGIAUgAkEwamogBjcDACACIAQpAgA3AzAgAkHEAGoaQQghByACIAdqIAcgAkEwamopAgA3AwAgAiACKQIwNwMAIAJBxABqIAIQiYOAgAAgAEGF5oSAACACQcQAahDOgoCAACACQcQAahDMgoCAABogAigCWCgCFCEIIAJBKGogCBDlgoCAACAAQc2yhIAAIAJBKGoQl4OAgAAgAkEoahDMgoCAABogAigCWCgCGCEJIAJBIGogCRCPg4CAACAAQc6JhYAAIAJBIGoQz4KAgAAgAkEgahDMgoCAABogAigCWCgCHCEKIAJBGGogChCKhICAACAAQfbshIAAIAJBGGoQzoKAgAAgAkEYahDMgoCAABogAigCWCgCICELIAJBEGogCxCPg4CAACAAQayHhYAAIAJBEGoQz4KAgAAgAkEQahDMgoCAABogAkEBQQFxOgBXAkAgAi0AV0EBcQ0AIAAQzIKAgAAaCwsgAkHgAGokgICAgAAPC6AEAwR/AX4FfyOAgICAAEHgAGshAiACJICAgIAAIAIgADYCXCACIAE2AlgCQAJAIAIoAlhBAEdBAXENACAAEMiCgIAADAELIAJBAEEBcToAVyAAEImEgIAAIAIoAlgQ/YCAgAAhAyACQcwAaiADEIODgIAAIABBnqqFgAAgAkHMAGoQy4KAgAAgAkHMAGoQzIKAgAAaIAIoAlhBBGohBEEIIQUgBCAFaikCACEGIAUgAkEwamogBjcDACACIAQpAgA3AzAgAkHEAGoaQQghByACIAdqIAcgAkEwamopAgA3AwAgAiACKQIwNwMAIAJBxABqIAIQiYOAgAAgAEGF5oSAACACQcQAahDOgoCAACACQcQAahDMgoCAABogAigCWCgCFCEIIAJBKGogCBDlgoCAACAAQc2yhIAAIAJBKGoQl4OAgAAgAkEoahDMgoCAABogAigCWCgCGCEJIAJBIGogCRCPg4CAACAAQc6JhYAAIAJBIGoQz4KAgAAgAkEgahDMgoCAABogAigCWCgCHCEKIAJBGGogChCKhICAACAAQfbshIAAIAJBGGoQzoKAgAAgAkEYahDMgoCAABogAigCWCgCICELIAJBEGogCxCPg4CAACAAQayHhYAAIAJBEGoQz4KAgAAgAkEQahDMgoCAABogAkEBQQFxOgBXAkAgAi0AV0EBcQ0AIAAQzIKAgAAaCwsgAkHgAGokgICAgAAPC6AEAwR/AX4FfyOAgICAAEHgAGshAiACJICAgIAAIAIgADYCXCACIAE2AlgCQAJAIAIoAlhBAEdBAXENACAAEMiCgIAADAELIAJBAEEBcToAVyAAEImEgIAAIAIoAlgQ/YCAgAAhAyACQcwAaiADEIODgIAAIABBnqqFgAAgAkHMAGoQy4KAgAAgAkHMAGoQzIKAgAAaIAIoAlhBBGohBEEIIQUgBCAFaikCACEGIAUgAkEwamogBjcDACACIAQpAgA3AzAgAkHEAGoaQQghByACIAdqIAcgAkEwamopAgA3AwAgAiACKQIwNwMAIAJBxABqIAIQiYOAgAAgAEGF5oSAACACQcQAahDOgoCAACACQcQAahDMgoCAABogAigCWCgCFCEIIAJBKGogCBDlgoCAACAAQc2yhIAAIAJBKGoQl4OAgAAgAkEoahDMgoCAABogAigCWCgCGCEJIAJBIGogCRCPg4CAACAAQc6JhYAAIAJBIGoQz4KA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5oSAACACQeQAahDOgoCAACACQeQAahDMgoCAABogAigCeCgCFCEIIAJByABqIAgQ5YKAgAAgAEHNsoSAACACQcgAahCXg4CAACACQcgAahDMgoCAABogAigCeCgCGCEJIAJBwABqIAkQj4OAgAAgAEHOiYWAACACQcAAahDPgoCAACACQcAAahDMgoCAABogAigCeCgCHCEKIAJBOGogChCPg4CAACAAQc6QhIAAIAJBOGoQzYKAgAAgAkE4ahDMgoCAABogAigCeCgCICELIAJBMGogCxCPg4CAACAAQayHhYAAIAJBMGoQz4KAgAAgAkEwahDMgoCAABogAigCeCgCJCEMIAJBKGogDBCKhICAACAAQYGthIAAIAJBKGoQr4SAgAAgAkEoahDMgoCAABogAigCeCgCKCENIAJBIGogDRCMhICAACAAQaaQhIAAIAJBIGoQr4SAgAAgAkEgahDMgoCAABogAigCeCgCLCEOIAJBGGogDhCMhICAACAAQfK4hYAAIAJBGGoQzoKAgAAgAkEYahDMgoCAABogAkEBQQFxOgB3AkAgAi0Ad0EBcQ0AIAAQzIKAgAAaCwsgAkGAAWokgICAgAAPC44FAwR/AX4HfyOAgICAAEHwAGshAiACJICAgIAAIAIgADYCbCACIAE2AmgCQAJAIAIoAmhBAEdBAXENACAAEMiCgIAADAELIAJBAEEBcToAZyAAEImEgIAAIAIoAmgQ/YCAgAAhAyACQdwAaiADEIODgIAAIABBnqqFgAAgAkHcAGoQy4KAgAAgAkHcAGoQzIKAgAAaIAIoAmhBBGohBEEIIQUgBCAFaikCACEGIAUgAkHAAGpqIAY3AwAgAiAEKQIANwNAIAJB1ABqGkEIIQcgAiAHaiAHIAJBwABqaikCADcDACACIAIpAkA3AwAgAkHUAGogAhCJg4CAACAAQYXmhIAAIAJB1ABqEM6CgIAAIAJB1ABqEMyCgIAAGiACKAJoKAIUIQggAkE4aiAIEOWCgIAAIABBzbKEgAAgAkE4ahCXg4CAACACQThqEMyCgIAAGiACKAJoKAIYIQkgAkEwaiAJEI+DgIAAIABBzomFgAAgAkEwahDPgoCAACACQTBqEMyCgIAAGiACKAJoKAIcIQogAkEoaiAKEI+DgIAAIABBzpCEgAAgAkEoahDNgoCAACACQShq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KGogChCPg4CAACAAQc6QhIAAIAJBKGoQzYKAgAAgAkEoahDMgoCAABogAigCaCgCICELIAJBIGogCxCPg4CAACAAQayHhYAAIAJBIGoQz4KAgAAgAkEgahDMgoCAABogAigCaCgCJCEMIAJBGGogDBCKhICAACAAQYGthIAAIAJBGGoQr4SAgAAgAkEYahDMgoCAABogAkEBQQFxOgBnAkAgAi0AZ0EBcQ0AIAAQzIKAgAAaCwsgAkHwAGokgICAgAAPC9MGAwR/AX4KfyOAgICAAEGQAWshAiACJICAgIAAIAIgADYCjAEgAiABNgKIAQJAAkAgAigCiAFBAEdBAXENACAAEMiCgIAADAELIAJBAEEBcToAhwEgABCJhICAACACKAKIARD9gICAACEDIAJB/ABqIAMQg4OAgAAgAEGeqoWAACACQfwAahDLgoCAACACQfwAahDMgoCAABogAigCiAFBBGohBEEIIQUgBCAFaikCACEGIAUgAkHgAGpqIAY3AwAgAiAEKQIANwNgIAJB9ABqGkEIIQcgByACQQhqaiAHIAJB4ABqaikCADcDACACIAIpAmA3AwggAkH0AGogAkEIahCJg4CAACAAQYXmhIAAIAJB9ABqEM6CgIAAIAJB9ABqEMyCgIAAGiACKAKIASgCFCEIIAJB2ABqIAgQ5YKAgAAgAEHNsoSAACACQdgAahCXg4CAACACQdgAahDMgoCAABogAigCiAEoAhghCSACQdAAaiAJEI+DgIAAIABBzomFgAAgAkHQAGoQz4KAgAAgAkHQAGoQzIKAgAAaIAIoAogBKAIcIQogAkHIAGogChCPg4CAACAAQc6QhIAAIAJByABqEM2CgIAAIAJByABqEMyCgIAAGiACKAKIASgCICELIAJBwABqIAsQj4OAgAAgAEGsh4WAACACQcAAahDPgoCAACACQcAAahDMgoCAABogAigCiAEoAiQhDCACQThqIAwQioSAgAAgAEGBrYSAACACQThqEK+EgIAAIAJBOGoQzIKAgAAaIAIoAogBKAIoIQ0gAkEwaiANEIyEgIAAIABBnqOFgAAgAkEwahDcgoCAACACQTBqEMyCgIAAGiACKAKIASgCLCEOIAJBKGogDhCMhICAACAAQayjhYAAIAJBKGoQz4KAgAAgAkEoahDMgoCAABogAigCiAEoAjAhDyACQSBqIA8QjISAgAAgAEG4o4WAACACQSBqENyCgIAAIAJBIGoQzIKAgAAaIAIoAogBKAI0IRAgAkEYaiAQEIyEgIAAIABB8riFgAAgAkEYahDOgoCAACACQRhqEMyCgIAAGiACQQFBAXE6AIcBAkAgAi0AhwFBAXENACAAEMyCgIAAGgsLIAJBkAFqJICAgIAADwvQBQMEfwF+CH8jgICAgABBgAFrIQIgAiSAgICAACACIAA2AnwgAiABNgJ4AkACQCACKAJ4QQBHQQFxDQAgABDIgoCAAAwBCyACQQBBAXE6AHcgABCJhICAACACKAJ4EP2AgIAAIQMgAkHsAGogAxCDg4CAACAAQZ6qhYAAIAJB7ABqEMuCgIAAIAJB7ABqEMyCgIAAGiACKAJ4QQRqIQRBCCEFIAQgBWopAgAhBiAFIAJB0ABqaiAGNwMAIAIgBCkCADcDUCACQeQAahpBCCEHIAcgAkEIamogByACQdAAamopAgA3AwAgAiACKQJQNwMIIAJB5ABqIAJBCGoQiYOAgAAgAEGF5oSAACACQeQAahDOgoCAACACQeQAahDMgoCAABogAigCeCgCFCEIIAJByABqIAgQ5YKAgAAgAEHNsoSAACACQcgAahCXg4CAACACQcgAahDMgoCAABogAigCeCgCGCEJIAJBwABqIAkQj4OAgAAgAEHOiYWAACACQcAAahDPgoCAACACQcAAahDMgoCAABogAigCeCgCHCEKIAJBOGogChCPg4CAACAAQc6QhIAAIAJBOGoQzYKAgAAgAkE4ahDMgoCAABogAigCeCgCICELIAJBMGogCxCPg4CAACAAQayHhYAAIAJBMGoQz4KAgAAgAkEwahDMgoCAABogAigCeCgCJCEMIAJBKGogDBCKhICAACAAQYGthIAAIAJBKGoQr4SAgAAgAkEoahDMgoCAABogAigCeCgCKCENIAJBIGogDRCMhICAACAAQayjhYAAIAJBIGoQz4KAgAAgAkEgahDMgoCAABogAigCeCgCLCEOIAJBGGogDhCMhICAACAAQfK4hYAAIAJBGGoQzoKAgAAgAkEYahDMgoCAABogAkEBQQFxOgB3AkAgAi0Ad0EBcQ0AIAAQzIKAgAAaCwsgAkGAAWokgICAgAAPC6AEAwR/AX4FfyOAgICAAEHgAGshAiACJICAgIAAIAIgADYCXCACIAE2AlgCQAJAIAIoAlhBAEdBAXENACAAEMiCgIAADAELIAJBAEEBcToAVyAAEImEgIAAIAIoAlgQ/YCAgAAhAyACQcwAaiADEIODgIAAIABBnqqFgAAgAkHMAGoQy4KAgAAgAkHMAGoQzIKAgAAaIAIoAlhBBGohBEEIIQUgBCAFaikCACEGIAUgAkEwamogBjcDACACIAQpAgA3AzAgAkHEAGoaQQghByACIAdqIAcgAkEwamopAgA3AwAgAiACKQIwNwMAIAJBxABqIAIQiYOAgAAgAEGF5oSAACACQcQAahDOgoCAACACQcQAahDMgoCAABogAigCWCgCFCEIIAJBKGogCBDlgoCAACAAQc2yhIAAIAJBKGoQl4OAgAAgAkEoahDMgoCAABogAigCWCgCGCEJIAJBIGogCRCPg4CAACAAQc6JhYAAIAJBIGoQz4KAgAAgAkEgahDMgoCAABogAigCWCgCHCEKIAJBGGogChCPg4CAACAAQc6QhIAAIAJBGGoQzYKAgAAgAkEYahDMgoCAABogAigCWCgCICELIAJBEGogCxCPg4CAACAAQayHhYAAIAJBEGoQz4KAgAAgAkEQahDMgoCAABogAkEBQQFxOgBXAkAgAi0AV0EBcQ0AIAAQzIKAgAAaCwsgAkHgAGokgICAgAAPC94EAwR/AX4GfyOAgICAAEHwAGshAiACJICAgIAAIAIgADYCbCACIAE2AmgCQAJAIAIoAmhBAEdBAXENACAAEMiCgIAADAELIAJBAEEBcToAZyAAEImEgIAAIAIoAmgQ/YCAgAAhAyACQdwAaiADEIODgIAAIABBnqqFgAAgAkHcAGoQy4KAgAAgAkHcAGoQzIKAgAAaIAIoAmhBBGohBEEIIQUgBCAFaikCACEGIAUgAkHAAGpqIAY3AwAgAiAEKQIANwNAIAJB1ABqGkEIIQcgByACQQhqaiAHIAJBwABqaikCADcDACACIAIpAkA3AwggAkHUAGogAkEIahCJg4CAACAAQYXmhIAAIAJB1ABqEM6CgIAAIAJB1ABqEMyCgIAAGiACKAJoKAIUIQggAkE4aiAIEOWCgIAAIABBzbKEgAAgAkE4ahCXg4CAACACQThqEMyCgIAAGiACKAJoKAIYIQkgAkEwaiAJEI+DgIAAIABBzomFgAAgAkEwahDPgoCAACACQTBqEMyCgIAAGiACKAJoKAIcIQogAkEoaiAKEI+DgIAAIABBzpCEgAAgAkEoahDNgoCAACACQShqEMyCgIAAGiACKAJoKAIgIQsgAkEgaiALEI+DgIAAIABBrIeFgAAgAkEgahDPgoCAACACQSBqEMyCgIAAGiACKAJoKAIkIQwgAkEYaiAMEIqEgIAAIABBga2EgAAgAkEYahCvhICAACACQRhqEMyCgIAAGiACQQFBAXE6AGcCQCACLQBnQQFxDQAgABDMgoCAABoLCyACQfAAaiSAgICAAA8LkQEBBH8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENKCgIAAIQUgAygCGCEGIANBDGogBCAGELGEgIAAIAUgA0EMahDSgoCAACAEIAMoAhQQ1YKAgAAQ0oKAgAAQgoCAgAAgA0EMahDMgoCAABogA0EgaiSAgICAAA8LrwEBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCAEENKCgIAAIQUgAygCGCEGIANBDGogBCAGEIiDgIAAIANBDGoQ0oKAgAAhByADKAIUIQggA0EEaiAEIAgQkYSAgAAgBSAHIANBBGoQ0oKAgAAQgoCAgAAgA0EEahDMgoCAABogA0EMahDMgoCAABogA0EgaiSAgICAAA8LRgEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgACADKAIEEPaCgIAAGiADQRBqJICAgIAADwuvAQEGfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCHCEEIAQQ0oKAgAAhBSADKAIYIQYgA0EMaiAEIAYQ2oKAgAAgA0EMahDSgoCAACEHIAMoAhQhCCADQQRqIAQgCBCRhICAACAFIAcgA0EEahDSgoCAABCCgICAACADQQRqEMyCgIAAGiADQQxqEMyCgIAAGiADQSBqJICAgIAADwtGAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCAAIAMoAgQQvYSAgAAaIANBEGokgICAgAAPC1MBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCEDIAIoAgghBEEAIQUgAyAFIAUgBBC1hICAACACQRBqJICAgIAAIAMPC7ECAQt/I4CAgIAAQTBrIQQgBCSAgICAACAEIAA2AiwgBCABNgIoIAQgAjYCJCAEIAM2AiBBAC0AsKWJgABBAXEhBUEAIQYCQCAFQf8BcSAGQf8BcUZBAXFFDQBByL6GgAAQtoSAgABByL6GgAAQt4SAgABBAxCEgICAACEHQQAgBzYCrKWJgABBASEIQQAgCDoAsKWJgAALIAQoAiAhCSAEQRhqIAkQuISAgAAaIARBADYCFEEAKAKspYmAACEKIAQoAighCyAEKAIkIQwgBEEYahC5hICAACENIAQgCiALIAwgBEEUaiANEIWAgIAAEO2CgIAANgIQIAQoAhQhDiAEQQxqIA4Q7oKAgAAaIAAgBCgCEBDvgoCAACAEQQxqEPCCgIAAGiAEQTBqJICAgIAADwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBC6hICAACECIAFBEGokgICAgAAgAg8LiQEBA38jgICAgABBIGshAiACJICAgIAAIAIgADYCFCACIAE2AhAgAigCFCEDIAIgAxD+goCAADYCDCACKAIQIQQgAiACQQxqNgIcIAIgBDYCGCACKAIcIAIoAhgtAABBAXEQu4SAgABBAXEQvISAgAAgAigCHBDzgoCAACACQSBqJICAgIAAIAMPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEIGDgIAAIQIgAUEQaiSAgICAACACDwsJAEHMvoaAAA8LHwEBfyOAgICAAEEQayEBIAEgADoADiABLQAOQQFxDwtJAQN/I4CAgIAAQRBrIQIgAiAANgIMIAIgAToACyACLQALQQFxIQMgAigCDCgCACADNgIAIAIoAgwhBCAEIAQoAgBBCGo2AgAPC1MBBH8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDCEDIAIoAgghBEEAIQUgAyAFIAUgBBC+hICAACACQRBqJICAgIAAIAMPC7ECAQt/I4CAgIAAQTBrIQQgBCSAgICAACAEIAA2AiwgBCABNgIoIAQgAjYCJCAEIAM2AiBBAC0AuKWJgABBAXEhBUEAIQYCQCAFQf8BcSAGQf8BcUZBAXFFDQBB1L6GgAAQv4SAgABB1L6GgAAQwISAgABBAxCEgICAACEHQQAgBzYCtKWJgABBASEIQQAgCDoAuKWJgAALIAQoAiAhCSAEQRhqIAkQwYSAgAAaIARBADYCFEEAKAK0pYmAACEKIAQoAighCyAEKAIkIQwgBEEYahDChICAACENIAQgCiALIAwgBEEUaiANEIWAgIAAEO2CgIAANgIQIAQoAhQhDiAEQQxqIA4Q7oKAgAAaIAAgBCgCEBDvgoCAACAEQQxqEPCCgIAAGiAEQTBqJICAgIAADwsZAQF/I4CAgIAAQRBrIQEgASAANgIMQQIPCzQBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDBDDhICAACECIAFBEGokgICAgAAgAg8LgAEBA38jgICAgABBIGshAiACJICAgIAAIAIgADYCFCACIAE2AhAgAigCFCEDIAIgAxD+goCAADYCDCACKAIQIQQgAiACQQxqNgIcIAIgBDYCGCACKAIcIAIoAhgQxISAgAAQxYSAgAAgAigCHBDzgoCAACACQSBqJICAgIAAIAMPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABKAIMEIGDgIAAIQIgAUEQaiSAgICAACACDwsJAEHYvoaAAA8LHwEBfyOAgICAAEEQayEBIAEgADYCCCABKAIIKAIADwtGAQN/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCCACKAIIIQMgAigCDCgCACADNgIAIAIoAgwhBCAEIAQoAgBBCGo2AgAPC74uAQN/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgggASgCCCECIAJBwAJLGgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg7BAgABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AYACgQKCAoMChAKFAoYChwKIAokCigKLAowCjQKOAo8CkAKRApICkwKUApUClgKXApgCmQKaApsCnAKdAp4CnwKgAqECogKjAqQCpQKmAqcCqAKpAqoCqwKsAq0CrgKvArAC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DAyQAQsgAUHr8ISAADYCDAyPAQsgAUGSoISAADYCDAyOAQsgAUGj8ISAADYCDAyNAQsgAUG8oISAADYCDAyMAQsgAUHZ8ISAADYCDAyLAQsgAUGUy4WAADYCDAyKAQsgAUGmi4WAADYCDAyJAQsgAUH0vYWAADYCDAyIAQsgAUGjrYWAADYCDAyHAQsgAUHD8oSAADYCDAyGAQsgAUGksISAADYCDAyFAQsgAUHsjYSAADYCDAyEAQsgAUGi24SAADYCDAyDAQsgAUHss4WAADYCDAyCAQsgAUGVw4SAADYCDAyBAQsgAUGf5oSAADYCDAyAAQsgAUGWqYWAADYCDAx/CyABQbj9hIAANgIMDH4LIAFBkqSEgAA2AgwMfQsgAUHZgYSAADYCDAx8CyABQYT9hIAANgIMDHsLIAFB5uuEgAA2AgwMegsgAUGDrISAADYCDAx5CyABQdf9hIAANgIMDHgLIAFB1oKFgAA2AgwMdwsgAUGhg4WAADYCDAx2CyABQcLYhIAANgIMDHULIAFBno2EgAA2AgwMdAsgAUGvrYWAADYCDAxzCyABQZ7HhYAANgIMDHILIAFByaKEgAA2AgwMcQsgAUHfiISAADYCDAxwCyABQbrFhYAANgIMDG8LIAFBsNWEgAA2AgwMbgsgAUHAgoWAADYCDAxtCyABQb/XhIAANgIMDGwLIAFB/7yFgAA2AgwMawsgAUH3iISAADYCDAxqCyABQanZhYAANgIMDGkLIAFB5quEgAA2AgwMaAsgAUG3oYWAADYCDAxnCyABQfSohIAANgIMDGYLIAFB8NiFgAA2AgwMZQsgAUG3qISAADYCDAxkCyABQcrrhIAANgIMDGMLIAFB7oKEgAA2AgwMYgsgAUHL7YSAADYCDAxhCyABQY/rhIAANgIMDGALIAFBo6qFgAA2AgwMXwsgAUG3t4WAADYCDAxeCyABQYCNhIAANgIMDF0LIAFBn9OEgAA2AgwMXAsgAUH8o4SAADYCDAxbCyABQYuDhIAANgIMDFoLIAFBnKGFgAA2AgwMWQsgAUH1xYWAADYCDAxYCyABQar3hIAANgIMDFcLIAFBtbmEgAA2AgwMVgsgAUGbqISAADYCDAxVCyABQY/ZhYAANgIMDFQLIAFBxI2EgAA2AgwMUwsgAUHMu4WAADYCDAxSCyABQZWphIAANgIMDFELIAFBlO6EgAA2AgwMUAsgAUGS7ISAADYCDAxPCyABQbaGhYAANgIMDE4LIAFB54qFgAA2AgwMTQsgAUHpt4WAADYCDAxMCyABQfbMhYAANgIMDEsLIAFBp8uEgAA2AgwMSgsgAUH98ISAADYCDAxJCyABQdO1hIAANgIMDEgLIAFBwdmEgAA2AgwMRwsgAUGu5oSAADYCDAxGCyABQaePhYAANgIMDEULIAFB5PGEgAA2AgwMRAsgAUGvtIWAADYCDAxDCyABQfbChYAANgIMDEILIAFBrL6FgAA2AgwMQQsgAUHyuISAADYCDAxACyABQbm+hIAANgIMDD8LIAFBvcCFgAA2AgwMPgsgAUGs64SAADYCDAw9CyABQauNhYAANgIMDDwLIAFBseWEgAA2AgwMOwsgAUH28oSAADYCDAw6CyABQdKMhYAANgIMDDkLIAFBn/GEgAA2AgwMOAsgAUGFw4WAADYCDAw3CyABQdbMhYAANgIMDDYLIAFBk8aFgAA2AgwMNQsgAUH834SAADYCDAw0CyABQbynhYAANgIMDDMLIAFBqI6FgAA2AgwMMgsgAUGiw4WAADYCDAwxCyABQeTLhIAANgIMDDALIAFBt5GEgAA2AgwMLwsgAUGdkYSAADYCDAwuCyABQe38hIAANgIMDC0LIAFBw72EgAA2AgwMLAsgAUHd94SAADYCDAwrCyABQYOShYAANgIMDCoLIAFBrsOEgAA2AgwMKQsgAUHq5YSAADYCDAwoCyABQauJhIAANgIMDCcLIAFB/qiFgAA2AgwMJgsgAUGU8YSAADYCDAwlCyABQdjmhIAANgIMDCQLIAFBz/KEgAA2AgwMIwsgAUHNvYWAADYCDAwiCyABQdiChIAANgIMDCELIAFB3cWFgAA2AgwMIAsgAUHO8YSAADYCDAwfCyABQdrChIAANgIMDB4LIAFBqauEgAA2AgwMHQsgAUHIq4SAADYCDAwcCyABQdTBhYAANgIMDBsLIAFB2daEgAA2AgwMGgsgAUHO14SAADYCDAwZCyABQfSEhYAANgIMDBgLIAFBvd+EgAA2AgwMFwsgAUHd84SAADYCDAwWCyABQf76hIAANgIMDBULIAFBn5uGgAA2AgwMFAsgAUGFvoWAADYCDAwTCyABQZyDhIAANgIMDBILIAFBh6OFgAA2AgwMEQsg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AABB/wFxLQDg+IeAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg+oeAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg+oeAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg+oeAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg/IeAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg/IeAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg/IeAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg/oeAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg/oeAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg/oeAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDggIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDggIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDggIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDggoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDggoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDggoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDghIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDghIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDghIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDghoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDghoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDghoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgiIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgiIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgiIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgioiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgioiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgioiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgjIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgjIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgjIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgjoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgjoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgjoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgkIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgkIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgkIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgkoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgkoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgkoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDglIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDglIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDglIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgloiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgloiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgloiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgmIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgmIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgmIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgmoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgmoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgmoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgnIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgnIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgnIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgnoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgnoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgnoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgoIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgoIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgoIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgooiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgooiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgooiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgpIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgpIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgpIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgpoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgpoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgpoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgqIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgqIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgqIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgqoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgqoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgqoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgrIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgrIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgrIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgroiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgroiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgroiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgsIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgsIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgsIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgsoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgsoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgsoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgtIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgtIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgtIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgtoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgtoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgtoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDguIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDguIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDguIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDguoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDguoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDguoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgvIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgvIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgvIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgvoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgvoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgvoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgwIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgwIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgwIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgwoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgwoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgwoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgxIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgxIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgxIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgxoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgxoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgxoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgyIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgyIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgyIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgyoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgyoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgyoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgzIiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgzIiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgzIiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgzoiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgzoiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDgzoiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg0IiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg0IiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg0IiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg0oiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg0oiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg0oiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg1IiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg1IiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg1IiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg1oiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg1oiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg1oiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg2IiAAEH/AXFBAXEPC0EBAn8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg2IiAAEH/AXFBAnEhA0EBQQAgAxsPCz4BAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg2IiAAEH/AXFBBHFBAEdBAXEPCzgBAX8jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgwtAABB/wFxLQDg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AkAgAigCAEEFRkEBcUUNACACKAIIIRwgAigCACEdIBxBmZiGgAAgHRCri4CAAA0AIAJB8N2HgABB8ARqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIIR4gAigCACEfIB5Byp6GgAAgHxCri4CAAA0AIAJB8N2HgABBiAVqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIISAgAigCACEhICBBjJiGgAAgIRCri4CAAA0AIAJB8N2HgABBoAVqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIISIgAigCACEjICJBnZmGgAAgIxCri4CAAA0AIAJB8N2HgABBuAVqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIISQgAigCACElICRBoZ6GgAAgJRCri4CAAA0AIAJB8N2HgABB8AFqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIISYgAigCACEnICZB35yGgAAgJxCri4CAAA0AIAJB8N2HgABBiAJqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIISggAigCACEpIChBt5mGgAAgKRCri4CAAA0AIAJB8N2HgABBoAJqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIISogAigCACErICpB65eGgAAgKxCri4CAAA0AIAJB8N2HgABBgAZqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIISwgAigCACEtICxBjp6GgAAgLRCri4CAAA0AIAJB8N2HgABBmAZqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIIS4gAigCACEvIC5BrZ2GgAAgLxCri4CAAA0AIAJB8N2HgABBsAZqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIITAgAigCACExIDBB0pyGgAAgMRCri4CAAA0AIAJB8N2HgABByAZqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIITIgAigCACEzIDJBp5qGgAAgMxCri4CAAA0AIAJB8N2HgABB+AZqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIITQgAigCACE1IDRBqpmGgAAgNRCri4CAAA0AIAJB8N2HgABBkAdqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIITYgAigCACE3IDZBvpiGgAAgNxCri4CAAA0AIAJB8N2HgABBqAdqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIITggAigCACE5IDhB25aGgAAgORCri4CAAA0AIAJB8N2HgABBwAdqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIITogAigCACE7IDpBlZqGgAAgOxCri4CAAA0AIAJB8N2HgABB2BBqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIITwgAigCACE9IDxBjZeGgAAgPRCri4CAAA0AIAJB8N2HgABBwApqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIIT4gAigCACE/ID5B9ZuGgAAgPxCri4CAAA0AIAJB8N2HgABB4AZqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIIUAgAigCACFBIEBB45iGgAAgQRCri4CAAA0AIAJB8N2HgABB2ARqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIIUIgAigCACFDIEJB6JaGgAAgQxCri4CAAA0AIAJB8N2HgABBuAJqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIIUQgAigCACFFIERBm56GgAAgRRCri4CAAA0AIAJB8N2HgABB0AJqNgIMDA4LAkAgAigCAEEFRkEBcUUNACACKAIIIUYgAigCACFHIEZBup2GgAAgRxCri4CAAA0AIAJB8N2HgABB6AJqNgIMDA4LAkAgAigCAEEGRkEBcUUNACACKAIIIUggAigCACFJIEhBrp6GgAAgSRCri4CAAA0AIAJB8N2HgABBgA9qNgIMDA4LAkAgAigCAEEGRkEBcUUNACACKAIIIUogAigCACFLIEpBwJ2GgAAgSxCri4CAAA0AIAJB8N2HgABBmA9qNgIMDA4LAkAgAigCAEEGRkEBcUUNACACKAIIIUwgAigCACFNIExB7JyGgAAgTRCri4CAAA0AIAJB8N2HgABBsA9qNgIMDA4LAkAgAigCAEEGRkEBcUUNACACKAIIIU4gAigCACFPIE5BgpyGgAAgTxCri4CAAA0AIAJB8N2HgABByA9qNgIMDA4LAkAgAigCAEEGRkEBcUUNACACKAIIIVAgAigCACFRIFBBtJqGgAAgURCri4CAAA0AIAJB8N2HgABB4A9qNgIMDA4LAkAgAigCAEEGRkEBcUUNACACKAIIIVIgAigCACFTIFJBxJmGgAAgUxCri4CAAA0AIAJB8N2HgABB+A9qNgIMDA4LAkAgAigCAEEGRkEBcUUNACACKAIIIVQgAigCACFVIFRBy5iGgAAgVRCri4CAAA0AIAJB8N2HgABBkBBqNgIMDA4LAkAgAigCAEEGRkEBcUUNACACKAIIIVYgAigCACFXIFZB+JeGgAAgVxCri4CAAA0AIAJB8N2HgABBqBBqNgIMDA4LAkAgAigCAEEGRkEBcUUNACACKAIIIVggAigCACFZIFhBopeGgAAgWRCri4CAAA0AIAJB8N2HgABBwBBqNgIMDA4LAkAgAigCAEEHRkEBcUUNACACKAIIIVogAigCACFbIFpBhp2GgAAgWxCri4CAAA0AIAJB8N2HgABB2AFqNgIMDA4LDAsLAkAgAigCAEEGRkEBcUUNACACKAIIIVwgAigCACFdIFxByvSFgAAgXRCri4CAAA0AIAJB8N2HgABByABqNgIMDA0LAkAgAigCAEEFRkEBcUUNACACKAIIIV4gAigCACFfIF5BxPSFgAAgXxCri4CAAA0AIAJB8N2HgABByABqNgIMDA0LAkAgAigCAEEIRkEBcUUNACACKAIIIWAgAigCACFhIGBB4riEgAAgYRCri4CAAA0AIAJB8N2HgABBmANqNgIMDA0LAkAgAigCAEEJRkEBcUUNACACKAIIIWIgAigCACFjIGJB2LiEgAAgYxCri4CAAA0AIAJB8N2HgABBmANqNgIMDA0LAkAgAigCAEEMRkEBcUUNACACKAIIIWQgAigCACFlIGRB35qGgAAgZRCri4CAAA0AIAJB8N2HgABBsANqNgIMDA0LAkAgAigCAEEMRkEBcUUNACACKAIIIWYgAigCACFnIGZBlpyGgAAgZxCri4CAAA0AIAJB8N2HgABBsANqNgIMDA0LAkAgAigCAEEGRkEBcUUNACACKAIIIWggAigCACFpIGhB1PGFgAAgaRCri4CAAA0AIAJB8N2HgABByANqNgIMDA0LAkAgAigCAEEFRkEBcUUNACACKAIIIWogAigCACFrIGpBzvGFgAAgaxCri4CAAA0AIAJB8N2HgABByANqNgIMDA0LAkAgAigCAEEGRkEBcUUNACACKAIIIWwgAigCACFtIGxBjfaFgAAgbRCri4CAAA0AIAJB8N2HgABB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BEEARkEBcUUNACACQQBBAXE6AB8MAQsgAigCBCEEIAIoAhggBDYCCCACKAIMIQUgAigCGCAFNgIEIAJBAUEBcToAHwsgAi0AH0EBcSEGIAJBIGokgICAgAAgBg8LpQEBBn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQCACKAIMQQEQmYaAgABBAXFFDQAgAigCDCgCCEEEaiEDIAIoAgwoAgghBCACKAIMKAIAQQJ0IQUCQCAFRQ0AIAMgBCAF/AoAAAsgAigCCCEGIAIoAgwoAgggBjYCACACKAIMIQcgByAHKAIAQQFqNgIACyACQRBqJICAgIAADwu7AQEGfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCAJAIAIoAggoAgBBAEtBAXFFDQAgAigCDCACKAIIKAIAEJmGgIAAQQFxRQ0AIAIoAgwoAgggAigCDCgCAEECdGohAyACKAIIKAIIIQQgAigCCCgCAEECdCEFAkAgBUUNACADIAQgBfwKAAALIAIoAggoAgAhBiACKAIMIQcgByAGIAcoAgBqNgIACyACQRBqJICAgIAADwuGAQEDfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkAgASgCDCgCBEEAS0EBcUUNACABKAIMKAIIEJaMgIAAIAEoAgwhAiABQQA2AgAgAUEANgIEIAFBADYCCCACIAEpAgA3AgBBCCEDIAIgA2ogASADaigCADYCAAsgAUEQaiSAgICAAA8L60ABAn8jgICAgABB4ANrIQIgAiSAgICAACACIAA2AtwDIAIgATYC2AMgAigC2AMvAQBBf2ohAyADQZYBSxoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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IAIoAugBKAIQQQBHQQFxRQ0AIAIoAtwDIAIoAugBKAIQEJ2GgIAACwJAIAIoAugBKAIkQQBHQQFxRQ0AIAIoAtwDIAIoAugBKAIkEJ2GgIAACwJAIAIoAugBKAIwQQBHQQFxRQ0AIAIoAtwDIAIoAugBKAIwEJ2GgIAACyACKALcAyACKALoASgCPBCdhoCAAAxOCyACIAIoAtgDNgLkASACKALcAyACKALkASgCEBCdhoCAAAJAIAIoAuQBKAIcQQBHQQFxRQ0AIAIoAtwDIAIoAuQBKAIcEJ2GgIAACwJAIAIoAuQBKAIoQQBHQQFxRQ0AIAIoAtwDIAIoAuQBKAIoEJ2GgIAACwxNCyACIAIoAtgDNgLgASACKALcAyACKALgASgCJBCdhoCAAAxMCyACIAIoAtgDNgLcASACKALcAyACKALcASgCJBCdhoCAAAxLCyACIAIoAtgDNgLYASACKALcAyACKALYASgCJBCdhoCAAAxKCwxJCwxICyACIAIoAtgDNgLUASACKALcAyACKALUASgCHBCdhoCAAAxHCyACIAIoAtgDNgLQASACKALQAUEQahCVi4CAAAxGCyACIAIoAtgDNgLMASACKALcAyACKALMAUEYahCehoCAAAxFCyACIAIoAtgDNgLIASACKALcAyACKALIAUEYahCehoCAAAxECyACIAIoAtgDNgLEASACKALcAyACKALEAUEYahCehoCAAAxDCyACIAIoAtgDNgLAASACKALcAyACKALAAUEYahCehoCAAAxCCyACIAIoAtgDNgK8ASACKALcAyACKAK8AUEYahCehoCAAAxBCwxACww/CyACIAIoAtgDNgK4ASACKALcAyACKAK4AUEQahCehoCAAAw+Cww9CyACIAIoAtgDNgK0ASACKAK0AUEQahCAi4CAAAJAIAIoArQBKAI0QQBHQQFxRQ0AIAIoAtwDIAIoArQBKAI0EJ2GgIAACwJAIAIoArQBKAI4QQBHQQFxRQ0AIAIoAtwDIAIoArQBKAI4EJ2GgIAACww8CyACIAIoAtgDNgKwASACKALcAyACKAKwASgCIBCdhoCAAAw7CyACIAIoAtgDNgKsASACKALcAyACKAKsASgCIBCdhoCAAAw6CyACIAIoAtgDNgKoASACKALcAyACKAKoASgCIBCdhoCAAAw5Cww4Cww3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AiQgAygCqAUgAygCpAUQn4aAgAAMewsMegsMeQsgAyADKAKsBTYCgAQgAygCgAQoAhwgAygCqAUgAygCpAUQn4aAgAAMeAsgAyADKAKsBTYC/AMgAygC/AMoAiQgAygCqAUgAygCpAUQn4aAgAAMdwsgAyADKAKsBTYC+AMgAygC+AMoAiQgAygCqAUgAygCpAUQn4aAgAAMdgsgAyADKAKsBTYC9AMgAygC9AMoAiQgAygCqAUgAygCpAUQn4aAgAAMdQsgAyADKAKsBTYC8AMgAygC8AMoAhAgAygCqAUgAygCpAUQn4aAgAAgAygC8AMoAhwgAygCqAUgAygCpAUQn4aAgAAMdAsgAyADKAKsBTYC7AMCQCADKALsAygCEEEAR0EBcUUNACADKALsAygCECADKAKoBSADKAKkBRCfhoCAAAsMcwsgAyADKAKsBTYC6AMgAygC6AMoAhAgAygCqAUgAygCpAUQn4aAgAAgAygC6AMoAhwgAygCqAUgAygCpAUQn4aAgAAMcgsgAyADKAKsBTYC5AMgAygC5AMoAhAgAygCqAUgAygCpAUQn4aAgAAgAygC5AMoAhwgAygCqAUgAygCpAUQn4aAgAAMcQsgAyADKAKsBTYC4AMCQCADKALgAygCEEEAR0EBcUUNACADKALgAygCECADKAKoBSADKAKkBRCfhoCAAAsMcAsgAyADKAKsBTYC3AMgAygC3AMoAhAgAygCqAUgAygCpAUQn4aAgAAgAygC3AMoAhwgAygCqAUgAygCpAUQn4aAgAAMbwsMbgsMbQsgAyADKAKsBTYC2AMgAygC2AMoAhwgAygCqAUgAygCpAUQn4aAgAAMbAsgAyADKAKsBTYC1AMCQCADKALUAygCHEEAR0EBcUUNACADKALUAygCHCADKAKoBSADKAKkBRCfhoCAAAsCQCADKALUAygCIEEAR0EBcUUNACADKALUAygCICADKAKoBSADKAKkBRCfhoCAAAsCQCADKALUAygCJEEAR0EBcUUNACADKALUAygCJCADKAKoBSADKAKkBRCfhoCAAAsMawsgAyADKAKsBTYC0AMgAygC0AMoAhggAygCqAUgAygCpAUQn4aAgAAMagsgAyADKAKsBTYCzAMCQCADKALMAygCGEEAR0EBcUUNACADKALMAygCGCADKAKoBSADKAKkBRCfhoCAAAsMaQsgAyADKAKsBTYCyAMCQCADKALIAygCGEEAR0EBcUUNACADKALIAygCGCADKAKoBSADKAKkBRCfhoCAAAsMaAsgAyADKAKsBTYCxAMgAygCxAMoAhggAygCqAUgAygCpAUQn4aAgAAMZwsgAyADKAKsBTYCwAMCQCADKALAAygCGEEAR0EBcUUNACADKALAAygCGCADKAKoBSADKAKkBRCfhoCAAAsMZgsMZQsgAyADKAKsBTYCvAMCQCADKAK8AygCEEEAR0EBcUUNACADKAK8AygCECADKAKoBSADKAKkBRCfhoCAAAsgAygCvAMoAhQgAygCqAUgAygCpAUQn4aAgAAgAyADKAK8A0EYajYCuAMgA0EANgK0AwJAA0AgAygCtAMgAygCuAMoAgBJQQFxRQ0BIAMoArgDKAIIIAMoArQDQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoArQDQQFqNgK0AwwACwsgAygCvAMoAiQgAygCqAUgAygCpAUQn4aAgAAMZAsgAyADKAKsBTYCsAMCQCADKAKwAygCEEEAR0EBcUUNACADKAKwAygCECADKAKoBSADKAKkBRCfhoCAAAsCQCADKAKwAygCFEEAR0EBcUUNACADKAKwAygCFCADKAKoBSADKAKkBRCfhoCAAAsMYwsMYgsgAyADKAKsBTYCrAMgAygCrAMoAhAgAygCqAUgAygCpAUQn4aAgAAgAygCrAMoAhQgAygCqAUgAygCpAUQn4aAgAACQCADKAKsAygCGEEAR0EBcUUNACADKAKsAygCGCADKAKoBSADKAKkBRCfhoCAAAsMYQsMYAsMXwsgAyADKAKsBTYCqAMCQCADKAKoAygCEEEAR0EBcUUNACADKAKoAygCECADKAKoBSADKAKkBRCfhoCAAAsMXgsgAyADKAKsBTYCpAMgAygCpAMoAiQgAygCqAUgAygCpAUQn4aAgAAMXQsgAyADKAKsBTYCoAMgAygCoAMoAiQgAygCqAUgAygCpAUQn4aAgAAMXAsgAyADKAKsBTYCnAMgAygCnAMoAiQgAygCqAUgAygCpAUQn4aAgAAMWwsMWgsMWQsgAyADKAKsBTYCmAMgAygCmAMoAhwgAygCqAUgAygCpAUQn4aAgAAMWAsgAyADKAKsBTYClAMgAyADKAKUA0EYajYCkAMgA0EANgKMAwJAA0AgAygCjAMgAygCkAMoAgBJQQFxRQ0BIAMoApADKAIIIAMoAowDQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoAowDQQFqNgKMAwwACwsMVwsgAyADKAKsBTYCiAMCQCADKAKIAygCEEEAR0EBcUUNACADKAKIAygCECADKAKoBSADKAKkBRCfhoCAAAsgAyADKAKIA0EUajYChAMgA0EANgKAAwJAA0AgAygCgAMgAygChAMoAgBJQQFxRQ0BIAMoAoQDKAIIIAMoAoADQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoAoADQQFqNgKAAwwACwsCQCADKAKIAygCIEEAR0EBcUUNACADKAKIAygCICADKAKoBSADKAKkBRCfhoCAAAsMVgsgAyADKAKsBTYC/AIgAygC/AIoAhggAygCqAUgAygCpAUQn4aAgAACQCADKAL8AigCJEEAR0EBcUUNACADKAL8AigCJCADKAKoBSADKAKkBRCfhoCAAAsCQCADKAL8AigCKEEAR0EBcUUNACADKAL8AigCKCADKAKoBSADKAKkBRCfhoCAAAsMVQsgAyADKAKsBTYC+AIgAygC+AIoAhAgAygCqAUgAygCpAUQn4aAgAAMVAsgAyADKAKsBTYC9AIgAygC9AIoAhAgAygCqAUgAygCpAUQn4aAgAAMUwsMUgsgAyADKAKsBTYC8AIgAygC8AIoAhAgAygCqAUgAygCpAUQn4aAgAACQCADKALwAigCFEEAR0EBcUUNACADKALwAigCFCADKAKoBSADKAKkBRCfhoCAAAsMUQsgAyADKAKsBTYC7AICQCADKALsAigCEEEAR0EBcUUNACADKALsAigCECADKAKoBSADKAKkBRCfhoCAAAsCQCADKALsAigCJEEAR0EBcUUNACADKALsAigCJCADKAKoBSADKAKkBRCfhoCAAAsCQCADKALsAigCMEEAR0EBcUUNACADKALsAigCMCADKAKoBSADKAKkBRCfhoCAAAsgAygC7AIoAjwgAygCqAUgAygCpAUQn4aAgAAMUAsgAyADKAKsBTYC6AICQCADKALoAigCEEEAR0EBcUUNACADKALoAigCECADKAKoBSADKAKkBRCfhoCAAAsCQCADKALoAigCJEEAR0EBcUUNACADKALoAigCJCADKAKoBSADKAKkBRCfhoCAAAsCQCADKALoAigCMEEAR0EBcUUNACADKALoAigCMCADKAKoBSADKAKkBRCfhoCAAAsgAygC6AIoAkAgAygCqAUgAygCpAUQn4aAgAAMTwsgAyADKAKsBTYC5AICQCADKALkAigCEEEAR0EBcUUNACADKALkAigCECADKAKoBSADKAKkBRCfhoCAAAsCQCADKALkAigCJEEAR0EBcUUNACADKALkAigCJCADKAKoBSADKAKkBRCfhoCAAAsCQCADKALkAigCMEEAR0EBcUUNACADKALkAigCMCADKAKoBSADKAKkBRCfhoCAAAsgAygC5AIoAjwgAygCqAUgAygCpAUQn4aAgAAMTgsgAyADKAKsBTYC4AIgAygC4AIoAhAgAygCqAUgAygCpAUQn4aAgAACQCADKALgAigCHEEAR0EBcUUNACADKALgAigCHCADKAKoBSADKAKkBRCfhoCAAAsCQCADKALgAigCKEEAR0EBcUUNACADKALgAigCKCADKAKoBSADKAKkBRCfhoCAAAsMTQsgAyADKAKsBTYC3AIgAygC3AIoAiQgAygCqAUgAygCpAUQn4aAgAAMTAsgAyADKAKsBTYC2AIgAygC2AIoAiQgAygCqAUgAygCpAUQn4aAgAAMSwsgAyADKAKsBTYC1AIgAygC1AIoAiQgAygCqAUgAygCpAUQn4aAgAAMSgsMSQsMSAsgAyADKAKsBTYC0AIgAygC0AIoAhwgAygCqAUgAygCpAUQn4aAgAAMRwsMRgsgAyADKAKsBTYCzAIgAyADKALMAkEYajYCyAIgA0EANgLEAgJAA0AgAygCxAIgAygCyAIoAgBJQQFxRQ0BIAMoAsgCKAIIIAMoAsQCQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoAsQCQQFqNgLEAgwACwsMRQsgAyADKAKsBTYCwAIgAyADKALAAkEYajYCvAIgA0EANgK4AgJAA0AgAygCuAIgAygCvAIoAgBJQQFxRQ0BIAMoArwCKAIIIAMoArgCQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoArgCQQFqNgK4AgwACwsMRAsgAyADKAKsBTYCtAIgAyADKAK0AkEYajYCsAIgA0EANgKsAgJAA0AgAygCrAIgAygCsAIoAgBJQQFxRQ0BIAMoArACKAIIIAMoAqwCQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoAqwCQQFqNgKsAgwACwsMQwsgAyADKAKsBTYCqAIgAyADKAKoAkEYajYCpAIgA0EANgKgAgJAA0AgAygCoAIgAygCpAIoAgBJQQFxRQ0BIAMoAqQCKAIIIAMoAqACQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoAqACQQFqNgKgAgwACwsMQgsgAyADKAKsBTYCnAIgAyADKAKcAkEYajYCmAIgA0EANgKUAgJAA0AgAygClAIgAygCmAIoAgBJQQFxRQ0BIAMoApgCKAIIIAMoApQCQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoApQCQQFqNgKUAgwACwsMQQsMQAsMPwsgAyADKAKsBTYCkAIgAyADKAKQAkEQajYCjAIgA0EANgKIAgJAA0AgAygCiAIgAygCjAIoAgBJQQFxRQ0BIAMoAowCKAIIIAMoAogCQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoAogCQQFqNgKIAgwACwsMPgsMPQsgAyADKAKsBTYChAICQCADKAKEAigCNEEAR0EBcUUNACADKAKEAigCNCADKAKoBSADKAKkBRCfhoCAAAsCQCADKAKEAigCOEEAR0EBcUUNACADKAKEAigCOCADKAKoBSADKAKkBRCfhoCAAAsMPAsgAyADKAKsBTYCgAIgAygCgAIoAiAgAygCqAUgAygCpAUQn4aAgAAMOwsgAyADKAKsBTYC/AEgAygC/AEoAiAgAygCqAUgAygCpAUQn4aAgAAMOgsgAyADKAKsBTYC+AEgAygC+AEoAiAgAygCqAUgAygCpAUQn4aAgAAMOQsMOAsMNwsgAyADKAKsBTYC9AEgAygC9AEoAiAgAygCqAUgAygCpAUQn4aAgAAMNgsMNQsgAyADKAKsBTYC8AEgAygC8AEoAhAgAygCqAUgAygCpAUQn4aAgAAgAygC8AEoAhQgAygCqAUgAygCpAUQn4aAgAAMNAsgAyADKAKsBTYC7AEgAygC7AEoAhAgAygCqAUgAygCpAUQn4aAgAAgAygC7AEoAhQgAygCqAUgAygCpAUQn4aAgAAMMwsgAyADKAKsBTYC6AEgAygC6AEoAhAgAygCqAUgAygCpAUQn4aAgAAgAyADKALoAUEUajYC5AEgA0EANgLgAQJAA0AgAygC4AEgAygC5AEoAgBJQQFxRQ0BIAMoAuQBKAIIIAMoAuABQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoAuABQQFqNgLgAQwACwsMMgsMMQsgAyADKAKsBTYC3AEgAygC3AEoAiQgAygCqAUgAygCpAUQn4aAgAACQCADKALcASgCKEEAR0EBcUUNACADKALcASgCKCADKAKoBSADKAKkBRCfhoCAAAsMMAsgAyADKAKsBTYC2AEgAyADKALYAUEQajYC1AEgA0EANgLQAQJAA0AgAygC0AEgAygC1AEoAgBJQQFxRQ0BIAMoAtQBKAIIIAMoAtABQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoAtABQQFqNgLQAQwACwsCQCADKALYASgCHEEAR0EBcUUNACADKALYASgCHCADKAKoBSADKAKkBRCfhoCAAAsgAyADKALYAUEgajYCzAEgA0EANgLIAQJAA0AgAygCyAEgAygCzAEoAgBJQQFxRQ0BIAMoAswBKAIIIAMoAsgBQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoAsgBQQFqNgLIAQwACwsMLwsgAyADKAKsBTYCxAEgAyADKALEAUEQajYCwAEgA0EANgK8AQJAA0AgAygCvAEgAygCwAEoAgBJQQFxRQ0BIAMoAsABKAIIIAMoArwBQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoArwBQQFqNgK8AQwACwsCQCADKALEASgCHEEAR0EBcUUNACADKALEASgCHCADKAKoBSADKAKkBRCfhoCAAAsgAyADKALEAUEgajYCuAEgA0EANgK0AQJAA0AgAygCtAEgAygCuAEoAgBJQQFxRQ0BIAMoArgBKAIIIAMoArQBQQJ0aigCACADKAKoBSADKAKkBRCfhoCAACADIAMoArQBQQFqNgK0AQwACwsgAygCxAEoAkQgAygCqAUgAygCpAUQn4aAgAAMLgsgAyADKAKsBTYCsAECQCADKAKwASgCEEEAR0EBcUUNACADKAKwASgCECADKAKoBSADKAKkBRCfhoCAAAsMLQsMLAsMKwsMKgsMKQsgAyADKAKsBTYCrAEg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BUGWpoaAACAGEKqGgIAANgJMAkACQCAEKAJMQQBGQQFxRQ0ADAELIAQoAlghB0EwIQggByAIaikCACEJIAggBEEQamogCTcDAEEoIQogByAKaikCACELIAogBEEQamogCzcDAEEgIQwgByAMaikCACENIAwgBEEQamogDTcDAEEYIQ4gByAOaikCACEPIA4gBEEQamogDzcDAEEQIRAgByAQaikCACERIBAgBEEQamogETcDAEEIIRIgByASaikCACETIBIgBEEQamogEzcDACAEIAcpAgA3AxAgBCgCWCgCACEUIAQoAkxBAWohFSAEKAJQIAQoAkwgBCgCVGtrQQFrIRYgBCgCWCgCBCEXIARBEGogFSAWIBcgFBGFgICAAICAgIAAIARBEGpBGGoQp4uAgAAhGCAEIBg2AgwCQCAYQQBLQQFxRQ0AIAQgBEEQakEYahCoi4CAADYCCCAEKAJcIAQoAgggBCgCCCAEKAIMahClhoCAABoLIAQtAEAhGSAEKAJcIBk6APwCIAQtAEEhGiAEKAJcIBo6AP0CCyAEQeAAaiSAgICAAA8LXgEBfyOAgICAAEEQayEEIAQkgICAgAAgBCAANgIMIAQgATYCCCAEIAI2AgQgBCADNgIAIAQoAgxBiAJqIAQoAgggBCgCBCAEKAIAEMeEgIAAGiAEQRBqJICAgIAADwtVAQJ/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADKAIMQbwCaiADKAIIIAMoAgQQiYuAgAAhBCADQRBqJICAgIAAIAQPC20BAX8jgICAgABBIGshBSAFJICAgIAAIAUgADYCHCAFIAE2AhggBSACNgIUIAUgAzYCECAFIAQ2AgwgBSgCHCgClAJBBGogBSgCGCAFKAIUIAUoAhAgBSgCDBDEhoCAABogBUEgaiSAgICAAA8LQQECfyOAgICAAEEQayECIAIgADYCDCACIAE6AAsgAigCDCgCAEEBdCACLQALQQFxQQFxciEDIAIoAgwgAzYCAA8LXgEBfyOAgICAAEEQayEEIAQkgICAgAAgBCAANgIMIAQgATYCCCAEIAI2AgQgBCADNgIAIAQoAgxB/AFqIAQoAgggBCgCBCAEKAIAEMeEgIAAGiAEQRBqJICAgIAADwvdAQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgxBsAJqEKqLgIAAIAEoAgxBiAJqEMuEgIAAIAEoAgxB/AFqEMuEgIAAIAEoAgxB3AFqELOGgIAAIAEoAgxB6AFqELSGgIAAIAEoAgxBvAJqEIuLgIAAIAEoAgxBzAJqEKKLgIAAAkADQCABKAIMKAKUAkEAR0EBcUUNASABKAIMELWGgIAADAALCwJAA0AgASgCDCgCsAFBBE9BAXFFDQEgASgCDBC2hoCAAAwACwsgAUEQaiSAgICAAA8LeQEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEgASgCDCgCBDYCCAJAA0AgASgCCEEAR0EBcUUNASABIAEoAggoAgA2AgQgASABKAIINgIAIAEoAgAQloyAgAAgASABKAIENgIIDAALCyABQRBqJICAgIAADwt5AQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASABKAIMKAIENgIIAkADQCABKAIIQQBHQQFxRQ0BIAEgASgCCCgCADYCBCABIAEoAgg2AgAgASgCABCWjICAACABIAEoAgQ2AggMAAsLIAFBEGokgICAgAAPC3QBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDCABIAEoAgwoApQCNgIIIAEoAggoAgAhAiABKAIMIAI2ApQCIAEoAghBBGoQt4aAgAAgASgCCEEQahCchoCAACABKAIIEJaMgIAAIAFBEGokgICAgAAPC+MBAQV/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQAJAIAEoAgwoArABDQAgASgCDCgCHEEANgIADAELAkACQCABKAIMKAKwAUEESUEBcUUNACABKAIMIQIgAiACKAKwAUF/ajYCsAEgASgCDEEcakEEaiABKAIMKAKwAUEkbGohAyABKAIMIAM2AhwMAQsgASgCDCEEIAQgBCgCsAFBf2o2ArABIAEgASgCDCgCHCgCIDYCCCABKAIMKAIcEJaMgIAAIAEoAgghBSABKAIMIAU2AhwLCyABQRBqJICAgIAADwtMAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwCQCABKAIMKAIEQQBLQQFxRQ0AIAEoAgwoAggQloyAgAALIAFBEGokgICAgAAPCzkBAn8jgICAgABBEGshASABJICAgIAAIAEgADYC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gIAADAULAkAgASgC/AUoAtQBQQBHQQFxRQ0AIAEoAvwFKALUASGNAiABKAL8BSCNAjYC0AEgASgC/AVBADYC1AELIAEoAvwFKALQASGOAiABKAL8BSCOAjYCzAECQAJAIAEoAvwFKALYAUEAR0EBcUUNACABIAEoAvwFKALQASABKAL8BSgCuAEgASgC/AUoAtABaxDqioCAADYCwAQCQCABKAL8BSABKALABBDehoCAAEH/AXFBCkZBAXFFDQAgASABKALABEEBajYCwAQLDAELIAEgASgC/AUoAtABIAEoAvwFKAK4ASABKAL8BSgC0AFrIAEoAvwFQcwCahDpioCAADYCwAQLAkAgASgCwARBAEtBAXFFDQAgASgCwAQhjwIgASgC/AUhkAIgkAIgjwIgkAIoAtABajYC0AECQCABKAL8BUF/EN6GgIAAQf8BcUEKRkEBcUUNACABKAL8BRDNhoCAAAsgASgC/AVBoQE2AsgBIAEoAvwFEMiGgIAADAULAkAgASgC/AUoAtABIAEoAvwFKAK4AU9BAXFFDQAgASgC/AVBATYCyAEgASgC/AUQyIaAgAAMBQsgASABKAL8BSgCHDYCvAQgASABKAK8BEEEakEHajYCuAQgASABKAL8BSABKAL8BSgC0AEgASgCuAQgASgC/AUoArgBIAEoAvwFKALQAWtBAUEBcRCti4CAADYCtAQgAUGoBGohkQJCACGSAiCRAiCSAjcDACABIJICNwOgBAJAA0AgASgCtARBAEdBAXFFDQECQCABKAK0BC0AAEH/AXEQ7IqAgABBAXFFDQAgASgCtAQhkwIgASgC/AUgkwI2AtABIAEoAvwFIAFBoARqEPmGgIAAIAEoAvwFQZQBNgLIASABKAL8BRDIhoCAAAwHCwJAIAEoArQELQAAQf8BcSABKAK8BC0ACkH/AXFGQQFxRQ0AAkAgASgCvAQoAgRBAEtBAXFFDQAgASgCtARBAWohlAIgASgC/AUglAI2AtABIAEgASgC/AUgASgC/AUoAtABIAEoArgEIAEoAvwFKAK4ASABKAL8BSgC0AFrQQFBAXEQrYuAgAA2ArQEIAEoArwEIZUCIJUCIJUCKAIEQX9qNgIEDAILAkAgASgCtAQgASgC/AUoAswBS0EBcUUNACABKAK0BCGWAiABKAL8BSCWAjYC0AEgASgC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CCABKAIIQRhsajYCBAJAIAEoAgQoAgBFDQACQCABLQATQQFxRQ0AIAEoAgQoAgAQxoaAgAAhBiABKAIEIAY2AhQLIAEgASgCBCgCFDYCAAJAA0AgASgCFCABKAIAIAEoAgxxQRhsaigCAEUNASABIAEoAgBBAWo2AgAMAAsLIAEoAhQgASgCACABKAIMcUEYbGohByABKAIEIQggByAIKQIANwIAQRAhCSAHIAlqIAggCWopAgA3AgBBCCEKIAcgCmogCCAKaikCADcCAAsgASABKAIIQQFqNgIIDAALCwsgASgCHBC3hoCAACABKAIUIQsgASgCHCALNgIIIAEoAhghDCABKAIcIAw2AgQgAUEgaiSAgICAAA8LYQEBfyOAgICAAEEQayEBIAEgADYCDCABIAEoAgxBEHYgASgCDHNBu772Imw2AgwgASABKAIMQRB2IAEoAgxzQbu+9iJsNgIMIAEgASgCDEEQdiABKAIMczYCDCABKAIMDwtPAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgwgAigCDCgC0AEgAigCCGoQzIaAgAAhAyACQRBqJICAgIAAIAMPC3QBAn8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAIAEoAgwoAqwCQQBHQQFxRQ0AIAEoAgwoAqwCKAIEIQIgASgCDCgCrAIoAgAgASgCDCABKAIMQcgBaiACEYOAgIAAgICAgAALIAFBEGokgICAgAAPC8IBAQR/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhggAiABNgIUIAJBAUEQEJ2MgIAANgIQAkACQCACKAIQQQBGQQFxRQ0AIAJBADYCHAwBCyACKAIQIQMgAkEANgIAIAIgAigCGCgCzAE2AgQgAiACKAIYKALQATYCCCACIAIoAhQ2AgwgAyACKQIANwIAQQghBCADIARqIAIgBGopAgA3AgAgAiACKAIQNgIcCyACKAIcIQUgAkEgaiSAgICAACAFDwveGgFofyOAgICAAEGQAWshAiACJICAgIAAIAIgADYCiAEgAiABOgCHASACQQE6AIYBIAIgAigCiAEoAswBQQFqNgKAASACIAIoAogBKALQATYCfAJAAkAgAigCfCACKAKAAWtBB0xBAXFFDQAgAkEAQQFxOgCPAQwBCyACQQA6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CwJAIAEoAggoAgRB/3dxQZAQRkEBcUUNACABQQI2AgwMAQsgAUEANgIMCyABKAIMIQYgAUEQaiSAgICAACAGDwtBAQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDEHCADYCyAEgASgCDBDIhoCAACABQRBqJICAgIAADwsvAQJ/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCCACKAIIIQMgAigCDCADNgIEDwtYAQF/I4CAgIAAQRBrIQIgAiAANgIIIAIgATYCBAJAAkAgAigCBCACKAIIKAK4AUlBAXFFDQAgAiACKAIELQAAOgAPDAELIAJBADoADwsgAi0AD0H/AXEPC7cCAQV/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhggAyABNgIUIAMgAjYCEAJAAkAgAygCEEEATEEBcUUNACADQQA2AhwMAQsCQCADKAIYLQCDA0EBcUUNACADKAIYKAKgAigCCCEEIAMoAhQgAygCECAEEYCAgIAAgICAgAAhBSADIAU2AgwCQCAFRQ0AIAMgAygCDDYCHAwCCwJAIAMoAhQtAABB/wFxQd8ARkEBcUUNACADQQE2AhwMAgsCQCADKAIULQAAQf8BcUGAAU5BAXFFDQAgAygCGCgCoAIoAgAhBiADIAMoAhQgAygCECAGEYCAgIAAgICAgAA2AhwMAgsgA0EANgIcDAELIAMgAygCFCADKAIQEKKHgIAANgIcCyADKAIcIQcgA0EgaiSAgICAACAHDws+AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDEEwENmGgIAAQQFxIQIgAUEQaiSAgICAACACDwtHAQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABOgALIAIoAgxBFGogAi0AC0EBcRCwhoCAACACQRBqJICAgIAADws4AQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDEEUahCjh4CAACABQRBqJICAgIAADws/AQJ/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDEGAAxDZhoCAAEEBcSECIAFBEGokgICAgAAgAg8LjgEBA38jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE6AAcCQAJAIAIoAggQ5YaAgABB/wFxIAItAAdB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IQcgAiAHaiAHIAFBDGpqKQIANwIAIAEoAighCCABQTBqJICAgIAAIAgPC1UBAn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACNgIEIAMoAgxBvAJqIAMoAgggAygCBBCKi4CAACEEIANBEGokgICAgAAgBA8L2AEBB38jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhggAiACKAIcQRQQnYeAgAA2AhQgAigCFCEDIAJBPjsBACACQQA7AQIgAigCHCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIEIAIgAigCHCgCtAE2AgggAiACKAIcKAK0ATYCDCACIAIoAhg2AhAgAyACKQIANwIAQRAhBiADIAZqIAIgBmooAgA2AgBBCCEHIAMgB2ogAiAHaikCADcCACACKAIUIQggAkEgaiSAgICAACAIDwvWAQEDfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCAJAIAIoAgwQgoqAgAANACACKAIIKAIIIQMgAigCDCADNgIICyACKAIIKAIMIQQgAigCDCAENgIMIAIoAgxBEGogAigCCBCYhoCAAAJAIAIoAggvAQBB//8DcUGLAUZBAXFFDQACQAJAIAIoAgwvAQJB//8DcUEgcUUNACACKAIMQcAAQf//A3EQm4eAgAAMAQsgAigCDEEgQf//A3EQm4eAgAALCyACQRBqJICAgIAADwuqAQEFfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAyADKAIcQSBB//8DcRCqiYCAADYCECADKAIQQQhqIQQgAyADKAIcKAK0ATYCCCADIAMoAhwoArQBNgIMIAQgAykCCDcCACADKAIYIQUgAygCECAFNgIwIAMoAhQhBiADKAIQIAY2AhwgAygCECEHIANBIGokgICAgAAgBw8LlgIBCX8jgICAgABBMGshBCAEJICAgIAAIAQgADYCLCAEIAE2AiggBCACNgIkIAQgAzYCICAEIAQoAixBAEH//wNxEKqJgIAANgIcIAQoAiwoArQBIQUgBCgCHCAFNgIIIAQoAiwoArgBIQYgBCgCHCAGNgIMIAQoAighByAEKAIcIAc2AhAgBCgCHEEUaiEIIARBADYCFCAEQQA2AhggCCAEKQIUNwIAIAQoAhxBIGohCSAEQQA2AgwgBEEANgIQIAkgBCkCDDcCACAEKAIgIQogBCgCHCAKNgIwIAQoAiwgBCgCJCAEKAIkEOiLgIAAEI+HgIAAIQsgBCgCHCALNgIcIAQoAhwhDCAEQTBqJICAgIAAIAwPC9gCAQl/I4CAgIAAQcAAayEDIAMkgICAgAAgAyAANgI8IAMgATYCOCADIAI2AjQgAyADKAI8QSgQnYeAgAA2AjAgAygCMCEEIANBwAA7AQggA0EAOwEKIAMoAjwhBSAFKAIAQQFqIQYgBSAGNgIAIAMgBjYCDCADIAMoAjwoArQBNgIQIAMgAygCPCgCtAE2AhQgAyADKAI4NgIYIAMgAygCPCgCtAE2AhwgAyADKAI8KAK0ATYCICADIAMoAjQ2AiQgAyADKAI8KAK0ATYCKCADIAMoAjwoArQBNgIsIAQgAykCCDcCAEEgIQcgBCAHaiAHIANBCGpqKQIANwIAQRghCCAEIAhqIAggA0EIamopAgA3AgBBECEJIAQgCWogCSADQQhqaikCADcCAEEIIQogBCAKaiAKIANBCGpqKQIANwIAIAMoAjAhCyADQcAAaiSAgICAACALDwtmAQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgwgAigCCBDFh4CAACACKAIMQRBqIAIoAggQmoaAgAAgAigCCEEBQf//A3EQm4eAgAAgAkEQaiSAgICAAA8L7AEBCH8jgICAgABBMGshASABJICAgIAAIAEgADYCLCABIAEoAixBHBCdh4CAADYCKCABKAIoIQIgAUHaADsBDCABQQQ7AQ4gASgCLCEDIAMoAgBBAWohBCADIAQ2AgAgASAENgIQIAFBADYCFCABQQA2AhggAUEANgIcIAFBADYCICABQQA2AiQgAiABKQIMNwIAQRghBSACIAVqIAUgAUEMamooAgA2AgBBECEGIAIgBmogBiABQQxqaikCADcCAEEIIQcgAiAHaiAHIAFBDGpqKQIANwIAIAEoAighCCABQTBqJICAgIAAIAgPC4QDAQt/I4CAgIAAQcAAayECIAIkgICAgAAgAiAANgI8IAIgATYCOCACIAIoAjxBNBCdh4CAADYCNCACKAI0IQMgAkGPATsBACACQRI7AQIgAigCPCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIEIAIgAigCPCgCtAE2AgggAiACKAI8KAK0ATYCDCACQRBqQgA3AgAgAiACKAI8KAK0ATYCGCACIAIoAjwoArQBNgIcIAJBIGpCADcCACACQQA2AiggAkEANgIsIAJBADYCMCADIAIpAgA3AgBBMCEGIAMgBmogAiAGaigCADYCAEEoIQcgAyAHaiACIAdqKQIANwIAQSAhCCADIAhqIAIgCGopAgA3AgBBGCEJIAMgCWogAiAJaikCADcCAEEQIQogAyAKaiACIApqKQIANwIAQQghCyADIAtqIAIgC2opAgA3AgAgAigCNEEoaiACKAI4IAIoAjgQ6IuAgAAQpYuAgAAgAigCNCEMIAJBwABqJICAgIAAIAwPC7cBAQZ/I4CAgIAAQSBrIQEgASSAgICAACABIAA2AhwgASABKAIcQRAQnYeAgAA2AhggASgCGCECIAFBkAE7AQggAUECOwEKIAEoAhwhAyADKAIAQQFqIQQgAyAENgIAIAEgBDYCDCABIAEoAhwoArQBNgIQIAEgASgCHCgCuAE2AhQgAiABKQIINwIAQQghBSACIAVqIAUgAUEIamopAgA3AgAgASgCGCEGIAFBIGokgICAgAAgBg8LtwUBCn8jgICAgABBwABrIQQgBCSAgICAACAEIAA2AjwgBCABNgI4IAQgAjYCNCAEIAM2AjAgBCAEKAI8QSAQnYeAgAA2AiwCQAJAIAQoAjBBAEdBAXFFDQAgBCgCMCgCDCAEKAI4KAIMS0EBcUUNACAEIAQoAjAoAgw2AigMAQsCQAJAIAQoAjQoAgBBpAFHQQFxRQ0AIAQgBCgCNCgCCDYCKAwBCyAEIAQoAjgoAgw2AigLCwJAIAQoAjgvAQBB//8DcUGNAUZBAXFFDQAgBCgCOCEFIAUgBS8BAkH//wNxQRJyOwECCyAEQQA7ASYCQCAEKAI4LwEAQf//A3FBBkZBAXENACAEKAI4LwEAQf//A3FBwQBGQQFxDQAgBCgCOC8BAEH//wNxQfoARkEBcQ0AIAQoAjBBAEdBAXFFDQAgBCgCMC8BAEH//wNxQQZGQQFxDQAgBCgCMC8BAEH//wNxQcEARkEBcQ0AIAQoAjAvAQBB//8DcUH6AEZBAXENACAEIAQoAjgvAQJB//8DcSAEKAIwLwECQf//A3FxQQJxOwEmCyAEKAIsIQYgBEEIOwEEIAQgBC8BJjsBBiAEKAI8IQcgBygCAEEBaiEIIAcgCDYCACAEIAg2AgggBCAEKAI4KAIINgIMIAQgBCgCKDYCECAEIAQoAjg2AhQgBCAEKAIwNgIYIARBBGpBGGohCQJAAkAgBCgCNCgCAEGkAUZBAXFFDQAgCUEANgIAIAlBADYCBAwBCyAJIAQoAjQoAgQ2AgAgCSAEKAI0KAIINgIECyAGIAQpAgQ3AgBBGCEKIAYgCmogCiAEQQRqaikCADcCAEEQIQsgBiALaiALIARBBGpqKQIANwIAQQghDCAGIAxqIAwgBEEEamopAgA3AgAgBCgCLCENIARBwABqJICAgIAAIA0PC8cBAQN/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIAkACQCACKAIILwEAQf//A3FBCEZBAXFFDQAgAigCCCgCEC8BAEH//wNxQY8BRkEBcQ0BCyACKAIMQQRB//8DcRDzh4CAAAsgAigCDEEQaiACKAIIEJiGgIAAAkAgAigCDCgCCEEARkEBcUUNACACKAIIKAIIIQMgAigCDCADNgIICyACKAIIKAIMIQQgAigCDCAENgIMIAJBEGokgICAgAAPC0MBA38jgICAgABBEGshAiACIAA2AgwgAiABOwEKIAIvAQpB//8DcSEDIAIoAgwhBCAEIAMgBC8BAkH//wNxcjsBAg8L/AIBCn8jgICAgABBwABrIQMgAySAgICAACADIAA2AjwgAyABNgI4IAMgAjYCNCADIAMoAjxBMBCdh4CAADYCMCADKAIwIQQgA0GVATsBACADQQA7AQIgAygCPCEFIAUoAgBBAWohBiAFIAY2AgAgAyAGNgIEIAMgAygCPCgCtAE2AgggAyADKAI8KAK0ATYCDCADIAMoAjwoArQBNgIQIAMgAygCPCgCtAE2AhQgAyADKAI8KAK0ATYCGCADIAMoAjwoArQBNgIcIAMgAygCPCgCtAE2AiAgAyADKAI8KAK0ATYCJCADIAMoAjg2AiggAyADKAI0NgIsIAQgAykCADcCAEEoIQcgBCAHaiADIAdqKQIANwIAQSAhCCAEIAhqIAMgCGopAgA3AgBBGCEJIAQgCWogAyAJaikCADcCAEEQIQogBCAKaiADIApqKQIANwIAQQghCyAEIAtqIAMgC2opAgA3AgAgAygCMCEMIANBwABqJICAgIAAIAwPC44BAQR/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgghAyACQQEgAxCdjICAADYCBAJAIAIoAgRBAEZBAXFFDQBBACgC0POIgAAhBCACIAIoAgg2AgAgBEHBuIaAACACEMOLgIAAGhC6i4CAAAALIAIoAgQhBSACQRBqJICAgIAAIAUPC6kCAQt/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgggAyABNgIEIAMgAjYCAAJAA0AgAygCBEEDaiADKAIATSEEQQAhBSAEQQFxIQYgBSEHAkAgBkUNACADKAIEIQggAygCACADKAIEayEJIAMoAggtAIMDIQogAygCCCgCoAIhCyAIQS0gCSAKQQFxIAsQnIuAgAAhDCADIAw2AgQgDEEARyEHCwJAIAdBAXFFDQACQCADKAIEQQNqIAMoAgBNQQFxRQ0AIAMoAgQtAAFB/wFxQSpGQQFxRQ0AIAMoAgQtAAJB/wFxQS1GQQFxRQ0AIAMgAygCBDYCDAwDCyADIAMoAgRBAWo2AgQMAQsLIANBADYCDAsgAygCDCENIANBEGokgICAgAAgDQ8LkAEBC38jgICAgABBEGshASABIAA6AA8gAS0AD0H/AXFBJ0YhAkEBIQMgAkEBcSEEIAMhBQJAIAQNACABLQAPQf8BcUEiRiEGQQEhByAGQQFxIQggByEFIAgNACABLQAPQf8BcUE6RiEJQQEhCiAJQQFxIQsgCiEFIAsNACABLQAPQf8BcUE7RiEFCyAFQQFxDwuiAQECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgATYCBAJAAkAgAigCBEEERkEBcUUNACACKAIIQe2OhYAAQQQQq4uAgAANACACQQA2AgwMAQsCQCACKAIEQQVGQQFxRQ0AIAIoAghBg6iFgABBBRCri4CAAA0AIAJBATYCDAwBCyACQQI2AgwLIAIoAgwhAyACQRBqJICAgIAAIAMPC38BB38jgICAgABBEGshAiACIAA2AgwgAiABOgALIAIgAigCDCgClAI2AgQDQCACLQALIQMgAigCBCADOgAdIAIoAgQtAB4hBEEAIQUgBEEBcSEGIAUhBwJAIAYNACACKAIEKAIAIQggAiAINgIEIAhBAEchBwsgB0EBcQ0ACw8L4QEBB38jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQCQAJAIAIoAgRBAExBAXFFDQAgAkEANgIMDAELAkAgAigCCC0AAEH/AXFBgAFIQQFxRQ0AIAIoAggtAABB/wFxQd8ARiEDQQEhBCADQQFxIQUgBCEGAkAgBQ0AIAIoAggtAABB/wFxLQDw0oaAAEH/AXFBAnEhB0EBQQAgBxtBAEchBgsgAiAGQQFxNgIMDAELIAIgAigCCCACKAIEEMyEgIAANgIMCyACKAIMIQggAkEQaiSAgICAACAIDwsrAQJ/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwhAiACIAIoAgBBAXY2AgAPC+sIARN/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhwgAiABNgIYIAJBxAA2AhQgAigCGEEAOgAAAkACQCACKAIcQX8Q3oaAgABB/wFxQTBGQQFxRQ0AIAIoAhwoAtABLQAAQVJqIQMgA0HKAEsaAkACQAJAAkACQAJAAkACQCADDksFBwMDAwMDAwMDBwcHBwcHBwcHBwEHAAYHBwcHBwcHBwcCBwcHBwcHBwcEBwcHBwcHAwcHAQcABgcHBwcHBwcHBwIHBwcHBwcHBwQHCyACKAIcIQQgBCAEKALQAUEBajYC0AECQAJAIAIoAhwQ5YaAgABB/wFxEPqKgIAAQQFxRQ0AIAIoAhwgAigCHCgC0AEQtYeAgAAhBSACKAIcIQYgBiAFIAYoAtABajYC0AEMAQsgAigCHEHfAEH/AXEQ14aAgAAaIAIoAhxBmgEQ6oaAgAALDAYLIAIoAhwhByAHIAcoAtABQQFqNgLQAQJAAkAgAigCHBDlhoCAAEH/AXEQ94qAgABBAXFFDQAgAigCHCACKAIcKALQARC2h4CAACEIIAIoAhwhCSAJIAggCSgC0AFqNgLQAQwBCyACKAIcQd8AQf8BcRDXhoCAABogAigCHEGZARDqhoCAAAsgAigCHEEEOwHcAgwFCyACKAIcIQogCiAKKALQAUEBajYC0AECQAJAIAIoAhwQ5YaAgABB/wFxEPmKgIAAQQFxRQ0AIAIoAhwgAigCHCgC0AEQt4eAgAAhCyACKAIcIQwgDCALIAwoAtABajYC0AEMAQsgAigCHEHfAEH/AXEQ14aAgAAaIAIoAhxBnQEQ6oaAgAALIAIoAhxBEDsB3AIMBAsgAigCHCACKAIcKALQARC3h4CAACENIAIoAhwhDiAOIA0gDigC0AFqNgLQASACKAIcQRA7AdwCDAMLIAIoAhwhDyAPIA8oAtABQQFqNgLQAQJAAkAgAigCHBDlhoCAAEH/AXEQ+4qAgABBAXFFDQAgAigCHCACKAIcKALQARC4h4CAACEQIAIoAhwhESARIBAgESgC0AFqNgLQAQwBCyACKAIcQd8AQf8BcRDXhoCAABogAigCHEGcARDqhoCAAAsgAigCHEEgOwHcAgwCCyACIAIoAhwgAigCGBC5h4CAADYCFAwBCyACIAIoAhwgAigCGBC5h4CAADYCFAsMAQsgAigCHCACKAIcKALQARC1h4CAACESIAIoAhwhEyATIBIgEygC0AFqNgLQASACIAIoAhwgAigCGBC5h4CAADYCFAsCQCACKAIcQQAQ3oaAgABB/wFxQS5GQQFxRQ0AIAIoAhxBARDehoCAAEH/AXEQ+oqAgABBAXFFDQAgAiACKAIcKALQATYCECACIAIoAhwoAtABQQJqNgIMIAIgAigCDCACKAIcKAK4ASACKAIMaxDyioCAACACKAIMajYCDCACKAIcIAIoAhAgAigCDEGbARCthoCAAAsgAigCFCEUIAJBIGokgICAgAAgFA8LWAEBfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAygCDCADKAIIKAIEIAMoAggoAgggAygCBBCthoCAACADQRBqJICAgIAADwugAgECfyOAgICAAEEwayEHIAckgICAgAAgByAANgIoIAcgATYCJCAHIAI2AiAgByADNgIcIAcgBDYCGCAHIAU2AhQgByAGNgIQAkACQCAHKAIkIAcoAiAgBygCHBDQi4CAAA0AIAcgBygCKCgCBDYCDAJAAkAgBygCKCgCBEGAAXFFDQAgBygCKEEIENCGgIAADAELIAcoAiggBygCGBDQhoCAAAJAIAcoAhhBAUZBAXFFDQAgBygCKEEBOgCAAwsCQCAHKAIQQQFHQQFxRQ0AIAcoAgxBgRRxDQAgBygCKEGBCBDQhoCAACAHIAcoAhA2AiwMAwsLIAcgBygCFDYCLAwBCyAHQQE2AiwLIAcoAiwhCCAHQTBqJICAgIAAIAgPCz8BAn8jgICAgABB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cUUNAQJAIAIoAgggAigCAGotAABB/wFxQYABcUUNACACQQBBAXE6AA8MAwsgAiACKAIAQQFqNgIADAALCyACQQFBAXE6AA8LIAItAA9BAXEPC38BAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAkEANgIEIAIgAigCCCACKAIMKAK4ASACKAIIayACQQRqEPSKgIAANgIAIAIoAgwgAigCCCACKAIAIAIoAgQQuoeAgAAgAigCACEDIAJBEGokgICAgAAgAw8LfwECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACQQA2AgQgAiACKAIIIAIoAgwoArgBIAIoAghrIAJBBGoQ74qAgAA2AgAgAigCDCACKAIIIAIoAgAgAigCBBC6h4CAACACKAIAIQMgAkEQaiSAgICAACADDwt/AQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAJBADYCBCACIAIoAgggAigCDCgCuAEgAigCCGsgAkEEahDxioCAADYCACACKAIMIAIoAgggAigCACACKAIEELqHgIAAIAIoAgAhAyACQRBqJICAgIAAIAMPC38BAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAkEANgIEIAIgAigCCCACKAIMKAK4ASACKAIIayACQQRqEPaKgIAANgIAIAIoAgwgAigCCCACKAIAIAIoAgQQuoeAgAAgAigCACEDIAJBEGokgICAgAAgAw8L5gQBDH8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQgAkHEADYCAAJAAkAgAigCCBDlhoCAAEH/AXFBLkZBAXFFDQACQAJAIAIoAghBARDehoCAAEH/AXEQ+oqAgABBAXFFDQAgAigCCCEDIAMgAygC0AFBAmo2AtABIAIoAgggAigCCCgC0AEQtYeAgAAhBCACKAIIIQUgBSAEIAUoAtABajYC0AEgAkE2NgIADAELIAIgAigCADYCDAwCCwsCQAJAIAIoAggQ5YaAgABB/wFxQeUARkEBcQ0AIAIoAggQ5YaAgABB/wFxQcUARkEBcUUNAQsCQAJAAkAgAigCCEEBEN6GgIAAQf8BcUErRkEBcQ0AIAIoAghBARDehoCAAEH/AXFBLUZBAXFF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KGpBADYCACADQgA3AyAgAygCPEHMAmohBCADKAI8KALsAiEFIAMoAjwoAqACKAIQIQYgAygCMCEHIANBIGogBCAFIAYgBxDQioCAACADKAI8QfwBaiEIIAMoAjAoAgghCSADKAIwKAIMIQogA0EgahDbioCAACELIANBIGoQ2oqAgAAhDCADKAI8QcwCaiENIAMoAjQoAgghDiADKAI8KALsAiEPIANBGGogDSAOIA8QoYuAgAAgAyADKAIYNgIIIAMgDDYCBCADIAs2AgAgCCAJIApBrwIgAxDKhICAABogA0EgahDnioCAAAsgA0HAAGokgICAgAAPCzsBAX8jgICAgABBEGshAiACIAE2AgwgAEGkATYCACAAIAIoAgwoArQBNgIEIAAgAigCDCgCtAE2AggPC6ACAQN/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIAkAgAigCDCgCEA0AIAIoAgwoAhxBAEdBAXENACACKAIIKAIIIQMgAigCDCADNgIICyACKAIMQRBqIAIoAggQmIaAgAAgAigCCCgCDCEEIAIoAgwgBDYCDAJAAkAgAigCCC8BAEH//wNxQQZGQQFxDQAgAigCCC8BAEH//wNxQcEARkEBcQ0AIAIoAggvAQBB//8DcUH6AEZBAXENACACKAIILwECQf//A3FBAnENAQsgAigCDEECQf//A3EQ84eAgAALAkAgAigCCC8BAEH//wNxQYsBRkEBcUUNACACKAIMQQRB//8DcRCbh4CAAAsgAkEQaiSAgICAAA8L1QEBA38jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQCACKAIIKAIAQSBGQQFxDQAgAigCCCgCAEGVAUZBAXENACACKAIIKAIAQaMBRkEBcQ0AIAIoAggoAgBBpAFGQQFxDQBBuo2GgABBjdGFgABB5BBBwaeEgAAQjoCAgAAACyACKAIIKAIIIQMgAigCDCADNgIMIAIoAgxBJGohBCACIAIoAggoAgQ2AgAgAiACKAIIKAIINgIEIAQgAikCADcCACACQRBqJICAgIAADws4AQF/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgwgASgCDEEYahCjh4CAACABQRBqJICAgIAADwucAQECfyOAgICAAEEQayEDIAMkgICAgAAgAyAA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KQIQNwIADAELIAIgAigCGCgCBDYCCCACIAIoAhgoAgg2AgwgAyACKQIINwIACyACKAIYKAIIIQQgAigCHCAENgIMDwudAwENfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgA0EBOgATIANBADYCDCADQQA2AgQDQCADKAIEIAMoAhgoAgBJIQRBACEFIARBAXEhBiAFIQcCQCAGRQ0AIAMoAhgoAgggAygCBEECdGooAgAhCCADIAg2AgggCEEARyEHCwJAIAdBAXFFDQACQAJAIAMoAggvAQBB//8DcUGNAUZBAXENACADKAIIIQkgAygCGCgCCCEKIAMoAgwhCyADIAtBAWo2AgwgCiALQQJ0aiAJNgIAIANBADoAEwwBCyADIAMoAgg2AgACQCADLQATQQFxRQ0AIAMoAgBBKGogAygCFBD9h4CAAAsCQAJAIAMoAgAoAiwNACADKAIcIAMoAggQnYaAgAAMAQsgAygCCCEMIAMoAhgoAgghDSADKAIMIQ4gAyAOQQFqNgIMIA0gDkECdGogDDYCAAsgA0EBOgATCyADIAMoAgRBAWo2AgQMAQsLIAMoAgwhDyADKAIYIA82AgAgA0EgaiSAgICAAA8LkgIBB38jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhgCQCACKAIYKAIAQcMARkEBcQ0AQbKChoAAQY3RhYAAQfonQfKfhYAAEI6AgIAAAAsgAiACKAIcQRQQnYeAgAA2AhQgAigCFCEDIAJBzwA7AQAgAkEAOwECIAIoAhwhBCAEKAIAQQFqIQUgBCAFNgIAIAIgBTYCBCACIAIoAhgoAgQ2AgggAiACKAIYKAIINgIMIAIgAigCHCACKAIYEKiHgIAANgIQIAMgAikCADcCAEEQIQYgAyAGaiACIAZqKAIANgIAQQghByADIAdqIAIgB2opAgA3AgAgAigCFCEIIAJBIGokgICAgAAgCA8LpAQBD38jgICAgABBwABrIQMgAySAgICAACADIAA2AjwgAyABOwE6IAMgAjYCNAJAIAMoAjQoAgBBxABGQQFxDQBByvKFgABBjdGFgABBlSZBtJeFgAAQjoCAgAAACyADIAMoAjxBIBCdh4CAADYCMCADKAIwIQQgA0HSADsBECADIAMvATpBAnI7ARIg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AigCPCEEIAQoAgBBAWohBSAEIAU2AgAgAiAFNgIIIAIgAigCOCgCBDYCDCACQQA2AhAgAiACKAI4KAIENgIUIAIgAigCOCgCCDYCGCACQQA2AhwgAkEANgIgIAJBADYCJCACQQA2AiggAkEANgIsIAJBADYCMCADIAIpAgQ3AgBBKCEGIAMgBmogBiACQQRqaikCADcCAEEgIQcgAyAHaiAHIAJBBGpqKQIANwIAQRghCCADIAhqIAggAkEEamopAgA3AgBBECEJIAMgCWogCSACQQRqaikCADcCAEEIIQogAyAKaiAKIAJBBGpqKQIANwIAIAIoAjQhCyACQcAAaiSAgICAACALDwtYAQJ/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAggoAgwhAyACKAIMIAM2AgwgAigCDEEYaiACKAIIEJiGgIAAIAJBEGokgICAgAAPC6ECAQx/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjYCJCADKAIsQcwCaiADKAIsKALsAiADKAIoIAMoAiRBAEEBcRDEioCAACEEIAMgBDYCIAJAIARBAEdBAXFFDQAgAygCLEH8AWohBSADKAIkKAIIIQYgAygCJCgCDCEHIAMoAixBzAJqIQggAygCJCgCCCEJIAMoAiwoAuwCIQogA0EYaiAIIAkgChChi4CAACADKAIYIQsgAygCLEHMAmohDCADKAIgKAIIIQ0gAygCLCgC7AIhDiADQRBqIAwgDSAOEKGLgIAAIAMgAygCEDYCBCADIAs2AgAgBSAGIAdBsAIgAxDKhICAABoLIANBMGokgICAgAAPC2ABA38jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAggoAgghAyACKAIMIAM2AgwgAigCDEEkaiEEIAIgAigCCCgCBDYCACACIAIoAggoAgg2AgQgBCACKQIANwIADwtdAQN/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCAJAIAIoAggoAgwgAigCDCgCDEtBAXFFDQAgAigCCCgCDCEDIAIoAgwgAzYCDAsgAigCCCEEIAIoAgwgBDYCLA8LjQEBAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AggCQCACKAIILwEAQf//A3FBlAFGQQFxDQBB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IQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIYQSRqIQQgAyADKAIUKAIENgIMIAMgAygCFCgCCDYCECAEIAMpAgw3AgAgAygCFCgCCCEFIAMoAhggBTYCDCADKAIYIAMoAhwgAygCFBDviYCAAEH//wNxEJuHgIAAIANBIGokgICAgAAPC4cBAQZ/I4CAgIAAQSBrIQQgBCSAgICAACAEIAA2AhwgBCABNgIYIAQgAjYCFCAEIAM2AhAgBCgCHCEFIAQoAhghBiAEKAIUIQcgBCgCECEIIARBADYCBCAEQQA2AgggBEEANgIMIAUgBiAHIAggBEEEahD6h4CAACEJIARBIGokgICAgAAgCQ8LXQECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIAIoAgxBGGogAigCCBDuiYCAACACKAIIKAIMIQMgAigCDCADNgIMIAJBEGokgICAgAAPC5wEARR/I4CAgIAAQcAAayECIAIkgICAgAAgAiAANgI8IAIgATYCOCACKAI4IQMCQAJAAkAgA0HWAEYNAAJAAkAgA0HdAEYNAAJAIANBggFGDQAgA0GFAUYNASADQZACRg0DIANBkQJGDQIMBAsgAigCPEGIAmohBCACKAI8KALAASEFIAIoAjwoAsQBIQYgAigCOCEHIAIgAigCPCgCvAEQ2IqAgAA2AgAgBCAFIAYgByACEMqEgIAAGgwECyACKAI8QYgCaiEIIAIoAjwoAswBIQkgAigCPCgC0AEhCiACKAI4IQsgAiACKAI8KALIARDYioCAADYCECAIIAkgCiALIAJBEGoQyoSAgAAaDAMLAkACQCACKAI8KALIAUEBRkEBcUUNAEG1i4SAACEMDAELIAIoAjwoAsgBENiKgIAAIQwLIAIgDDYCNCACKAI8QYgCaiENIAIoAjwoAsABIQ4gAigCPCgCxAEhDyACKAI4IRAgAigCNCERIAIgAigCPCgCwAEtAABB/wFxNgIkIAIgETYCICANIA4gDyAQIAJBIGoQyoSAgAAaDAILIAIoAjxBiAJqIRIgAigCPCgCzAEhEyACKAI8KALQASEUIAIoAjghFSACIAIoAjwoAsgBENiKgIAANgIwIBIgEyAUIBUgAkEwahDKhICAABoMAQsgAigCPCACKAI4EMmHgIAACyACQcAAaiSAgICAAA8L6wEBBn8jgICAgABBEGshAyADJICAgIAAIAMgADYCDCADIAE2AgggAyACOgAHIAMoAgwhBCADKAIIIQUgAy0AByEGQQAhByADIAQgBSAGQQFxIAdBAXEQwoiAgAA2AgACQCADKAIMQTEQi4eAgABBAXENAAJAIAMoAgxBGxDnhoCAAEEBcUUNACADKAIMQQoQi4eAgABBAXENAQsCQCADKAIMQSkQ54aAgABBAXFFDQAgAygCDEEPEIuHgIAAQQFxDQELIAMoAgwgAygCAEGhAhDbh4CAAAsgAygCACEIIANBEGokgICAgAAgCA8LuAIBB38jgICAgABBMGshBCAEJICAgIAAIAQgADYCLCAEIAE2AiggBCACNgIkIAQgAzYCICAEKAIsIAQoAiQQnImAgAAgBCAEKAIsIAQoAiQQ7YmAgABB//8DcRCqiYCAADYCHCAEKAIoKAIEIQUgBCgCHCAFNgIIIAQoAiQoAgwhBiAEKAIcIAY2AgwgBCgCJCEHIAQoAhwgBzYCECAEKAIcQSBqIQgCQAJAIAQoAigoAgBBpAFGQQFxRQ0AIARBADYCFCAEQQA2AhggCCAEKQIUNwIADAELIAQgBCgCKCgCBDYCDCAEIAQoAigoAgg2AhAgCCAEKQIMNwIACyAEKAIsIAQoAiAgBCgCIBDoi4CAABCPh4CAACEJIAQoAhwgCTYCHCAEKAIcIQogBEEwaiSAgICAACAKDwv5CAECfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIsIAMgATYCKCADIAI2AiQgAygCKC8BAEF8aiEEIARBiwFLGgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAQOjAEAERERERERAxERERERERERERERERERERERERERCxERERERERERERERDBEREREREREREQoRERERERERERENERERChEREREREREREREREQ4HEQYICRERERERERERERERDxEREREREREQEREREREREQERAhERERERBAoRBREREREREREREREKCAoREQgRCRELIAMgAygCKDYCICADKAIsIAMoAiAoAhBBABDgiICAACADKAIsIAMoAiAoAhRBABDgiICAAAwRCyADIAMoAig2AhwgAygCLCADKAIcKAIQQQAQ4IiA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AgQ2AiggByAHKAJQKAIINgIsIAcgBygCTCgCBDYCMCAHIAcoAkwoAgg2AjQgByAHKAJINgI4IAcgBygCRDYCPCAIIAcpAgQ3AgBBOCEOIAggDmogDiAHQQRqaigCADYCAEEwIQ8gCCAPaiAPIAdBBGpqKQIANwIAQSghECAIIBBqIBAgB0EEamopAgA3AgBBICERIAggEWogESAHQQRqaikCADcCAEEYIRIgCCASaiASIAdBBGpqKQIANwIAQRAhEyAIIBNqIBMgB0EEamopAgA3AgBBCCEUIAggFGogFCAHQQRqaikCADcCACAHKAJAIRUgB0HgAGokgICAgAAgFQ8LlxABK38jgICAgABBkAFrIQQgBCSAgICAACAEIAA2AogBIAQgATYChAEgBCACNgKAASAEIAM7AX4gBCgCiAFBvAFqIQVBCCEGIAUgBmooAgAhByAGIARB8ABqaiAHNgIAIAQgBSkCADcDcAJAAkAgBCgChAEoAgBBBkdBAXFFDQACQCAEKAKAAUUNACAEKAKIASAEKAKAARDQhoCAAAsgBCgCiAEoAsgBQXtqIQggCEGbAUsaAkACQAJAAkAgCA6cAQEBAQEBAQEBAQICAgACAgICAAEAAAACAgIAAAIAAgIBAgICAQICAgICAgICAgAAAgACAgICAQAAAAICAgECAQICAgIBAQEBAQEBAQEBAQEBAQIBAQEBAQECAQEBAQEBAQIBAgECAQEBAQICAgAAAAACAQACAgECAgACAgICAgIAAgICAAICAgIAAgACAAICAgICAAACAgIAAAAAAAILIAQoAogBIQkCQAJAIAQoAoABDQBBCCEKDAELIAQoAoABIQoLIAohCyAEIAkgBEHwAGogCxCwiYCAADYCjAEMBAsgBCgCiAEQu4aAgAAMAQsgBCgCiAFBwQBB9gBBigIQsoiAgAALIAQoAogBIQwgBEHkAGogDBDRh4CAACAEKAKIASENIAQoAogBQbwBaiEOIAQgDSAEQfAAaiAOIARB5ABqEKeJgIAANgJgIAQoAmBBKGogBCgCiAEoAsABIAQoAogBKALEARCji4CAACAEKAJgIAQoAogBIAQoAogBQbwBaiAEKAJgQShqQQBBAXEQqImAgABB//8DcRCbh4CAACAEIAQoAmA2AowBDAELAkAgBCgChAEtAAhBAXFFDQACQCAE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NgIYIAIgAigCWCgCCCgCACgCCDYCHCACIAIoAlgoAgggAigCWCgCAEEBa0ECdGooAgAoAgw2AiAgAkEANgIkIAJBADYCKCACQQA2AiwgAkEANgIwIAJBADYCNCACQQA2AjggAkEANgI8IAJBADYCQCACQQA2AkQgAkEANgJIIAJBADYCTCACQQA2AlAgAyACKQIUNwIAQTghBiADIAZqIAYgAkEUamopAgA3AgBBMCEHIAMgB2ogByACQRRqaikCADcCAEEoIQggAyAIaiAIIAJBFGpqKQIANwIAQSAhCSADIAlqIAkgAkEUamopAgA3AgBBGCEKIAMgCmogCiACQRRqaikCADcCAEEQIQsgAyALaiALIAJBFGpqKQIANwIAQQghDCADIAxqIAwgAkEUamopAgA3AgAgAkEAOgATIAJBADYCCANAIAIoAgggAigCWCgCAEkhDUEAIQ4gDUEBcSEPIA4hEAJAIA9FDQAgAigCWCgCCCACKAIIQQJ0aigCACERIAIgETYCDCARQQBHIRALAkAgEEEBcUUNAAJAAkAgAi0AE0EBcQ0AAkAgAigCDC8BAEH//wNxQYsBRkEBcQ0AIAIoAgwvAQBB//8DcUHGAEZBAXFFDQELIAIoAgwhEiACKAJUIBI2AiAgAkEBOgATDAELAkACQCACLQATQQFxRQ0AIAIoAlRBJGogAigCDBCYhoCAAAwBCyACKAJUQRRqIAIoAgwQmIaAgAALCyACIAIoAghBAWo2AggMAQsLIAIoAlQhEyACQeAAaiSAgICAACATDwufAwENfyOAgICAAEHQAGshAiACJICAgIAAIAIgADYCTCACIAE2AkggAiACKAJMQcAAEJ2HgIAANgJEIAIoAkQhAyACQQRqIQQgAkEHOwEEIAJBADsBBiACKAJMIQUgBSgCAEEBaiEGIAUgBjYCACACIAY2AgggBEEIaiACKAJIQQhqKQIANwIAIAJBADYCFCACQQA2AhggAkEANgIcIAJBADYCICACIAIoAkg2AiQgAkEANgIoIAJBADYCLCACQQA2AjAgAkEANgI0IAJBADYCOCACQQA2AjwgAkEANgJAIAMgAikCBDcCAEE4IQcgAyAHaiAHIAJBBGpqKQIANwIAQTAhCCADIAhqIAggAkEEamopAgA3AgBBKCEJIAMgCWogCSACQQRqaikCADcCAEEgIQogAyAKaiAKIAJBBGpqKQIANwIAQRghCyADIAtqIAsgAkEEamopAgA3AgBBECEMIAMgDGogDCACQQRqaikCADcCAEEIIQ0gAyANaiANIAJBBGpqKQIANwIAIAIoAkQhDiACQdAAaiSAgICAACAODwupAwEMfyOAgICAAEHQAGshAiACJICAgIAAIAIgADYCTCACIAE2AkggAiACKAJMQcAAEJ2HgIAANgJEIAIoAkQhAyACQYEBOwEEIAJBADsBBiACKAJMIQQgBCgCAEEBaiEFIAQgBTYCACACIAU2AgggAiACKAJIKAIENgIMIAIgAigCSCgCCDYCECACIAIoAkgoAgQ2AhQgAiACKAJIKAIINgIYIAJBADYCHCACQQA2AiAgAkEANgIkIAJBADYCKCACQQA2AiwgAkEANgIwIAJBADYCNCACQQA2AjggAkEANgI8IAJBADYCQCADIAIpAgQ3AgBBOCEGIAMgBmogBiACQQRqaikCADcCAEEwIQcgAyAHaiAHIAJBBGpqKQIANwIAQSghCCADIAhqIAggAkEEamopAgA3AgBBICEJIAMgCWogCSACQQRqaikCADcCAEEYIQogAyAKaiAKIAJBBGpqKQIANwIAQRAhCyADIAtqIAsgAkEEamopAgA3AgBBCCEMIAMgDGogDCACQQRqaikCADcCACACKAJEIQ0gAkHQAGokgICAgAAgDQ8LfgECfyOAgICAAEEgayECIAIgADYCHCACIAE2AhggAigCHEEkaiEDAkACQCACKAIYKAIAQaQBRkEBcUUNACACQQA2AhAgAkEANgIUIAMgAikCEDcCAAwBCyACIAIoAhgoAgQ2AgggAiACKAIYKAIINgIMIAMgAikCCDcCAAsPC0MBA38jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAgghAyACKAIMIAM2AiwgAigCCCgCDCEEIAIoAgwgBDYCDA8LzgIBEn8jgICAgABBMGshBSAFJICAgIAAIAUgADYCKCAFIAE2AiQgBSACOgAjIAUgAzYCHCAFIAQ7ARoCQAJAIAUoAihBnwEQyIeAgABBAXFFDQAgBSgCKEG8AWohBkEIIQcgBiAHaigCACEIIAcgBUEIamogCDYCACAFIAYpAgA3AwggBSgCKCEJIAUoAiQhCiAFLwEaQf//A3FBAWohC0EAIQxB4gAhDSAFIAkgCiAMQQFxIAxBAXEgDSALQf//A3EQzIeAgAA2AgQgBSgCKCEOIAUoAgQhDyAFIA4gBUEIaiAPEM2HgIAANgIsDAELIAUoAighECAFKAIkIREgBS0AIyESIAUoAhwhEyAFLwEaIRRBACEVIAUgECARIBJBAXEgFUEBcSATIBRB//8DcRDMh4CAADYCLAsgBSgCLCEWIAVBMGokgICAgAAgFg8LWAECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMQRhqIAIoAggQmIaAgAAgAigCCCgCDCEDIAIoAgwgAzYCDCACQRBqJICAgIAADwttAQN/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgghAyACKAIMIAM2AjgCQCACKAIIEJaKgIAAQQBLQQFxRQ0AIAIoAggoAgwhBCACKAIMIAQ2AgwLIAJBEGokgICAgAAPC2oBBH8jgICAgABBEGshAiACIAA2AgwgAiABNgIIAkAgAigCDCgCEEEAR0EBcQ0AIAIoAggoAgghAyACKAIMIAM2AggLIAIoAggoAgwhBCACKAIMIAQ2AgwgAigCCCEFIAIoAgwgBTYCHA8LQwEDfyOAgICAAEEQayECIAIgADYCDCACIAE2AgggAigCCCEDIAIoAgwgAzYCPCACKAIIKAIMIQQgAigCDCAENgIMDwtDAQN/I4CAgIAAQRBrIQIgAiAANgIMIAIgATYCCCACKAIIKAIMIQMgAigCDCADNgIMIAIoAgghBCACKAIMIAQ2AiAPC84CAQl/I4CAgIAAQcAAayEEIAQkgICAgAAgBCAANgI8IAQgATYCOCAEIAI2AjQgBCADNgIwIAQgBCgCPEEkEJ2HgIAANgIsIAQoAiwhBSAEQTI7AQggBEEAOwEKIAQoAjwhBiAGKAIAQQFqIQcgBiAHNgIAIAQgBzYCDCAEIAQoAjgoAgQ2AhAgBCAEKAIwKAIINgIUIAQgBCgCOCgCBDYCGCAEIAQoAjgoAgg2AhwgBCAEKAI0NgIgIAQgBCgCMCgCBDYCJCAEIAQoAjAoAgg2AiggBSAEKQIINwIAQSAhCCAFIAhqIAggBEEIamooAgA2AgBBGCEJIAUgCWogCSAEQQhqaikCADcCAEEQIQogBSAKaiAKIARBCGpqKQIANwIAQQghCyAFIAtqIAsgBEEIamopAgA3AgAgBCgCLCEMIARBwABqJICAgIAAIAwPC0MBA38jgICAgABBEGshAiACIAA2AgwgAiABNgIIIAIoAggoAgwhAyACKAIMIAM2AgwgAigCCCEEIAIoAgwgBDYCJA8LdgECfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQCQCADKAIIKAIIQQBGQQFxRQ0AIAMoAgwQjoeAgAAhBCADKAIIIAQ2AggLIAMoAggoAgggAygCBBCRh4CAACADQRBqJICAgIAADwuCAQECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMQQQQm4mAgAAhAyADQQJLGgJAAkACQAJAIAMOAwABAgMLDAILIAIoAgwgAigCCEEIEKWHgIAADAELIAIoAgwgAigCCEEQEKWHgIAACyACQRBqJICAgIAADwvNAgEMfyOAgICAAEEwayEDIAMkgICAgAAgAyAANgIsIAMgATYCKCADIAI2AiQgAyADKAIsQRwQnYeAgAA2AiAgAygCICEEIANBBGohBSADQQw7AQQgA0EAOwEGIAMoAiwhBiAGKAIAQQFqIQcgBiAHNgIAIAMgBzYCCCAFQQhqIQggAyADKAIoKAIENgIMIAhBBGohCQJAAkAgAygCJEEARkEBcUUNACADKAIoKAIIIQoMAQsgAygCJCgCDCEKCyAJIAo2AgAgAyADKAIkNgIUIAMgAygCKCgCBDYCGCADIAMoAigoAgg2AhwgBCADKQIENwIAQRghCyAEIAtqIAsgA0EEamooAgA2AgBBECEMIAQgDGogDCADQQRqaikCADcCAEEIIQ0gBCANaiANIANBBGpqKQIANwIAIAMoAiAhDiADQTBqJICAgIAAIA4PC3ABAn8jgICAgABBEGshAiACJICAgIAAIAIgADYCDCACIAE2AgggAigCDEEIEJuJgIAAIQMgA0ECSxoCQAJAAkACQCADDgMAAQIDCwwCCwwBCyACKAIMIAIoAghBERClh4CAAAsgAkEQaiSAgICAAA8L6wEBBn8jgICAgABBIGshAiACJICAgIAAIAIgADYCHCACIAE2AhgCQCACKAIYKAIAQZsBRkEBcQ0AQZzshYAAQY3RhYAAQfchQfOVhYAAEI6A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hoCAACACQRBqJICAgIAADwvvAQECfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgATYCBCACKAIIIAIoAgQoAgQgAigCBCgCCBC2iICAACACIAIoAgggAigCBBCoh4CAADYCAAJAAkAgAigCCCgClAJBBGogAigCABC8h4CAAEF/R0EBcUUNAAJAIAIoAgQoAgQgAigCBCgCCElBAXFFDQAgAigCBCgCBC0AAEH/AXFB3wBHQQFxRQ0AIAIoAgggAigCBEHPARClh4CAAAsgAkEBQQFxOgAPDAELIAJBAEEBcToADwsgAi0AD0EBcSEDIAJBEGokgICAgAAgAw8LXAECfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAygCDCADKAIIKAIEIAMoAggoAgggAygCBBDsiICAACEEIANBEGokgICAgAAgBA8LkgQBDn8jgICAgABBwABrIQMgAySAgICAACADIAA2AjwgAyABNgI4IAMgAjYCNAJAIAMoAjQoAgBBpAFGQQFxDQAgAygCNCgCAEGYAUZBAXENACADKAI0KAIAQRFGQQFxDQBBwYyGgABBjdGFgABBvhNBvJaFgAAQjoCAgAAACyADIAMoAjxBJBCdh4CAADYCMCADKAIwIQQgA0EMaiEFIANBDzsBDCADQQA7AQ4gAygCPCEGIAYoAgBBAWohByAGIAc2AgAgAyAHNgIQIAVBCGohCCADIAMoAjQoAgQ2AhQgCEEEaiEJAkACQCADKAI4KAIAQaQBRkEBcUUNACADKAI0KAIIIQoMAQsgAygCOCgCCCEKCyAJIAo2AgAgAyADKAI8IAMoAjgQmoqAgAA2AhwgA0EMakEUaiELAkACQCADKAI4KAIAQaQBRkEBcUUNACALQQA2AgAgC0EANgIEDAELIAsgAygCOCgCBDYCACALIAMoAjgoAgg2AgQLIAMgAygCNCgCBDYCKCADIAMoAjQoAgg2AiwgBCADKQIMNwIAQSAhDCAEIAxqIAwgA0EMamooAgA2AgBBGCENIAQgDWogDSADQQxqaikCADcCAEEQIQ4gBCAOaiAOIANBDGpqKQIANwIAQQghDyAEIA9qIA8gA0EMamopAgA3AgAgAygCMCEQIANBwABqJICAgIAAIBAPC4kCAQF/I4CAgIAAQRBrIQEg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IAJBCGpqKQIANwIAQQghCCADIAhqIAggAkEIamopAgA3AgAgAigCJCEJIAJBMGokgICAgAAgCQ8LVAEBfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMIAIoAggQmYqAgAAgAigCDEE4aiACKAIIEJiGgIAAIAJBEGokgICAgAAPC68CAQh/I4CAgIAAQTBrIQMgAySAgICAACADIAA2AiwgAyABNgIoIAMgAjYCJCADIAMoAixBIBCdh4CAADYCICADKAIgIQQgA0HwADsBACADQQA7AQIgAygCLCEFIAUoAgBBAWohBiAFIAY2AgAgAyAGNgIEIAMgAygCKCgCBDYCCCADIAMoAiQoAgw2AgwgAyADKAIsIAMoAigoAgQgAygCKCgCCEF/ahC9h4CAADYCECADIAMoAigoAgQ2AhQgAyADKAIoKAIINgIYIAMgAygCJDYCHCAEIAMpAgA3AgBBGCEHIAQgB2ogAyAHaikCADcCAEEQIQggBCAIaiADIAhqKQIANwIAQQghCSAEIAlqIAMgCWopAgA3AgAgAygCICEKIANBMGokgICAgAAgCg8LwgMBDn8jgICAgABBwABrIQMgAySAgICAACADIAA2AjwgAyABNgI4IAMgAjYCNCADIAMoAjxBJBCdh4CAADYCMCADKAIwIQQgA0EMaiEFIANBggE7AQwgA0EAOwEOIAMoAjwhBiAGKAIAQQFqIQcgBiAHNgIAIAMgBzYCECAFQQhqIQggAyADKAI4KAIENgIUIAhBBGohCQJAAkAgAygCNCgCAEGkAUZBAXFFDQAgAygCOCgCCCEKDAELIAMoAjQoAgghCgsgCSAKNgIAIAMgAygCPCADKAI0EJqKgIAANgIcIANBDGpBFGohCwJAAkAgAygCNCgCAEGkAUZBAXFFDQAgC0EANgIAIAtBADYCBAwBCyALIAMoAjQoAgQ2AgAgCyADKAI0KAIINgIECyADIAMoAjgoAgQ2AiggAyADKAI4KAIINgIsIAQgAykCDDcCAEEgIQwgBCAMaiAMIANBDGpqKAIANgIAQRghDSAEIA1qIA0gA0EMamopAgA3AgBBECEOIAQgDmogDiADQQxqaikCADcCAEEIIQ8gBCAPaiAPIANBDGpqKQIANwIAIAMoAjAhECADQcAAaiSAgICAACAQDwtS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gIAAQQFxRQ0AIAQoAgwgBCgCACgCACAEKAIAKAIEQdoBEK2GgIAADAELIAQoAgggBCgCBBD9ioCAABoLIARBEGokgICAgAAPC6YDAQx/I4CAgIAAQdAAayEDIAMkgICAgAAgAyAANgJMIAMgATYCSCADIAI2AkQgAyADKAJMQcAAEJ2HgIAANgJAIAMoAkAhBCADQQc7AQAgA0EAOwECIAMoAkwhBSAFKAIAQQFqIQYgBSAGNgIAIAMgBjYCBCADIAMoAkgoAgQ2AgggAyADKAJEKAIINgIMIANBADYCECADQQA2AhQgA0EANgIYIANBADYCHCADQQA2AiAgA0EANgIkIANBADYCKCADQQA2AiwgAyADKAJIKAIENgIwIAMgAygCSCgCCDYCNCADIAMoAkQoAgQ2AjggAyADKAJEKAIINgI8IAQgAykCADcCAEE4IQcgBCAHaiADIAdqKQIANwIAQTAhCCAEIAhqIAMgCGopAgA3AgBBKCEJIAQgCWogAyAJaikCADcCAEEgIQogBCAKaiADIApqKQIANwIAQRghCyAEIAtqIAMgC2opAgA3AgBBECEMIAQgDGogAyAMaikCADcCAEEIIQ0gBCANaiADIA1qKQIANwIAIAMoAkAhDiADQdAAaiSAgICAACAODwtEAQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABNgIIIAIoAgxBFGogAigCCBCYhoCAACACQRBqJICAgIAADwuPAwELfyOAgICAAEHQAGshAyADJICAgIAAIAMgADYCTCADIAE2AkggAyACNgJEIAMgAygCTEE0EJ2HgIAANgJAIAMoAkAhBCADQcIAOwEMIANBADsBDiADKAJMIQUgBSgCAEEBaiEGIAUgBjYCACADIAY2AhAgAyADKAJIKAIENgIUIAMgAygCRCgCCDYCGCADQQA2AhwgA0EANgIgIANBADYCJCADQQA2AiggA0EANgIsIAMgAygCSCgCBDYCMCADIAMoAkgoAgg2AjQgAyADKAJEKAIENgI4IAMgAygCRCgCCDYCPCAEIAMpAgw3AgBBMCEHIAQgB2ogByADQQxqaigCADYCAEEoIQggBCAIaiAIIANBDGpqKQIANwIAQSAhCSAEIAlqIAkgA0EMamopAgA3AgBBGCEKIAQgCmogCiADQQxqaikCADcCAEEQ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BDYCACAIIAQoAjQoAgg2AgQLIAUgBCkCBDcCAEEgIQkgBSAJaiAJIARBBGpqKQIANwIAQRghCiAFIApqIAogBEEEamopAgA3AgBBECELIAUgC2ogCyAEQQRqaikCADcCAEEIIQwgBSAMaiAMIARBBGpqKQIANwIAIAQoAiwhDSAEQcAAaiSAgICAACANDwvHAQEDfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIIIAIgATYCBCACKAIELwEAIQMCQAJAAkACQCADQQpGDQACQCADQT5GDQAgA0HvAEYNAgwDCyACIAIoAgQoAhA2AgwMAwsgAiACKAIEKAIQNgIMDAILIAIgAigCCCACKAIEKAIIIAIoAgQoAgwQvYeAgAA2AgwMAQtBgriGgABBjdGFgABBiyNBha2FgAAQjoCAgAAACyACKAIMIQQgAkEQaiSAgICAACAEDwsnAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwoApQCLQAdQf8BcQ8L6wEBB38jgICAgABBMGshAyADJICAgIAAIAMgADYCLCADIAE2AiggAyACOgAnIAMgAygCLEEUEJ2HgIAANgIgIAMoAiAhBCADQYYBOwEMIAMgAy0AJ0H/AXE7AQ4gAygCLCEFIAUoAgBBAWohBiAFIAY2AgAgAyAGNgIQIAMgAygCKCgCCDYCFCADIAMoAigoAgw2AhggAyADKAIoNgIcIAQgAykCDDcCAEEQIQcgBCAHaiAHIANBDGpqKAIANgIAQQghCCAEIAhqIAggA0EMamopAgA3AgAgAygCICEJIANBMGokgICAgAAgCQ8L+wEBBn8jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUIAMgAygCHEG8AmogAygCFCgCABCDi4CAADYCEAJAAkAgAygCECgCBEEAS0EBcUUNACADIAMoAhAoAgRBAWs2AgwgAyADKAIMEJSMgIAANgIIIAMoAgghBCADKAIQKAIAIQUgAygCDCEGAkAgBkUNACAEIAUgBvwKAAALIAMoAhxBvAJqIAMoAgggAygCDBCJi4CAACEHIAMoAhggBzYCAAwBCyADKAIcQf+7hoAAQQAQj4eAgAAhCCADKAIYIAg2AgALIANBIGokgICAgAAPC4YHARJ/I4CAgIAAQeAAayECIAIkgICAgAAgAiAANgJcIAIgATYCWCACIAIoAlg2AlQgAiACKAJUKAIANgJQIAIgAigCVCgCBDYCTCACIAIoAlRBDGo2AkggAiACKAJcEKiLgIAANgJEIAIgAigCXBCni4CAADYCQCACQThqQQA2AgAgAkIANwMwIAIoAkQhAyACKAJAIQQgAigCUC0AgwMhBSACKAJQKAKgAiEGIAIgA0HcACAEIAVBAXEgBhCci4CAADYCLAJAIAIoAixBAEdBf3NBf3NBAXFFDQAgAigCUCEHIAIoAkQhCCACKAJAIQkgAigCLCEKIAcgAkEwaiAIIAkgChCqioCAACACIAJBMGoQ2oqAgAA2AkQgAiACQTBqENuKgIAANgJACwJAAkAgAigCUCACKAJEIAIoAkQgAigCQGoQlIqAgABBAXENACACQTBqEOeKgIAADAELAkACQCACKAJULQAYQQFxRQ0AIAIgAigCRDYCFCACIAIoAkQgAigCQGo2AhggAiACKQIUNwMgIAIgAigCUCACKAIgIAIoAiQQvYeAgAA2AhwMAQsgAiACKAJMKAIQKAIINgIMIAIgAigCTCgCECgCDDYCECACIAIpAgw3AyAgAiACKAJAEJSMgIAANgIIAkAgAigCCEEARkEBcUUNABC6i4CAAAALIAIoAgghCyACKAJEIQwgAigCQCENAkAgDUUNACALIAwgDfwKAAALIAIgAigCUCACKAIIIAIoAkAQroaAgAA2AhwLAkAgAigCHEUNACACKAJIIAIoAhwQ/4qAgABBAXENACACKAJIIAIoAhwQ/YqAgAAaIAIoAlAgAigCHBCph4CAACEOIAIgDjYCBAJAIA5Bf0ZBAXFFDQACQCACKAJEIAIoAkAQq4qAgABBAXFFDQAgAkEwahDnioCAAAwDCyACKAJQIAIoAhwgAigCICACKAIkQQAQr4aAgAALAkAgAigCVCgCCEEARkEBcUUNACACKAJQIAIoAkwQrIqAgAAhDyACKAJUIA82AggLIAIoAlAhECACKAIcIRECQAJAIAIoAgRBf0ZBAXFFDQBBACESDAELIAIoAgQhEgsgEiETIAIgECACQSBqIBEgExDkiYCAADYCACACKAJUKAIIQRRqIAIoAgAQmIaAgAALIAJBMGoQ54qAgAALIAJB4ABqJICAgIAADwvzAQECfyOAgICAAEEgayECIAIkgICA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AQZB//8DcRC4ioCAACEIQQAhCSAIQQFxIQogCSELAkAgCkUNACACKAIIELeKgIAAIQsLIAIgC0EBcToADwwFCyACKAIIIQwgDCAMKAIIQQFqNgIIIAIoAgggAi8BBkH//wNxELmKgIAAIQ1BACEOIA1BAXEhDyAOIRACQCAPRQ0AIAIoAggQt4qAgAAhEAsgAiAQQQFxOgAPDAQLIAIoAgghESARIBEoAghBAWo2AgggAigCCCACKAIIKAIIQX9qIAIoAggoAghBosuFgAAQtYqAgAAgAkEBQQFxOgAPDAMLIAIoAgghEiASIBIoAghBAWo2AgggAigCCCACKAIIKAIIQX9qIAIoAggoAghBhLqEgAAQtYqAgAAgAkEBQQFxOgAPDAILAkAgAigCCC0AEEEBcUUNAAJAIAIoAghBCkH/AXEQuoqAgABBAXENACACKAIIKAIMIRMgAigCCCATNgIICyACQQFBAXE6AA8MAgsLAkACQCACKAIILQARQQFxDQAgAiACKAIIKAIIIAIoAggoAgwgAigCCCgCCGsQzISAgAA2AgAMAQsgAigCCCgCFCgCACEUIAIgAigCCCgCCCACKAIIKAIMIAIoAggoAghrIBQRgICAgACAgICAADYCAAsCQCACKAIADQAgAkEAQQFxOgAPDAELIAIoAgAhFSACKAIIIRYgFiAVIBYoAghqNgIIIAIgAigCCBC3ioCAAEEBcToADwsgAi0AD0EBcSEXIAJBEGokgICAgAAgFw8L6gEBBX8jgICAgABBEGshASABJICAgIAAIAEgADYCCAJAAkADQCABKAIIELKKgIAAQX9zQQFxRQ0BIAEoAggoAggtAAAhAgJAAkACQAJAIAJBVmpBAkkNACACQT9GDQAgAkH7AEYNAQwCCyABKAIIIQMgAyADKAIIQQFqNgIIDAILIAEoAgghBCAEIAQoAghBAWo2AggCQCABKAIIELuKgIAAQQFxDQAgAUEAQQFxOgAPDAULDAELIAFBAUEBcToADwwDCwwACwsgAUEBQQFxOgAPCyABLQAPQQFxIQUgAUEQaiSAgICAACAFDwvjEwE+fyOAgICAAEHAAGshAiACJICAgIAAIAIgADYCOCACIAE7ATYgAiACKAI4KAIINgIwIAJBGGoQvIqAgAACQAJAIAIoAjhBP0H/AXEQtIqAgABBAXFFDQACQCACKAI4ELKKgIAAQQFxRQ0AIAIoAjggAigCMCACKAI4KAIIQeLZhIAAELWKgIAAIAJBAEEBcToAPwwCCyACKAI4KAIILQAAQV9qIQMgA0HdAEsaAkACQAJAAkACQAJAAkACQAJAIAMOXgEHAAcHBwMEBwcHBwYHBwcHBwcHBwcHBwcBBwIBAQcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcFBwcFBwcHBwUHBwcFBwcHBwcHBwUHBwUHBwcHBwEHCyACKAI4IQQgBCAEKAIIQQFqNgIIAkAgAigCOBCyioCAAEEBcUUNACACKAI4IAIoAjAgAigCOCgCCEHi2YSAABC1ioCAACACQQBBAXE6AD8MCgsCQCACKAI4LQARQQFxRQ0AIAIoAjgoAhQtABRBAXFFDQAgAkEAOgAXAkADQCACKAI4KAIIIAIoAjgoAgxJQQFxRQ0BAkAgAi0AF0EBcQ0AIAIoAjgoAggtAABB/wFxQSlGQQFxRQ0AIAIoAjghBSAFIAUoAghBAWo2AgggAkEBQQFxOgA/DA0LIAIoAjgoAhQoAgAhBiACIAIoAjgoAgggAigCOCgCDCACKAI4KAIIayAGEYCAgIAAgICAgAA2AhACQCACKAIQDQAgAkEAQQFxOgA/DA0LIAIoAhBBAUYhB0EAIQggB0EBcSEJIAghCgJAIAlFDQAgAigCOCgCCC0AAEH/AXFB3ABGIQoLIAIgCkEBcToAFyACKAIQIQsgAigCOCEMIAwgCyAMKAIIajYCCAwACwsgAkEAQQFxOgA/DAoLIAIgAigCOEEpQf8BcRC6ioCAAEEBcToADwNAIAItAA8hDUEAIQ4gDUEBcSEPIA4hEAJAIA9FDQAgAigCOCgCBCACKAI4KAIIQX5qTSERQQAhEiARQQFxIRMgEiEQIBNFDQAgAigCOCgCCEF+ai0AAEH/AXFB3ABGIRALAkAgEEEBcUUNACACIAIoAjhBKUH/AXEQuoqAgABBAXE6AA8MAQsLIAIgAi0AD0EBcToAPwwJCyACKAI4IRQgFCAUKAIIQQFqNgIIDAYLIAIoAjghFSAVIBUoAghBAWo2AggCQCACKAI4ELKKgIAAQQFxRQ0AIAIoAjggAigCMCACKAI4KAIIQaC6hIAAELWKgIAAIAJBAEEBcToAPwwICyACKAI4KAIILQAAIRYCQAJAAkAgFkEhRg0AIBZBPUcNAQsgAigCOCEXIBcgFygCCEEBajYCCAwBCyACIAIoAjgoAgg2AggCQCACKAI4QT5B/wFxELqKgIAAQQFxDQAgAkEAQQFxOgA/DAkLAkAgAigCOCgCCCACKAIIa0EBRkEBcUUNACACKAI4IAIoAgggAigCOCgCCEGRgISAABC1ioCAAAsCQCACKAI4KAIYQQBHQQFxRQ0AIAIoAjggAigCCCACKAI4KAIIQX9qEL2KgIAACwsMBQsgAigCOCEYIBgoAghBAWohGSAYIBk2AgggAiAZNgIEAkAgAigCOEEnQf8BcRC6ioCAAEEBcQ0AIAJBAEEBcToAPwwHCwJAIAIoAjgoAhhBAEdBAXFFDQAgAigCOCACKAIEIAIoAjgoAghBf2oQvYqAgAALDAQLAkAgAigCOEEpQf8BcRC6ioCAAEEBcQ0AIAJBAEEBcToAPwwGCwwDCwNAIAIoAjgQsoqAgAAhGkEAIRsgGkEBcSEcIBshHQJAIBwNACACKAI4KAIILQAAQf8BcUEtRyEeQQAhHyAeQQFxISAgHyEdICBFDQAgAigCOCgCCC0AAEH/AXFBOkchIUEAISIgIUEBcSEjICIhHSAjRQ0AIAIoAjgoAggtAABB/wFxQSlHIR0LAkAgHUEBcUUNACACKAI4KAIILQAAISQCQCACQRhqICRB/wFxEL6KgIAAQQFxDQAgAkEAQQFxOgA/DAcLIAIoAjghJSAlICUoAghBAWo2AggMAQsLAkAgAigCOBCyioCAAEEBcUUNACACQQBBAXE6AD8MBQsCQCACKAI4KAIILQAAQf8BcUEpRkEBcUUNAAJAIAJBGGpB+ABB/wFxEL+KgIAAQf8BcUEDRkEBcUUNACACKAI4QQE6ABALIAIoAjghJiAmICYoAghBAWo2AgggAkEBQQFxOgA/DAULAkAgAigCOCgCCC0AAEH/AXFBLUdBAXFFDQAMAwsLIAIoAjghJyAnICcoAghBAWo2AggDQCACKAI4ELKKgIAAIShBACEpIChBAXEhKiApISsCQCAqDQAgAigCOCgCCC0AAEH/AXFBOkchLEEAIS0gLEEBcSEuIC0hKyAuRQ0AIAIoAjgoAggtAABB/wFxQSlHISsLAkAgK0EBcUUNACACKAI4KAIILQAAIS8CQCACQRhqIC9B/wFxEMCKgIAAQQFxDQAgAkEAQQFxOgA/DAYLIAIoAjghMCAwIDAoAghBAWo2AggMAQsLAkAgAigCOBCyioCAAEEBcUUNACACQQBBAXE6AD8MBAsCQCACKAI4KAIILQAAQf8BcUEpRkEBcUUNAEH4ACExIAJBGGogMRC/ioCAAEF9aiEyIDJBAUsaAkACQAJAIDIOAgABAgsgAigCOEEBOgAQDAELIAIoAjhBADoAEAsgAigCOCEzIDMgMygCCEEBajYCCCACQQFBAXE6AD8MBAsMAQsgAigCOCE0IDQgNCgCCEEBajYCCCACKAI4IAIoAjgoAghBf2ogAigCOCgCCEGr4ISAABC1ioCAAAsLIAIoAjgtABAhNUEBITYgAiA1IDZxOgADQfgAITcgAkEYaiA3EL+KgIAAQX1qITggOCA2SxoCQAJAAkAgOA4CAAECCyACKAI4QQE6ABAMAQsgAigCOEEAOgAQCwNAIAIoAjgQsoqAgAAhOUEAITogOUEBcSE7IDohPAJAIDsNACACKAI4KAIILQAAQf8BcUEpRyE8CwJAIDxBAXFFDQACQCACKAI4IAIvATZB//8DcUEBakH//wNxELOKgIAAQQFxDQAgAi0AAyE9IAIoAjggPUEBcToAECACQQBBAXE6AD8MAwsgAigCOEH8AEH/AXEQtIqAgAAaDAELCyACLQADIT4gAigCOCA+QQFxOgAQAkAgAigCOEEpQf8BcRDBioCAAEEBcUUNACACQQFBAXE6AD8MAQsgAigCOCACKAIwIAIoAjgoAghBoLqEgAAQtYqAgAAgAkEAQQFxOgA/CyACLQA/QQFxIT8gAkHAAGokgICAgAAgPw8LuAMBBX8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE7AQYCQAJAIAIvAQZB//8DcUGAIE5BAXFFDQAgAigCCCACKAIIKAIEIAIoAggoAgxBzcuEgAAQtYqAgAAgAkEAQQFxOgAPDAELAkAgAigCCCgCCCACKAIIKAIMSUEBcUUNACACKAIIKAIILQAAQf8BcUHdAEZBAXFFDQAgAigCCCEDIAMgAygCCEEBajYCCCACKAIIIAIoAggoAghBf2ogAigCCCgCCEH3sYSAABC1ioCAACACQQFBAXE6AA8MAQsgAiACKAIIKAIINgIAAkAgAigCCCgCCEECaiACKAIIKAIMSUEBcUUNACACKAIIKAIILQAAQf8BcUHbAEZBAXFFDQAgAigCCCgCCC0AAUH/AXFBOkZBAXFFDQAgAigCCCEEIAQgBCgCCEEBajYCCAJAIAIoAggQwoqAgABBAXFFDQAgAkEBQQFxOgAPDAILIAIoAgAhBSACKAIIIAU2AggLIAIgAigCCCACLwEGQf//A3EQw4qAgABBAXE6AA8LIAItAA9BAXEhBiACQRBqJICAgIAAIAYPC+8BAQh/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgggAiABOgAHAkACQCACKAIIELKKgIAAQQFxRQ0AIAJBAEEBcToADwwBCyACKAIIKAIIIQMgAi0AB0H/AXEhBCACKAIIKAIMIAIoAggoAghrIQUgAigCCC0AESEGIAIoAggoAhQhByACIAMgBCAFIAZBAXEgBxCci4CAADYCAAJAIAIoAgBBAEZBAXFFDQAgAkEAQQFxOgAPDAELIAIoAgBBAWohCCACKAIIIAg2AgggAkEBQQFxOgAPCyACLQAPQQFxIQkgAkEQaiSAgICAACAJDwuyBgESfyOAgICAAEEQayEBIAEgADYCCCABIAEoAggoAgg2AgQgAUEANgIAAkADQAJAIAEoAggoAgggASgCCCgCDE9BAXFFDQAgASgCBCECIAEoAgggAjYCCCABQQFBAXE6AA8MAgsgASgCACEDIANBA0saAkACQAJAAkACQCADDgQAAQMCBAsgASgCCCgCCC0AAEFUaiEEIARBDUsaAkACQAJAAkAgBA4OAQICAgAAAAAAAAAAAAACCyABKAIIIQUgBSAFKAIIQQFqNgIIIAFBATYCAAwCCyABKAIIIQYgBiAGKAIIQQFqNgIIIAFBAzYCAAwBCyABKAIEIQcgASgCCCAHNgIIIAFBAUEBcToADwwGCwwDCyABKAIIKAIILQAAQVRqIQggCEHRAEsaAkACQAJAAkACQCAIDlIBAwMDAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCAwsgASgCCCEJIAkgCSgCCEEBajYCCAwDCyABKAIIIQogCiAKKAIIQQFqNgIIIAFBAjYCAAwCCyABKAIIIQsgCyALKAIIQQFqNgIIIAFBAUEBcToADwwGCyABKAIEIQwgASgCCCAMNgIIIAFBAUEBcToADwwFCwwCCwJAAkAgASgCCCgCCC0AAEFQakEJSw0AIAEoAgghDSANIA0oAghBAWo2AgggAUECNgIADAELIAEoAgQhDiABKAIIIA42AgggAUEBQQFxOgAPDAQLDAELIAEoAggoAggtAABBUGohDyAPQc0ASxoCQAJAAkACQCAPDk4AAAAAAAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgECCyABKAIIIRAgECAQKAIIQQFqNgIIDAILIAEoAgghESARIBEoAghBAWo2AgggAUEBQQFxOgAPDAQLIAEoAgQhEiABKAIIIBI2AgggAUEBQQFxOgAPDAMLCwwACwsgAS0AD0EBcQ8LewICfwF+I4CAgIAAQRBrIQEgASAANgIMIAEoAgwhAkIAIQMgAiADNwAAIAJBEGogAzcAACACQQhqIAM3AAAgASgCDEEBOgAIIAEoAgxBAToADCABKAIMQQE6ABcgASgCDEECOgADIAEoAgxBAjoAACABKAIMQQI6ABQPC4gBAQV/I4CAgIAAQSBrIQMgAySAgICAACADIAA2AhwgAyABNgIYIAMgAjYCFCADKAIYIQQgAygCFCEFIANBCGogBCAFEKOLgIAAIAMoAhwoAhghBiADKAIcKAIcIQcgA0EIaiAHIAYRgoCAgACAgICAACADQQhqEKqLgIAAIANBIGokgICAgAAPC84BAQJ/I4CAgIAAQRBrIQIgAiAANgIIIAIgAToABwJAAkAgAi0AB0H/AXFB4QBOQQFxRQ0AIAItAAdB/wFxQfgATEEBcUUNACACIAItAAdBn39qOgAHIAIoAgggAi0AB2otAAAhAyADQQRLGgJAAkACQAJAIAMOBQABAQIAAwsgAkEAQQFxOgAPDAQLIAIoAgggAi0AB0H/AXFqQQM6AAAgAkEBQQFxOgAPDAMLIAJBAUEBcToADwwCCwsgAkEAQQFxOgAPCyACLQAPQQFxDwuFAQEBfyOAgICAAEEQayECIAIgADYCCCACIAE6AAcCQAJAIAItAAdB/wFxQeEATkEBcUUNACACLQAHQf8BcUH4AExBAXFFDQAgAiACLQAHQf8B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DAQLIAIgAigCNEEQajYCDCACIAIoAgwQqIuAgAAgAigCDBCni4CAAEEAdBDWioCAADYCPAwDCyACIAIoAjRBKGo2AgggAiACKAIIEKiLgIAAIAIoAggQp4uAgABBAHQQ1oqAgAAgAigCNC8BAkH//wNxENeKgIAAczYCPAwCCyACIAIoAjRBKGo2AgQgAiACKAIEEKiLgIAAIAIoAgQQp4uAgABBAHQQ1oqAgAAgAigCNC8BAkH//wNxENeKgIAAczYCPAwBC0GCuIaAAEGRzoWAAEGRAUHPhYWAABCOgICAAAALIAIoAjwhByACQcAAaiSAgICAACAHDwvQAgQDfwJ+A38BfiOAgICAAEEwayECIAIkgICAgAAgAiAANgIkIAIgATYCICACKAIgLwEAIQMCQAJAAkACQCADQdIARg0AIANBigFGDQEMAgsgAiACKAIgQRBqNgIcAkAgAigCHCgCBEEAR0EBcUUNACACKAIcLQAMIQQgAkKAgICAgICAgIB/Qv///////////wAgBEEBcRs3AygMAwsgAiACKAIcKAIIrTcDEAJAAkAgAigCHC0ADEEBcUUNACACKQMQIQVCACAFfSEGDAELIAIpAxAhBgsgAiAGNwMoDAILIAIoAiQoAgAhByACKAIgKAIIIQggAigCJCgCBCEJIAJBCGogByAIIAkQoYuAgAAgAiACKAIIrDcDKAwBC0GCuIaAAEGRzoWAAEH1AUHYj4WAABCOgICAAAALIAIpAyghCiACQTBqJICAgIAAIAoPC6sBAQN/I4CAgIAAQRBrIQEgASSAgICAACABIAA2AgggASgCCC8BAEH3fmohAiACQQZLGgJAAkACQAJAAkAgAg4HAQMDAwADAgMLIAEgASgCCEEoajYCDAwDCyABIAEoAghBEGo2AgwMAgsgASABKAIIQShqNgIMDAELQYK4hoAAQZHOhYAAQcECQciPhYAAEI6AgIAAAAsgASgCDCEDIAFBEGokgICAgAAgAw8LewEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwQz4qAgAAgASgCDEEMahDPioCAACABKAIMQRhqEM+KgIAAIAEoAgxBJGoQz4qAgAAgASgCDEEwahDPioCAACABKAIMQTxqEM+KgIAAIAFBEGokgICAgAAPC0wBAX8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAIAEoAgwoAghBAEtBAXFFDQAgASgCDCgCABCWjICAAAsgAUEQaiSAgICAAA8LfgEDfyOAgICAAEEgayEFIAUkgICAgAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSADNgIQIAUgBDYCDCAFKAIcIQYgBSAFKAIYNgIAIAUgBSgCFDYCBCAFIAUoAhA2AgggBSgCDCEHIAYgBSAHENGKgIAAIAVBIGokgICAgAAPC7ENBAJ/AXwBfg1/I4CAgIAAQYABayEDIAMkgICAgAAgAyAANgJ8IAMgATYCeCADIAI2AnQgAygCdC8BAEFNaiEEIARB3QBLGgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAEDl4ADQ0BDQ0NDQ0NDQ0NDQ0NDQINDQ0NDQ0NDQ0NDQ0NAw0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0EDQ0NDQ0NDQ0NDQ0NDQ0FDQYNDQ0NDQ0NDQ0NBwgJDQ0KDQsMDQsgAygCfEGDqIWAAEEFEN+KgIAADA0LIAMgAygCdCsDEDkDaAJAAkACQAJAQQBBAXFFDQAgAysDaLYQ0oqAgABB/////wdxQYCAgPwHRkEBcQ0BDAILAkBBAUEBcUUNACADKwNoENOKgIAAQv///////////wCDQoCAgICAgID4/wBRQQFxDQEMAgsgAysDaCEFIANBEGogBRCljICAACADKQMYIQYgAykDECAGELmLgIAAQQFGQQFxRQ0BCwJAIAMoAnQoAggtAABB/wFxQS1GQQFxRQ0AIAMoAnxBLUH/AXEQ4oqAgAALIAMoAnxBroCEgABBCBDfioCAAAwBCwJAAkAgAysDaEEAt2FBAXFFDQACQCADKAJ0KAIILQAAQf8BcUEtRkEBcUUNACADKAJ8QS1B/wFxEOKKgIAACyADKAJ8QfaehoAAQQMQ34qAgAAMAQsgAygCfCEHIAMgAysDaDkDACAHQbuMhYAAIAMQ3oqAgAAgAygCfCEIQS4hCUEYIQoCQCAIIAkgCnQgCnUQ5YqAgABBf0ZBAXFFDQAgAygCfCELQeUAIQxBGCENIAMgCyAMIA10IA11EOWKgIAANgJkAkACQCADKAJkQX9GQQFxRQ0AIAMoAnwQ24qAgAAhDgwBCyADKAJkIQ4LIAMgDjYCYCADKAJ8IAMoAmBB956GgABBAhDmioCAAAsLCwwMCyADIAMoAnQoAhA2AlwgAygCfEH6noaAAEECEN+KgIAAAkAgAygCXBDUioCAAEEBcUUNACADKAJ8QStB/wFxEOKKgIAACyADKAJ8IAMoAnggAygCXBDRioCAAAJAIAMoAlwvAQBB//8DcUH7AEZBAXFFDQAgAygCfEEqQf8BcRDiioCAAAsgAygCfEHwpoaAAEECEN+KgIAADAsLIAMoAnwgAygCdEEQahCTi4CAAAwKCyADKAJ8Qdj2hIAAQQMQ34qAgAAMCQsgAyADKAJ0NgJYIAMoAnxBKEH/AXEQ4oqAgAAgAygCfCADKAJYQRBqEJOLgIAAIAMoAnxBL0H/AXEQ4oqAgAAgAygCfCADKAJYQSBqEJOLgIAAIAMoAnxBKUH/AXEQ4oqAgAAMCAsgAyADKAJ0QShqNgJUIAMoAnxBL0H/AXEQ4oqAgAAgAygCfCADKAJUEKiLgIAAIAMoAlQQp4uAgABBABDkioCAACADKAJ8QS9B/wFxEOKKgIAAAkAgAygCdC8BAkH//wNxQRBxRQ0AIAMoAnxBv/OEgABBARDfioCAAAsCQCADKAJ0LwECQf//A3FBBHFFDQAgAygCfEGjhIWAAEEBEN+KgIAACwJAIAMoAnQvAQJB//8DcUEIcUUNACADKAJ8Qd2IhIAAQQEQ34qAgAALAkAgAygCdC8BAkH//wNxQYABcUUNACADKAJ8QfLvhIAAQQEQ34qAgAALDAcLIAMoAnwhDyADIAMoAngoAgg2AiAgD0HSk4aAACADQSBqEN6KgIAADAYLIAMgAygCdEEQajYCUCADKAJ8QSJB/wFxEOKKgIAAIAMoAnwgAygCUBCoi4CAACADKAJQEKeLgIAAQQAQ5IqAgAAgAygCfEEiQf8BcRDiioCAAAwFCyADKAJ8IRAgAygCeCgCACERIAMoAnQoAgghEiADKAJ4KAIEIRMgA0HIAGogESASIBMQoYuAgAAgAyADKAJINgIwIBBBvMyFgAAgA0EwahDeioCAAAwECyADIAMoAnRBKGo2AkQgAygCfEEiQf8BcRDiioCAACADKAJ8IAMoAkQQqIuAgAAgAygCRBCni4CAAEEAEOSKgIAAIAMoAnxBIkH/AXEQ4oqAgAAMAwsgAyADKAJ0QShqNgJAIAMoAnxBOkH/AXEQ4oqAgAAgAygCfCADKAJAEKiLgIAAIAMoAkAQp4uAgABBABDkioCAAAwCCyADKAJ8Qe2OhYAAQQQQ34qAgAAMAQtBgriGgABBkc6FgABB1gRB07iFgAAQjoCAgAAACyADQYABaiSAgICAAA8LJgEBfyOAgICAAEEQayEBIAEgADgCDCABIAEqAgw4AgggASgCCA8LJgEBfyOAgICAAEEQayEBIAEgADkDCCABIAErAwg5AwAgASkDAA8L5wEBA38jgICAgABBEGshASABJICAgIAAIAEgADYCCCABKAIILwEAIQICQAJAAkACQAJAAkAgAkE2Rg0AIAJBxABGDQMgAkHSAEYNASACQfsARg0CDAQLIAEgASgCCCsDEEEAt2RBAXE6AA8MBAsgASABKAIILQAcQX9zQQFxOgAPDAMLIAEgASgCCC0AHEF/c0EBcToADwwCCyABIAEoAggoAhAQ1IqAgABBAXE6AA8MAQtBgriGgABBkc6FgABB5wNB+duEgAAQjoCAgAAACyABLQAPQQFxIQMgAUEQaiSAgICAACADDwujAQECfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMAkACQCABKAIMKAIEQQBHQQFxRQ0AIAEgASgCDCgCBCABKAIMKAIAQQJ0ENaKgIAANgIIDAELIAEgASgCDEEIakEEENaKgIAANgIICwJAIAEoAgwtAAxBAXFFDQAgAUEBENeKgIAAIAEoAghzNgIICyABKAIIIQIgAUEQaiSAgICAACACDwuoAwECfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIcIAIgATYCGCACQYzlnrp5NgIUIAIgAigCGEECdjYCDAJAA0AgAigCDEUNASACIAIoAhwoAAA2AhAgAiACKAIcQQRqNgIcIAIgAigCEBDXioCAACACKAIUczYCFCACIAIoAhRBDXQgAigCFEETdnI2AhQgAiACKAIUQQVsQeTW0bJ+ajYCFCACIAIoAgxBf2o2AgwMAAsLIAJBADYCECACIAIoAhhBA3E2AggCQANAIAIoAghFDQEgAiACKAIQQQh0NgIQIAIgAigCHCACKAIIQQFrai0AAEH/AXEgAigCEHI2AhAgAiACKAIIQX9qNgIIDAALCyACIAIoAhAQ14qAgAAgAigCFHM2AhQgAiACKAIYIAIoAhRzNgIUIAIgAigCFEEQdiACKAIUczYCFCACIAIoAhRB65Svr3hsNgIUIAIgAigCFEENdiACKAIUczYCFCACIAIoAhRBtdzKlXxsNgIUIAIgAigCFEEQdiACKAIUczYCFCACKAIUIQMgAkEgaiSAgICAACADDwtUAQF/I4CAgIAAQRBrIQEgASAANgIMIAEgASgCDEHR2vjkfGw2AgwgASABKAIMQQ90IAEoAgxBEXZyNgIMIAEgASgCDEGT65zcAWw2AgwgASgCDA8LvBcBA38jgICAgABBEGshASABJICAgIAAIAEgADYCCCABKAIIQX9qIQIgAkGkAUsaAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDqUBAA4aJEZISUpMUVheZXh8jQEDBAUGBwgJCgsMDQ8QERITFBUWFxgZGxwdHh8gISIjJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFR0tNTk9QUlNUVVZXWVpbXF1fYGFiY2RmZ2hpamtsbW5vcHFyc3R1dnd5ent9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBAQKkAaUBCyABQbWLhIAANgIMDKUBCyABQbPuhIAANgIMDKQBCyABQdLuhIAANgIMDKMBCyABQfG1hoAANgIMDKIBCyABQfW1hoAANgIMDKEBCyABQZu1hoAANgIMDKABCyABQc+1hoAANgIMDJ8BCyABQZa1hoAANgIMDJ4BCyABQc6zhoAANgIMDJ0BCyABQY27hYAANgIMDJwBCyABQYK2hoAANgIMDJsBCyABQaa1hoAANgIMDJoBCyABQeGvhoAANgIMDJkBCyABQfOvhoAANgIMDJgBCyABQeavhoAANgIMDJcBCyABQY60hoAANgIMDJYBCyABQY60hoAANgIMDJUBCyABQYW0hoAANgIMDJQBCyABQd20hoAANgIMDJMBCyABQYq0hoAANgIMDJIBCyABQYG0hoAANgIMDJEBCyABQdi0hoAANgIMDJABCyABQe/4hIAANgIMDI8BCyABQfS0hYAANgIMDI4BCyABQbi1hoAANgIMDI0BCyABQbO1hoAANgIMDIwBCyABQdi1hoAANgIMDIsBCyABQbyXhIAANgIMDIoBCyABQcCihIAANgIMDIkBCyABQcu1hoAANgIMDIgBCyABQdykhoAANgIMDIcBCyABQdukhoAANgIMDIYBCyABQbuxhoAANgIMDIUBCyABQbOzhoAANgIMDIQBCyABQcGshYAANgIMDIMBCyABQfevhoAANgIMDIIBCyABQeavhoAANgIMDIEBCyABQf61hoAANgIMDIABCyABQZK1hoAANgIMDH8LIAFB7rSGgAA2AgwMfgsgAUHotIaAADYCDAx9CyABQb+0hoAANgIMDHwLIAFB2K+GgAA2AgwMewsgAUH0qYSAADYCDAx6CyABQc+BhIAANgIMDHkLIAFBpfuEgAA2AgwMeAsgAUHPgYSAADYCDAx3CyABQbq2hYAANgIMDHYLIAFBybSGgAA2AgwMdQsgAUHjtIaAADYCDAx0CyABQbeVhoAANgIMDHMLIAFB25WGgAA2AgwMcgsgAUHdi4WAADYCDAxxCyABQbyJhYAANgIMDHALIAFBk76FgAA2AgwMbwsgAUGfq4WAADYCDAxuCyABQYC3hYAANgIMDG0LIAFBqNWEgAA2AgwMbAsgAUHPgYSAADYCDAxrCyABQaX7hIAANgIMDGoLIAFBz4GEgAA2AgwMaQsgAUGssIaAADYCDAxoCyABQcCzhoAANgIMDGcLIAFBxLGGgAA2AgwMZgsgAUGXtIaAADYCDAxlCyABQcSyhoAANgIMDGQLIAFBkrOGgAA2AgwMYwsgAUGksIaAADYCDAxiCyABQe2yhoAANgIMDGELIAFBqrSGgAA2AgwMYAsgAUGtsYaAADYCDAxfCyABQa2xhoAANgIMDF4LIAFBg7OGgAA2AgwMXQsgAUHYsoaAADYCDAxcCyABQbqzhoAANgIMDFsLIAFBpLSGgAA2AgwMWgsgAUGZs4aAADYCDAxZCyABQYqzhoAANgIMDFgLIAFBk7GGgAA2AgwMVwsgAUHgsoaAADYCDAxWCyABQeCyhoAANgIMDFULIAFBzLGGgAA2AgwMVAsgAUGis4aAADYCDAxTCyABQY6whoAANgIMDFILIAFBvrKGgAA2AgwMUQsgAUGVsIaAADYCDAxQCyABQZmxhoAANgIMDE8LIAFBprGGgAA2AgwMTgsgAUH6soaAADYCDAxNCyABQfjUhIAANgIMDEwLIAFB/K+GgAA2AgwMSwsgAUGysYaAADYCDAxKCyABQdGyhoAANgIMDEkLIAFBnrGGgAA2AgwMSAsgAUHYsYaAADYCDAxHCyABQfOyhoAANgIMDEYLIAFB5bKGgAA2AgwMRQsgAUGbsIaAADYCDAxECyABQZuwhoAANgIMDEMLIAFBtrKGgAA2AgwMQgsgAUG2soaAADYCDAxBCyABQdGxhoAANgIMDEALIAFBq7OGgAA2AgwMPwsgAUGrs4aAADYCDAw+CyABQcazhoAANgIMDD0LIAFB0rOGgAA2AgwMPAsgAUHss4aAADYCDAw7CyABQeGzhoAANgIMDDoLIAFB+feEgAA2AgwMOQsgAUHiyoSAADYCDAw4CyABQfOvhoAANgIMDDcLIAFBq7WGgAA2AgwMNgsgAUHztIaAADYCDAw1CyABQbm0hoAANgIMDDQLIAFBz5aGgAA2AgwMMwsgAUHCloaAADYCDAwyCyABQY+yhYAANgIMDDELIAFB1LWGgAA2AgwMMAsgAUH9tIaAADYCDAwvCyABQcS0hoAANgIMDC4LIAFBp6uFgAA2AgwMLQsgAUGcu4WAADYCDAwsCyABQe21hoAANgIMDCsLIAFB7bWGgAA2AgwMKgsgAUHptYaAADYCDAwpCyABQfq1hoAANgIMDCgLIAFBobWGgAA2AgwMJwsgAUHMsoaAADYCDAwmCyABQYmwhoAANgIMDCULIAFBhLCGgAA2AgwMJAsgAUGftIaAADYCDAwjCyABQZK0hoAANgIMDCILIAFB76+GgAA2AgwMIQsgAUHTtIaAADYCDAwgCyABQeqvhoAANgIMDB8LIAFBzbSGgAA2AgwMHgsgAUHctYaAADYCDAwdCyABQYK1hoAANgIMDBwLIAFBtbSGgAA2AgwMGwsgAUGfiYWAADYCDAwaCyABQbWLhYAANgIMDBkLIAFBr7WGgAA2AgwMGAsgAUG8tYaAADYCDAwXCyABQfi0hoAANgIMDBYLIAFB5bWGgAA2AgwMFQsgAUGNtYaAADYCDAwUCyABQeC1hoAANgIMDBMLIAFBh7WGgAA2AgwMEgsgAUG2+oSAADYCDAwRCyABQceQhIAANgIMDBALIAFBz4uFgAA2AgwMDwsgAUGQ+YSAADYCDAwOCyABQd2vhoAANgIMDA0LIAFB8bWGgAA2AgwMDAsgAUGztYaAADYCDAwLCyABQca1hoAANgIMDAoLIAFBwLWGgAA2AgwMCQsgAUHUtYaAADYCDAwICyABQdS1hoAANgIMDAcLIAFB3LWGgAA2AgwMBgsgAUGcpoaAADYCDAwFCyABQZumhoAANgIMDAQLIAFB0cqEgAA2AgwMAwsgAUH3s4aAADYCDAwCC0GCuIaAAEH81YWAAEG3BUGx74SAABCOgICAAAALQYK4hoAAQfzVhYAAQb0FQbHvhIAAEI6AgIAAAAsgASgCDCEDIAFBEGokgICAgAAgAw8LdQEEfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACKAIMQQA2AgAgAigCCCEDIAIoAgwgAzYCBCACKAIIEJSMgIAAIQQgAigCDCAENgIIIAIoAgwoAghBAEdBAXEhBSACQRBqJICAgIAAIAUPCx8BAX8jgICAgABBEGshASABIAA2AgwgASgCDCgCCA8LHwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMKAIADwuDAQEEfyOAgICAAEEQayECIAIkgICAgAAgAiAANgIMIAIgATYCCCACIAIoAgwoAgA2AgQCQCACKAIMIAIoAggQ3YqAgABBAXFFDQAgAigCDCgCCCACKAIEaiEDIAIoAgghBEEAIQUCQCAERQ0AIAMgBSAE/AsACwsgAkEQaiSAgICAAA8LjgIBBX8jgICAgABBEGshAiACJICAgIAAIAIgADYCCCACIAE2AgQgAiACKAIIKAIAIAIoAgRqNgIAAkACQCACKAIAIAIoAggoAgRLQQFxRQ0AAkAgAigCCCgCBA0AIAIoAghBATYCBAsCQANAIAIoAgAgAigCCCgCBEtBAXFFDQEgAigCCCEDIAMgAygCBEEBdDYCBAwACwsgAigCCCgCCCACKAIIKAIEEJeMgIAAIQQgAigCCCAENgIIAkAgAigCCCgCCEEARkEBcUUNACACQQBBAXE6AA8MAgsLIAIoAgAhBSACKAIIIAU2AgAgAkEBQQFxOgAPCyACLQAPQQFxIQYgAkEQaiSAgICAACAGDwviAQEFfyOAgICAAEEgayEDIAMkgICAgAAgAyAANgIcIAMgATYCGCADIAI2AhQgAygCGCEEIAMoAhQhBUEAIQYgAyAGIAYgBCAFEI+MgIAANgIQAkACQCADKAIQQQBIQQFxRQ0ADAELIAMgAygCEEEBajYCDCADIAMoAhwoAgA2AgggAygCHCADKAIMEN2KgIAAQQFxRQ0AIAMgAjYCFCADKAIcKAIIIAMoAghqIAMoAgwgAygCGCADKAIUEI+MgIAAGiADKAIcIQcgByAHKAIAQX9qNgIACyADQSBqJICAgIAADwtNAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADKAIMIAMoAgggAygCBBDgioCAACADQRBqJICAgIAADwuOAQEEfyOAgICAAEEQayEDIAMkgICAgAAgAyAANgIMIAMgATYCCCADIAI2AgQgAyADKAIMKAIANgIAAkAgAygCDCADKAIEEN2KgIAAQQFxRQ0AIAMoAgwoAgggAygCAGohBCADKAIIIQUgAygCBCEGAkAgBkUNACAEIAUgBvwKAAALCyADQRBqJICAgIAADwtNAQF/I4CAgIAAQRBrIQMgAySAgICAACADIAA2AgwgAyABNgIIIAMgAjYCBCADKAIMIAMoAgggAygCBBDgioCAACADQRBqJICAgIAADwtNAQF/I4CAgIAAQRBrIQIgAiSAgICAACACIAA2AgwgAiABOgALIAIgAkELajYCBCACKAIMIAIoAgRBARDgioCAACACQRBqJICAgIAADwu6AwECfyOAgICAAEEgayECIAIkgICAgAAgAiAANgIYIAIgATYCFAJAAkAgAigCFEH/AE1BAXFFDQAgAigCGCACKAIUQf8BcRDiioCAACACQQFBAXE6AB8MAQsCQCACKAIUQf8PTUEBcUUNACAC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IABBADYCBAwDCwJAAkAgBCgCHCgCDCAEKAIEQQJ0aigCACAEKAIQSUEBcUUNACAEIAQoAgRBAWo2AgwMAQsgBCAEKAIEQQFrNgIICwwACwsgACAEKAIMIAQoAhRqQQFrNgIAIAAgBCgCECAEKAIcKAIMIAQoAgxBAWtBAnRqKAIAazYCBAsgBEEgaiSAgICAAA8LOAEBfyOAgICAAEEQayEBIAEkgICAgAAgASAANgIMIAEoAgwoAgwQloyAgAAgAUEQaiSAgICAAA8LrwEBA38jgICAgABBIGshAyADJICAgIAAIAMgADYCHCADIAE2AhggAyACNgIUAkAgAygCGCADKAIUTUEBcQ0AQcfBhYAAQYbUhYAAQRFByaOEgAAQjoCAgAAACyADKAIcIQQgAyADKAIYNgIIIAMgAygCFCADKAIYazYCDCADQQE2AhAgBCADKQIINwIAQQghBSAEIAVqIAUgA0EIamooAgA2AgAgA0EgaiSAgICAAA8LaAEDfyOAgICAAEEgayEDIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCADIAMoAhg2AgggAyADKAIUNgIMIANBAjYCECAEIAMpAgg3AgBBCCEFIAQgBWogBSADQQhqaigCADYCAA8LaAEDfyOAgICAAEEgayEDIAMgADYCHCADIAE2AhggAyACNgIUIAMoAhwhBCADIAMoAhg2AgggAyADKAIUNgIMIANBADYCECAEIAMpAgg3AgBBCCEFIAQgBWogBSADQQhqaigCADYCAA8LxAEBBH8jgICAgABBEGshASABJICAgIAAIAEgADYCDAJAAkAgASgCDCgCCEECRkEBcUUNAAwBCyABIAEoAgwQp4uAgAA2AgggASABKAIMEKiLgIAANgIEIAEgASgCCBCUjICAADYCAAJAIAEoAgBBAEdBAXENAAwBCyABKAIMIAEoAgAgASgCCBCki4CAACABKAIMKAIAIQIgASgCBCEDIAEoAgghBAJAIARFDQAgAiADIAT8CgAACwsgAUEQaiSAgICAAA8LHwEBfyOAgICAAEEQayEBIAEgADYCDCABKAIMKAIEDwsfAQF/I4CAgIAAQRBrIQEgASAANgIMIAEoAgwoAgAPC70BAQJ/I4CAgIAAQSBrIQIgAiSAgICAACACIAA2AhggAiABNgIUIAIgAigCGBCn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gABFIQILAkACQAJAIAAoAhQgACgCHEYNACAAQQBBACAAKAIkEYaAgIAAgICAgAAaIAAoAhQNAEF/IQEgAkUNAQwCCwJAIAAoAgQiASAAKAIIIgNGDQAgACABIANrrEEBIAAoAigRh4CAgACAgICAABoLQQAhASAAQQA2AhwgAEIANwMQIABCADcCBCACDQELIAAQvYuAgAALIAEL8gICA38BfgJAIAJFDQAgACABOgAAIAAgAmoiA0F/aiABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBfWogAToAACADQX5qIAE6AAAgAkEHSQ0AIAAgAToAAyADQXxqIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIFayICQSBJDQAgAa1CgYCAgBB+IQYgAyAFaiEBA0AgASAGNwMYIAEgBjcDECABIAY3AwggASAGNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAALEQAgACgCPCABIAIQzouAgAALgQMBB38jgICAgABBIGsiAySAgICAACADIAAoAhwiBDYCECAAKAIUIQUgAyACNgIcIAMgATYCGCADIAUgBGsiATYCFCABIAJqIQYgA0EQaiEEQQIhBwJAAkACQAJAAkAgACgCPCADQRBqQQIgA0EMahCagICAABCRjICAAEUNACAEIQUMAQsDQCAGIAMoAgwiAUYNAgJAIAFBf0oNACAEIQUMBAsgBEEIQQAgASAEKAIEIghLIgkbaiIFIAUoAgAgASAIQQAgCRtrIghqNgIAIARBDEEEIAkbaiIEIAQoAgAgCGs2AgAgBiABayEGIAUhBCAAKAI8IAUgByAJayIHIANBDGoQmoCAgAAQkYyAgABFDQALCyAGQX9HDQELIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhAgAiEBDAELQQAhASAAQQA2AhwgAEIANwMQIAAgACgCAEEgcjYCACAHQQJGDQAgAiAFKAIEayEBCyADQSBqJICAgIAAIAELGQAgACgCPBC7i4CAABCZgICAABCRjICAAAs3AQF/I4CAgIAAQRBrIgMkgICAgAAgAyACNgIMIAAgASACEIuMgIAAIQIgA0EQaiSAgICAACACCyQBAX8gABDoi4CAACECQX9BACACIABBASACIAEQyouAgABHGwsTACACBEAgACABIAL8CgAACyAAC5MEAQN/AkAgAkGABEkNACAAIAEgAhDFi4CAAA8LIAAgAmohAwJAAkAgASAAc0EDcQ0AAkACQCAAQQNxDQAgACECDAELAkAgAg0AIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAkEDcUUNASACIANJDQALCyADQXxxIQQCQCADQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBwABqIQEgAkHAAGoiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAwCCwsCQCADQQRPDQAgACECDAELAkAgAkEETw0AIAAhAgwBCyADQXxqIQQgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLAkAgAiADTw0AA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0cNAAsLIAALiQEBAn8gACAAKAJIIgFBf2ogAXI2AkgCQCAAKAIUIAAoAhxGDQAgAEEAQQAgACgCJBGGgICAAICAgIAAGgsgAEEANgIcIABCADcDEAJAIAAoAgAiAUEEcUUNACAAIAFBIHI2AgBBfw8LIAAgACgCLCAAKAIwaiICNgIIIAAgAjYCBCABQRt0QR91C1wBAX8gACAAKAJIIgFBf2ogAXI2AkgCQCAAKAIAIgFBCHFFDQAgACABQSByNgIAQX8PCyAAQgA3AgQgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCEEEAC+YBAQN/AkACQCACKAIQIgMNAEEAIQQgAhDIi4CAAA0BIAIoAhAhAwsCQCABIAMgAigCFCIEa00NACACIAAgASACKAIkEYaAgIAAgICAgAAPCwJAAkAgAigCUEEASA0AIAFFDQAgASEDAkADQCAAIANqIgVBf2otAABBCkYNASADQX9qIgNFDQIMAAsLIAIgACADIAIoAiQRhoCAgACAgICAACIEIANJDQIgASADayEBIAIoAhQhBAwBCyAAIQVBACEDCyAEIAUgARDGi4CAABogAiACKAIUIAFqNgIUIAMgAWohBAsgBAtnAQJ/IAIgAWwhBAJAAkAgAygCTEF/Sg0AIAAgBCADEMmLgIAAIQAMAQsgAxC8i4CAACEFIAAgBCADEMmLgIAAIQAgBUUNACADEL2LgIAACwJAIAAgBEcNACACQQAgARsPCyAAIAFuCxcAIABBUGpBCkkgAEEgckGff2pBGklyCw4AIABBIHJBn39qQRpJCwgAQZjziIAAC0sBAX8jgICAgABBEGsiAySAgICAACAAIAEgAkH/AXEgA0EIahCbgICAABCRjICAACECIAMpAwghASADQRBqJICAgIAAQn8gASACGwvpAQECfyACQQBHIQMCQAJAAkAgAEEDcUUNACACRQ0AIAFB/wFxIQQDQCAALQAAIARGDQIgAkF/aiICQQBHIQMgAEEBaiIAQQNxRQ0BIAINAAsLIANFDQECQCAALQAAIAFB/wFxRg0AIAJBBEkNACABQf8BcUGBgoQIbCEEA0BBgIKECCAAKAIAIARzIgNrIANyQYCBgoR4cUGAgYKEeEcNAiAAQQRqIQAgAkF8aiICQQNLDQALCyACRQ0BCyABQf8BcSEDA0ACQCAALQAAIANHDQAgAA8LIABBAWohACACQX9qIgINAAsLQQALhgEBAn8CQAJAAkAgAkEESQ0AIAEgAHJBA3ENAQNAIAAoAgAgASgCAEcNAiABQQRqIQEgAEEEaiEAIAJBfGoiAkEDSw0ACwsgAkUNAQsCQANAIAAtAAAiAyABLQAAIgRHDQEgAUEBaiEBIABBAWohACACQX9qIgJFDQIMAAsLIAMgBGsPC0EACwQAQQALAgALAgALlQIBBH8jgICAgABBEGsiAiSAgICAAEGEpomAABDSi4CAACACQQA2AgwgACACQQxqENWLgIAAIQMCQAJAAkAgAUUNACADDQELQYSmiYAAENOLgIAAQWQhAQwBCwJAIAMoAgQgAUYNAEGEpomAABDTi4CAAEFkIQEMAQsgAygCJCEEAkACQCACKAIMIgVFDQAgBSAENgIkDAELQQAgBDYCiKaJgAALQYSmiYAAENOLgIAAAkAgAygCECIEQSBxDQAgACABIAMoAiAgBCADKAIMIAMpAxgQnICAgAAaCwJAIAMoAghFDQAgAygCABCWjICAAAtBACEBIAMtABBBIHENACADEJaMgIAACyACQRBqJICAgIAAIAELQgEBfwJAQQAoAoimiYAAIgJFDQADQAJAIAIoAgAgAEcNACACDwsCQCABRQ0AIAEgAjYCAAsgAigCJCICDQALC0EACwIACxgAENaLgIAAIAAgARDUi4CAABD+i4CAAAsUAEGMpomAABDSi4CAAEGQpomAAAsOAEGMpomAABDTi4CAAAsIABDdi4CAAAsEAEEqCwgAENuLgIAACwgAQZSmiYAAC10BAX9BAEHspYmAADYC9KaJgAAQ3IuAgAAhAEEAQYCAhIAAQYCAgIAAazYCzKaJgABBAEGAgISAADYCyKaJgABBACAANgKspomAAEEAQQAoAqSiiYAANgLQpomAAAuzAQEDfyOAgICAAEEQayICJICAgIAAIAIgAToADwJAAkAgACgCECIDDQACQCAAEMiLgIAARQ0AQX8hAwwCCyAAKAIQIQMLAkAgACgCFCIEIANGDQAgACgCUCABQf8BcSIDRg0AIAAgBEEBajYCFCAEIAE6AAAMAQsCQCAAIAJBD2pBASAAKAIkEYaAgIAAgICAgABBAUYNAEF/IQMMAQsgAi0ADyEDCyACQRBqJICAgIAAIAMLOQEBfyOAgICAAEEQayIEJICAgIAAIAQgAzYCDCAAIAEgAiADEI+MgIAAIQMgBEEQaiSAgICAACADCwQAQQALBABCAAuRAQECfwJAAkAgAC0AACICDQBBACEADAELAkADQCABLQAAIgNFDQECQCACQf8BcSICIANGDQAgAhD/i4CAACABLQAAEP+LgIAARg0AIAAtAAAhAgwCCyABQQFqIQEgAC0AASECIABBAWohACACDQALQQAhAgsgAkH/AXEhAAsgABD/i4CAACAB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D0YNAAJAIAMNAAJAAkAgAEQAAAAAAAAAAGINAEEAIQMMAQsgAEQAAAAAAADwQ6IgARCBjICAACEAIAEoAgBBQGohAwsgASADNgIAIAAPCyABIANBgnhqNgIAIAJC/////////4eAf4NCgICAgICAgPA/hL8hAAsgAAubAwEEfyOAgICAAEHQAWsiBSSAgICAACAFIAI2AswBAkBBKEUNACAFQaABakEAQSj8CwALIAUgBSgCzAE2AsgBAkACQEEAIAEgBUHIAWogBUHQAGogBUGgAWogAyAEEIOMgIAAQQBODQBBfyEEDAELAkACQCAAKAJMQQBODQBBASEGDAELIAAQvIuAgABFIQYLIAAgACgCACIHQV9xNgIAAkACQAJAAkAgACgCMA0AIABB0AA2AjAgAEEANgIcIABCADcDECAAKAIsIQggACAFNgIsDAELQQAhCCAAKAIQDQELQX8hAiAAEMiLgIAADQELIAAgASAFQcgBaiAFQdAAaiAFQaABaiADIAQQg4yAgAAhAgsgB0EgcSEEAkAgCEUNACAAQQBBACAAKAIkEYaAgIAAgICAgAAaIABBADYCMCAAIAg2AiwgAEEANgIcIAAoAhQhAyAAQgA3AxAgAkF/IAMbIQILIAAgACgCACIDIARyNgIAQX8gAiADQSBxGyEEIAYNACAAEL2LgIAACyAFQdABaiSAgICAACAEC5cUAhN/AX4jgICAgABBwABrIgckgICAgAAgByABNgI8IAdBKWohCCAHQSdqIQkgB0EoaiEKQQAhC0EAIQwCQAJAAkACQANAQQAhDQNAIAEhDiANIAxB/////wdzSg0CIA0gDGohDCAOIQ0CQAJAAkACQAJAAkAgDi0AACIPRQ0AA0ACQAJAAkAgD0H/AXEiDw0AIA0hAQwBCyAPQSVHDQEgDSEPA0ACQCAPLQABQSVGDQAgDyEBDAILIA1BAWohDSAPLQACIRAgD0ECaiIBIQ8gEEElRg0ACwsgDSAOayINIAxB/////wdzIg9KDQoCQCAARQ0AIAAgDiANEISMgIAACyANDQggByABNgI8IAFBAWohDUF/IRECQCABLAABQVBqIhBBCUsNACABLQACQSRHDQAgAUEDaiENQQEhCyAQIRELIAcgDTYCPEEAIRICQAJAIA0sAAAiE0FgaiIBQR9NDQAgDSEQDAELQQAh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IBQgFSASIA0gBRGIgICAAICAgIAAIg1BAE4NCAwLCyANLQABIQ8gDUEBaiENDAALCyAADQogC0UNBEEBIQ0CQANAIAQgDUECdGooAgAiD0UNASADIA1BA3RqIA8gAiAGEIaMgIAAQQEhDCANQQFqIg1BCkcNAAwMCwsCQCANQQpJDQBBASEMDAsLA0AgBCANQQJ0aigCAA0BQQEhDCANQQFqIg1BCkYNCwwACwtBHCEXDAcLIAcgDToAJ0EBIRUgCSEOIAohFyAYIRIMAQsgCiEXCyAVIBcgDmsiASAVIAFKGyITIBFB/////wdzSg0DQT0hFyAUIBEgE2oiECAUIBBKGyINIA9LDQQgAEEgIA0gECASEIqMgIAAIAAgGSAREISMgIAAIABBMCANIBAgEkGAgARzEIqMgIAAIABBMCATIAFBABCKjICAACAAIA4gARCEjICAACAAQSAgDSAQIBJBgMAAcxCKjICAACAHKAI8IQEMAQsLC0EAIQwMAwtBPSEXCxC4i4CAACAXNgIAC0F/IQwLIAdBwABqJICAgIAAIAwLHAACQCAALQAAQSBxDQAgASACIAAQyYuAgAAaCwt7AQV/QQAhAQJAIAAoAgAiAiwAAEFQaiIDQQlNDQBBAA8LA0BBfyEEAkAgAUHMmbPmAEsNAEF/IAMgAUEKbCIBaiADIAFB/////wdzSxshBAsgACACQQFqIgM2AgAgAiwAASEFIAQhASADIQIgBUFQaiIDQQpJDQALIAQLvgQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUF3ag4SAAECBQMEBgcICQoLDA0ODxAREgsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRgoCAgACAgICAAAsLPQEBfwJAIABQDQADQCABQX9qIgEgAKdBD3EtAID4iIAAIAJyOgAAIABCD1YhAyAAQgSIIQAgAw0ACwsgAQs2AQF/AkAgAFANAANAIAFBf2oiASAAp0EHcUEwcjoAACAAQgdWIQIgAEIDiCEAIAINAAsLIAELigECAX4DfwJAAkAgAEKAgICAEFoNACAAIQIMAQsDQCABQX9qIgEgACAAQgqAIgJCCn59p0EwcjoAACAAQv////+fAVYhAyACIQAgAw0ACwsCQCACUA0AIAKnIQMDQCABQX9qIgEgAyADQQpuIgRBCmxrQTByOgAAIANBCUshBSAEIQMgBQ0ACwsgAQuEAQEBfyOAgICAAEGAAmsiBSSAgICAAAJAIAIgA0wNACAEQYDABHENACAFIAEgAiADayIDQYACIANBgAJJIgIbEL+LgIAAGgJAIAINAANAIAAgBUGAAhCEjICAACADQYB+aiIDQf8BSw0ACwsgACAFIAMQhIyAgAALIAVBgAJqJICAgIAACxoAIAAgASACQeyBgIAAQe2BgIAAEIKMgIAAC8MZBgJ/AX4MfwJ+BH8BfCOAgICAAEGwBGsiBiSAgICAAEEAIQcgBkEANgIsAkACQCABEI6MgIAAIghCf1UNAEEBIQlBzIiEgAAhCiABmiIBEI6MgIAAIQgMAQsCQCAEQYAQcUUNAEEBIQlBz4iEgAAhCgwBC0HSiISAAEHNiISAACAEQQFxIgkbIQogCUUhBwsCQAJAIAhCgICAgICAgPj/AINCgICAgICAgPj/AFINACAAQSAgAiAJQQNqIgsgBEH//3txEIqMgIAAIAAgCiAJEISMgIAAIABBn++EgABBlPaFgAAgBUEgcSIMG0HljIWAAEGm/oWAACAMGyABIAFiG0EDEISMgIAAIABBICACIAsgBEGAwABzEIqMgIAAIAIgCyACIAtKGyENDAELIAZBEGohDgJAAkACQAJAIAEgBkEsahCBjICAACIBIAGgIgFEAAAAAAAAAABhDQAgBiAGKAIsIgtBf2o2AiwgBUEgciIPQeEARw0BDAMLIAVBIHIiD0HhAEYNAkEGIAMgA0EASBshECAGKAIsIREMAQsgBiALQWNqIhE2AixBBiADIANBAEgbIRAgAUQAAAAAAACwQaIhAQsgBkEwakEAQaACIBFBAEgbaiISIQwDQCAMIAH8AyILNgIAIAxBBGohDCABIAu4oUQAAAAAZc3NQaIiAUQAAAAAAAAAAGINAAsCQAJAIBFBAU4NACARIRMgDCELIBIhFAwBCyASIRQgESETA0AgE0EdIBNBHUkbIRMCQCAMQXxqIgsgFEkNACATrSEVQgAhCANAIAsgCzUCACAVhiAIfCIWIBZCgJTr3AOAIghCgJTr3AN+fT4CACALQXxqIgsgFE8NAAsgFkKAlOvcA1QNACAUQXxqIhQgCD4CAAsCQANAIAwiCyAUTQ0BIAtBfGoiDCgCAEUNAAsLIAYgBigCLCATayITNgIsIAshDCATQQBKDQALCwJAIBNBf0oNACAQQRlqQQluQQFqIRcgD0HmAEYhGANAQQAgE2siDEEJIAxBCUkbIQ0CQAJAIBQgC0kNAEEAQQQgFCgCABshDAwBC0GAlOvcAyANdiEZQX8gDXRBf3MhGkEAIRMgFCEMA0AgDCAMKAIAIgMgDXYgE2o2AgAgAyAacSAZbCETIAxBBGoiDCALSQ0AC0EAQQQgFCgCABshDCATRQ0AIAsgEzYCACALQQRqIQsLIAYgBigCLCANaiITNgIsIBIgFCAMaiIUIBgbIgwgF0ECdGogCyALIAxrQQJ1IBdKGyELIBNBAEgNAAsLQQAhEwJAIBQgC08NACASIBRrQQJ1QQlsIRNBCiEMIBQoAgAiA0EKSQ0AA0AgE0EBaiETIAMgDEEKbCIMTw0ACwsCQCAQQQAgEyAPQeYARhtrIBBBAEcgD0HnAEZxayIMIAsgEmtBAnVBCWxBd2pODQAgBkEwakGEYEGkYiARQQBIG2ogDEGAyABqIgNBCW0iGUECdGohDUEKIQwCQCADIBlBCWxrIgNBB0oNAANAIAxBCmwhDCADQQFqIgNBCEcNAAsLIA1BBGohGgJAAkAgDSgCACIDIAMgDG4iFyAMbGsiGQ0AIBogC0YNAQsCQAJAIBdBAXENAEQAAAAAAABAQyEBIAxBgJTr3ANHDQEgDSAUTQ0BIA1BfGotAABBAXFFDQELRAEAAAAAAEBDIQELRAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IBogC0YbRAAAAAAAAPg/IBkgDEEBdiIaRhsgGSAaSRshGwJAIAcNACAKLQAAQS1HDQAgG5ohGyABmiEBCyANIAMgGWsiAzYCACABIBugIAFhDQAgDSADIAxqIgw2AgACQCAMQYCU69wDSQ0AA0AgDUEANgIAAkAgDUF8aiINIBRPDQAgFEF8aiIUQQA2AgALIA0gDSgCAEEBaiIMNgIAIAxB/5Pr3ANLDQALCyASIBRrQQJ1QQlsIRNBCiEMIBQoAgAiA0EKSQ0AA0AgE0EBaiETIAMgDEEKbCIMTw0ACwsgDUEEaiIMIAsgCyAMSxshCwsCQANAIAsiDCAUTSIDDQEgDEF8aiILKAIARQ0ACwsCQAJAIA9B5wBGDQAgBEEIcSEZDAELIBNBf3NBfyAQQQEgEBsiCyATSiATQXtKcSINGyALaiEQQX9BfiANGyAFaiEFIARBCHEiGQ0AQXchCwJAIAMNACAMQXxqKAIAIg1FDQBBCiEDQQAhCyANQQpwDQADQCALIhlBAWohCyANIANBCmwiA3BFDQALIBlBf3MhCwsgDCASa0ECdUEJbCEDAkAgBUFfcUHGAEcNAEEAIRkgECADIAtqQXdqIgtBACALQQBKGyILIBAgC0gbIRAMAQtBACEZIBAgEyADaiALakF3aiILQQAgC0EAShsiCyAQIAtIGyEQC0F/IQ0gEEH9////B0H+////ByAQIBlyIhobSg0BIBAgGkEAR2pBAWohAwJAAkAgBUFfcSIYQcYARw0AIBMgA0H/////B3NKDQMgE0EAIBNBAEobIQsMAQsCQCAOIBMgE0EfdSILcyALa60gDhCJjICAACILa0EBSg0AA0AgC0F/aiILQTA6AAAgDiALa0ECSA0ACwsgC0F+aiIXIAU6AABBfyENIAtBf2pBLUErIBNBAEgbOgAAIA4gF2siCyADQf////8Hc0oNAgtBfyENIAsgA2oiCyAJQf////8Hc0oNASAAQSAgAiALIAlqIgUgBBCKjICAACAAIAogCRCEjICAACAAQTAgAiAFIARBgIAEcxCKjICAAAJAAkACQAJAIBhBxgBHDQAgBkEQakEJciETIBIgFCAUIBJLGyIDIRQDQCAUNQIAIBMQiYyAgAAhCwJAAkAgFCADRg0AIAsgBkEQak0NAQNAIAtBf2oiC0EwOgAAIAsgBkEQaksNAAwCCwsgCyATRw0AIAtBf2oiC0EwOgAACyAAIAsgEyALaxCEjICAACAUQQRqIhQgEk0NAAsCQCAaRQ0AIABBg6aGgABBARCEjICAAAsgFCAMTw0BIBBBAUgNAQNAAkAgFDUCACATEImMgIAAIgsgBkEQak0NAANAIAtBf2oiC0EwOgAAIAsgBkEQaksNAAsLIAAgCyAQQQkgEEEJSBsQhIyAgAAgEEF3aiELIBRBBGoiFCAMTw0DIBBBCUohAyALIRAgAw0ADAMLCwJAIBBBAEgNACAMIBRBBGogDCAUSxshDSAGQRBqQQlyIRMgFCEMA0ACQCAMNQIAIBMQiYyAgAAiCyATRw0AIAtBf2oiC0EwOgAACwJAAkAgDCAURg0AIAsgBkEQak0NAQNAIAtBf2oiC0EwOgAAIAsgBkEQaksNAAwCCwsgACALQQEQhIyAgAAgC0EBaiELIBAgGXJFDQAgAEGDpoaAAEEBEISMgIAACyAAIAsgEyALayIDIBAgECADShsQhIyAgAAgECADayEQIAxBBGoiDCANTw0BIBBBf0oNAAsLIABBMCAQQRJqQRJBABCKjICAACAAIBcgDiAXaxCEjICAAAwCCyAQIQsLIABBMCALQQlqQQlBABCKjICAAAsgAEEgIAIgBSAEQYDAAHMQioyAgAAgAiAFIAIgBUobIQ0MAQsgCiAFQRp0QR91QQlxaiEXAkAgA0ELSw0AQQwgA2shC0QAAAAAAAAwQCEbA0AgG0QAAAAAAAAwQKIhGyALQX9qIgsNAAsCQCAXLQAAQS1HDQAgGyABmiAboaCaIQEMAQsgASAboCAboSEBCwJAIAYoAiwiDCAMQR91IgtzIAtrrSAOEImMgIAAIgsgDkcNACALQX9qIgtBMDoAACAGKAIsIQwLIAlBAnIhGSAFQSBxIRQgC0F+aiIaIAVBD2o6AAAgC0F/akEtQSsgDEEASBs6AAAgA0EBSCAEQQhxRXEhEyAGQRBqIQwDQCAMIgsgAfwCIgxBgPiIgABqLQAAIBRyOgAAIAEgDLehRAAAAAAAADBAoiEBAkAgC0EBaiIMIAZBEGprQQFHDQAgAUQAAAAAAAAAAGEgE3ENACALQS46AAEgC0ECaiEMCyABRAAAAAAAAAAAYg0AC0F/IQ0gA0H9////ByAZIA4gGmsiFGoiE2tKDQAgAEEgIAIgEyADQQJqIAwgBkEQamsiCyALQX5qIANIGyALIAMbIgNqIgwgBBCKjICAACAAIBcgGRCEjICAACAAQTAgAiAMIARBgIAEcxCKjICAACAAIAZBEGogCxCEjICAACAAQTAgAyALa0EAQQAQioyAgAAgACAaIBQQhIyAgAAgAEEgIAIgDCAEQYDAAHMQioyAgAAgAiAMIAIgDEobIQ0LIAZBsARqJICAgIAAIA0LLgEBfyABIAEoAgBBB2pBeHEiAkEQajYCACAAIAIpAwAgAikDCBCzjICAADkDAAsFACAAvQujAQECfyOAgICAAEGgAWsiBCSAgICAACAEIAAgBEGeAWogARsiADYClAEgBEEAIAFBf2oiBSAFIAFLGzYCmAECQEGQAUUNACAEQQBBkAH8CwALIARBfzYCTCAEQe6BgIAANgIkIARBfzYCUCAEIARBnwFqNgIsIAQgBEGUAWo2AlQgAEEAOgAAIAQgAiADEIuMgIAAIQEgBEGgAWokgICAgAAgAQu2AQEFfyAAKAJUIgMoAgAhBAJAIAMoAgQiBSAAKAIUIAAoAhwiBmsiByAFIAdJGyIHRQ0AIAQgBiAHEMaLgIAAGiADIAMoAgAgB2oiBDYCACADIAMoAgQgB2siBTYCBAsCQCAFIAIgBSACSRsiBUUNACAEIAEgBRDGi4CAABogAyADKAIAIAVqIgQ2AgAgAyADKAIEIAVrNgIECyAEQQA6AAAgACAAKAIsIgM2AhwgACADNgIUIAILGQACQCAADQBBAA8LELiLgIAAIAA2AgBBfwusAgEBf0EBIQMCQAJAIABFDQAgAUH/AE0NAQJAAkAQ3YuAgAAoAmAoAgANACABQYB/cUGAvwNGDQMQuIuAgABBGTYCAAwBCwJAIAFB/w9LDQAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIPCwJAAkAgAUGAsANJDQAgAUGAQHFBgMADRw0BCyAAIAFBP3FBgAFyOgACIAAgAUEMdkHgAXI6AAAgACABQQZ2QT9xQYABcjoAAUEDDwsCQCABQYCAfGpB//8/Sw0AIAAgAUE/cUGAAXI6AAMgACABQRJ2QfABcjoAACAAIAFBBnZBP3FBgAFyOgACIAAgAUEMdkE/cUGAAXI6AAFBBA8LELiLgIAAQRk2AgALQX8hAwsgAw8LIAAgAToAAEEBCxgAAkAgAA0AQQAPCyAAIAFBABCSjICAAAuDJwEMfyOAgICAAEEQayIBJICAgIAAAkACQAJAAkACQCAAQfQBSw0AAkBBACgCqK+JgAAiAkEQIABBC2pB+ANxIABBC0kbIgNBA3YiBHYiAEEDcUUNAAJAAkAgAEF/c0EBcSAEaiIDQQN0IgBB0K+JgABqIgUgACgC2K+JgAAiBCgCCCIARw0AQQAgAkF+IAN3cTYCqK+JgAAMAQsgAEEAKAK4r4mAAEkNBCAAKAIMIARHDQQgACAFNgIMIAUgADYCCAsgBEEIaiEAIAQgA0EDdCIDQQNyNgIEIAQgA2oiBCAEKAIEQQFyNgIEDAULIANBACgCsK+JgAAiBk0NAQJAIABFDQACQAJAIAAgBHRBAiAEdCIAQQAgAGtycWgiBUEDdCIAQdCviYAAaiIHIAAoAtiviYAAIgAoAggiBEcNAEEAIAJBfiAFd3EiAjYCqK+JgAAMAQsgBEEAKAK4r4mAAEkNBCAEKAIMIABHDQQgBCAHNgIMIAcgBDYCCAsgACADQQNyNgIEIAAgA2oiByAFQQN0IgQgA2siA0EBcjYCBCAAIARqIAM2AgACQCAGRQ0AIAZBeHFB0K+JgABqIQVBACgCvK+JgAAhBAJAAkAgAkEBIAZBA3Z0IghxDQBBACACIAhyNgKor4mAACAFIQgMAQsgBSgCCCIIQQAoAriviYAASQ0FCyAFIAQ2AgggCCAENgIMIAQgBTYCDCAEIAg2AggLIABBCGohAEEAIAc2AryviYAAQQAgAzYCsK+JgAAMBQtBACgCrK+JgAAiCUUNASAJaEECdCgC2LGJgAAiBygCBEF4cSADayEEIAchBQJAA0ACQCAFKAIQIgANACAFKAIUIgBFDQILIAAoAgRBeHEgA2siBSAEIAUgBEkiBRshBCAAIAcgBRshByAAIQUMAAsLIAdBACgCuK+JgAAiCkkNAiAHKAIYIQsCQAJAIAcoAgwiACAHRg0AIAcoAggiBSAKSQ0EIAUoAgwgB0cNBCAAKAIIIAdHDQQgBSAANgIMIAAgBTYCCAwBCwJAAkACQCAHKAIUIgVFDQAgB0EUaiEIDAELIAcoAhAiBUUNASAHQRBqIQgLA0AgCCEMIAUiAEEUaiEIIAAoAhQiBQ0AIABBEGohCCAAKAIQIgUNAAsgDCAKSQ0EIAxBADYCAAwBC0EAIQALAkAgC0UNAAJAAkAgByAHKAIcIghBAnQiBSgC2LGJgABHDQAgBUHYsYmAAGogADYCACAADQFBACAJQX4gCHdxNgKsr4mAAAwCCyALIApJDQQCQAJAIAsoAhAgB0cNACALIAA2AhAMAQsgCyAANgIUCyAARQ0BCyAAIApJDQMgACALNgIYAkAgBygCECIFRQ0AIAUgCkkNBCAAIAU2AhAgBSAANgIYCyAHKAIUIgVFDQAgBSAKSQ0DIAAgBTYCFCAFIAA2AhgLAkACQCAEQQ9LDQAgByAEIANqIgBBA3I2AgQgByAAaiIAIAAoAgRBAXI2AgQMAQsgByADQQNyNgIEIAcgA2oiAyAEQQFyNgIEIAMgBGogBDYCAAJAIAZFDQAgBkF4cUHQr4mAAGohBUEAKAK8r4mAACEAAkACQEEBIAZBA3Z0IgggAnENAEEAIAggAnI2AqiviYAAIAUhCAwBCyAFKAIIIgggCkkNBQsgBSAANgIIIAggADYCDCAAIAU2AgwgACAINgIIC0EAIAM2AryviYAAQQAgBDYCsK+JgAALIAdBCGohAAwEC0F/IQMgAEG/f0sNACAAQQtqIgRBeHEhA0EAKAKsr4mAACILRQ0AQR8hBgJAIABB9P//B0sNACADQSYgBEEIdmciAGt2QQFxIABBAXRrQT5qIQYLQQAgA2shBAJAAkACQAJAIAZBAnQoAtixiYAAIgUNAEEAIQBBACEIDAELQQAhACADQQBBGSAGQQF2ayAGQR9GG3QhB0EAIQgDQAJAIAUoAgRBeHEgA2siAiAETw0AIAIhBCAFIQggAg0AQQAhBCAFIQggBSEADAMLIAAgBSgCFCICIAIgBSAHQR12QQRxaigCECIMRhsgACACGyEAIAdBAXQhByAMIQUgDA0ACwsCQCAAIAhyDQBBACEIQQIgBnQiAEEAIABrciALcSIARQ0DIABoQQJ0KALYsYmAACEACyAARQ0BCwNAIAAoAgRBeHEgA2siAiAESSEHAkAgACgCECIFDQAgACgCFCEFCyACIAQgBxshBCAAIAggBxshCCAFIQAgBQ0ACwsgCEUNACAEQQAoArCviYAAIANrTw0AIAhBACgCuK+JgAAiDEkNASAIKAIYIQYCQAJAIAgoAgwiACAIRg0AIAgoAggiBSAMSQ0DIAUoAgwgCEcNAyAAKAIIIAhHDQMgBSAANgIMIAAgBTYCCAwBCwJAAkACQCAIKAIUIgVFDQAgCEEUaiEHDAELIAgoAhAiBUUNASAIQRBqIQcLA0AgByECIAUiAEEUaiEHIAAoAhQiBQ0AIABBEGohByAAKAIQIgUNAAsgAiAMSQ0DIAJBADYCAAwBC0EAIQALAkAgBkUNAAJAAkAgCCAIKAIcIgdBAnQiBSgC2LGJgABHDQAgBUHYsYmAAGogADYCACAADQFBACALQX4gB3dxIgs2AqyviYAADAILIAYgDEkNAwJAAkAgBigCECAIRw0AIAYgADYCEAwBCyAGIAA2AhQLIABFDQELIAAgDEkNAiAAIAY2AhgCQCAIKAIQIgVFDQAgBSAMSQ0DIAAgBTYCECAFIAA2AhgLIAgoAhQiBUUNACAFIAxJDQIgACAFNgIUIAUgADYCGAsCQAJAIARBD0sNACAIIAQgA2oiAEEDcjYCBCAIIABqIgAgACgCBEEBcjYCBAwBCyAIIANBA3I2AgQgCCADaiIHIARBAXI2AgQgByAEaiAENgIAAkAgBEH/AUsNACAEQXhxQdCviYAAaiEAAkACQEEAKAKor4mAACIDQQEgBEEDdnQiBHENAEEAIAMgBHI2AqiviYAAIAAhBAwBCyAAKAIIIgQgDEkNBAsgACAHNgIIIAQgBzYCDCAHIAA2AgwgByAENgIIDAELQR8hAAJAIARB////B0sNACAEQSYgBEEIdmciAGt2QQFxIABBAXRrQT5qIQALIAcgADYCHCAHQgA3AhAgAEECdEHYsYmAAGohAwJAAkACQCALQQEgAHQiBXENAEEAIAsgBXI2AqyviYAAIAMgBzYCACAHIAM2AhgMAQsgBEEAQRkgAEEBdmsgAEEfRht0IQAgAygCACEFA0AgBSIDKAIEQXhxIARGDQIgAEEddiEFIABBAXQhACADIAVBBHFqIgIoAhAiBQ0ACyACQRBqIgAgDEkNBCAAIAc2AgAgByADNgIYCyAHIAc2AgwgByAHNgIIDAELIAMgDEkNAiADKAIIIgAgDEkNAiAAIAc2AgwgAyAHNgIIIAdBADYCGCAHIAM2AgwgByAANgIICyAIQQhqIQAMAwsCQEEAKAKwr4mAACIAIANJDQBBACgCvK+JgAAhBAJAAkAgACADayIFQRBJDQAgBCADaiIHIAVBAXI2AgQgBCAAaiAFNgIAIAQgA0EDcjYCBAwBCyAEIABBA3I2AgQgBCAAaiIAIAAoAgRBAXI2AgRBACEHQQAhBQtBACAFNgKwr4mAAEEAIAc2AryviYAAIARBCGohAAwDCwJAQQAoArSviYAAIgcgA00NAEEAIAcgA2siBDYCtK+JgABBAEEAKALAr4mAACIAIANqIgU2AsCviYAAIAUgBEEBcjYCBCAAIANBA3I2AgQgAEEIaiEADAMLAkACQEEAKAKAs4mAAEUNAEEAKAKIs4mAACEEDAELQQBCfzcCjLOJgABBAEKAoICAgIAENwKEs4mAAEEAIAFBDGpBcHFB2KrVqgVzNgKAs4mAAEEAQQA2ApSziYAAQQBBADYC5LKJgABBgCAhBAtBACEAIAQgA0EvaiIGaiICQQAgBGsiDHEiCCADTQ0CQQAhAAJAQQAoAuCyiYAAIgRFDQBBACgC2LKJgAAiBSAIaiILIAVNDQMgCyAESw0DCwJAAkACQEEALQDksomAAEEEcQ0AAkACQAJAAkACQEEAKALAr4mAACIERQ0AQeiyiYAAIQADQAJAIAQgACgCACIFSQ0AIAQgBSAAKAIEakkNAwsgACgCCCIADQALC0EAEJ+MgIAAIgdBf0YNAyAIIQICQEEAKAKEs4mAACIAQX9qIgQgB3FFDQAgCCAHayAEIAdqQQAgAGtxaiECCyACIANNDQMCQEEAKALgsomAACIARQ0AQQAoAtiyiYAAIgQgAmoiBSAETQ0EIAUgAEsNBAsgAhCfjICAACIAIAdHDQEMBQsgAiAHayAMcSICEJ+MgIAAIgcgACgCACAAKAIEakYNASAHIQALIABBf0YNAQJAIAIgA0EwakkNACAAIQcMBAsgBiACa0EAKAKIs4mAACIEakEAIARrcSIEEJ+MgIAAQX9GDQEgBCACaiECIAAhBwwDCyAHQX9HDQILQQBBACgC5LKJgABBBHI2AuSyiYAACyAIEJ+MgIAAIQdBABCfjICAACEAIAdBf0YNASAAQX9GDQEgByAATw0BIAAgB2siAiADQShqTQ0BC0EAQQAoAtiyiYAAIAJqIgA2AtiyiYAAAkAgAEEAKALcsomAAE0NAEEAIAA2AtyyiYAACwJAAkACQAJAQQAoAsCviYAAIgRFDQBB6LKJgAAhAANAIAcgACgCACIFIAAoAgQiCGpGDQIgACgCCCIADQAMAwsLAkACQEEAKAK4r4mAACIARQ0AIAcgAE8NAQtBACAHNgK4r4mAAAtBACEAQQAgAjYC7LKJgABBACAHNgLosomAAEEAQX82AsiviYAAQQBBACgCgLOJgAA2AsyviYAAQQBBADYC9LKJgAADQCAAQQN0IgQgBEHQr4mAAGoiBTYC2K+JgAAgBCAFNgLcr4mAACAAQQFqIgBBIEcNAAtBACACQVhqIgBBeCAHa0EHcSIEayIFNgK0r4mAAEEAIAcgBGoiBDYCwK+JgAAgBCAFQQFyNgIEIAcgAGpBKDYCBEEAQQAoApCziYAANgLEr4mAAAwCCyAEIAdPDQAgBCAFSQ0AIAAoAgxBCHENACAAIAggAmo2AgRBACAEQXggBGtBB3EiAGoiBTYCwK+JgABBAEEAKAK0r4mAACACaiIHIABrIgA2ArSviYAAIAUgAEEBcjYCBCAEIAdqQSg2AgRBAEEAKAKQs4mAADYCxK+JgAAMAQsCQCAHQQAoAriviYAATw0AQQAgBzYCuK+JgAALIAcgAmohBUHosomAACEAAkACQANAIAAoAgAiCCAFRg0BIAAoAggiAA0ADAILCyAALQAMQQhxRQ0EC0HosomAACEAAkADQAJAIAQgACgCACIFSQ0AIAQgBSAAKAIEaiIFSQ0CCyAAKAIIIQAMAAsLQQAgAkFYaiIAQXggB2tBB3EiCGsiDDYCtK+JgABBACAHIAhqIgg2AsCviYAAIAggDEEBcjYCBCAHIABqQSg2AgRBAEEAKAKQs4mAADYCxK+JgAAgBCAFQScgBWtBB3FqQVFqIgAgACAEQRBqSRsiCEEbNgIEIAhBEGpBACkC8LKJgAA3AgAgCEEAKQLosomAADcCCEEAIAhBCGo2AvCyiYAAQQAgAjYC7LKJgABBACAHNgLosomAAEEAQQA2AvSyiYAAIAhBGGohAANAIABBBzYCBCAAQQhqIQcgAEEEaiEAIAcgBUkNAAsgCCAERg0AIAggCCgCBEF+cTYCBCAEIAggBGsiB0EBcjYCBCAIIAc2AgACQAJAIAdB/wFLDQAgB0F4cUHQr4mAAGohAAJAAkBBACgCqK+JgAAiBUEBIAdBA3Z0IgdxDQBBACAFIAdyNgKor4mAACAAIQUMAQsgACgCCCIFQQAoAriviYAASQ0FCyAAIAQ2AgggBSAENgIMQQwhB0EIIQgMAQtBHyEAAkAgB0H///8HSw0AIAdBJiAHQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAAsgBCAANgIcIARCADcCECAAQQJ0QdixiYAAaiEFAkACQAJAQQAoAqyviYAAIghBASAAdCICcQ0AQQAgCCACcjYCrK+JgAAgBSAENgIAIAQgBTYCGAwBCyAHQQBBGSAAQQF2ayAAQR9GG3QhACAFKAIAIQgDQCAIIgUoAgRBeHEgB0YNAiAAQR12IQggAEEBdCEAIAUgCEEEcWoiAigCECIIDQALIAJBEGoiAEEAKAK4r4mAAEkNBSAAIAQ2AgAgBCAFNgIYC0EIIQdBDCEIIAQhBSAEIQAMAQsgBUEAKAK4r4mAACIHSQ0DIAUoAggiACAHSQ0DIAAgBDYCDCAFIAQ2AgggBCAANgIIQQAhAEEYIQdBDCEICyAEIAhqIAU2AgAgBCAHaiAANgIAC0EAKAK0r4mAACIAIANNDQBBACAAIANrIgQ2ArSviYAAQQBBACgCwK+JgAAiACADaiIFNgLAr4mAACAFIARBAXI2AgQgACADQQNyNgIEIABBCGohAAwDCxC4i4CAAEEwNgIAQQAhAAwCCxC6i4CAAAALIAAgBzYCACAAIAAoAgQgAmo2AgQgByAIIAMQlYyAgAAhAAsgAUEQaiSAgICAACAAC4oKAQd/IABBeCAAa0EHcWoiAyACQQNyNgIEIAFBeCABa0EHcWoiBCADIAJqIgVrIQACQAJAAkAgBEEAKALAr4mAAEcNAEEAIAU2AsCviYAAQQBBACgCtK+JgAAgAGoiAjYCtK+JgAAgBSACQQFyNgIEDAELAkAgBEEAKAK8r4mAAEcNAEEAIAU2AryviYAAQQBBACgCsK+JgAAgAGoiAjYCsK+JgAAgBSACQQFyNgIEIAUgAmogAjYCAAwBCwJAIAQoAgQiBkEDcUEBRw0AIAQoAgwhAgJAAkAgBkH/AUsNAAJAIAQoAggiASAGQQN2IgdBA3RB0K+JgABqIghGDQAgAUEAKAK4r4mAAEkNBSABKAIMIARHDQULAkAgAiABRw0AQQBBACgCqK+JgABBfiAHd3E2AqiviYAADAILAkAgAiAIRg0AIAJBACgCuK+JgABJDQUgAigCCCAERw0FCyABIAI2AgwgAiABNgIIDAELIAQoAhghCQJAAkAgAiAERg0AIAQoAggiAUEAKAK4r4mAAEkNBSABKAIMIARHDQUgAigCCCAERw0FIAEgAjYCDCACIAE2AggMAQsCQAJAAkAgBCgCFCIBRQ0AIARBFGohCAwBCyAEKAIQIgFFDQEgBEEQaiEICwNAIAghByABIgJBFGohCCACKAIUIgENACACQRBqIQggAigCECIBDQALIAdBACgCuK+JgABJDQUgB0EANgIADAELQQAhAgsgCUUNAAJAAkAgBCAEKAIcIghBAnQiASgC2LGJgABHDQAgAUHYsYmAAGogAjYCACACDQFBAEEAKAKsr4mAAEF+IAh3cTYCrK+JgAAMAgsgCUEAKAK4r4mAAEkNBAJAAkAgCSgCECAERw0AIAkgAjYCEAwBCyAJIAI2AhQLIAJFDQELIAJBACgCuK+JgAAiCEkNAyACIAk2AhgCQCAEKAIQIgFFDQAgASAISQ0EIAIgATYCECABIAI2AhgLIAQoAhQiAUUNACABIAhJDQMgAiABNgIUIAEgAjYCGAsgBkF4cSICIABqIQAgBCACaiIEKAIEIQYLIAQgBkF+cTYCBCAFIABBAXI2AgQgBSAAaiAANgIAAkAgAEH/AUsNACAAQXhxQdCviYAAaiECAkACQEEAKAKor4mAACIBQQEgAEEDdnQiAHENAEEAIAEgAHI2AqiviYAAIAIhAAwBCyACKAIIIgBBACgCuK+JgABJDQMLIAIgBTYCCCAAIAU2AgwgBSACNgIMIAUgADYCCAwBC0EfIQICQCAAQf///wdLDQAgAEEmIABBCHZnIgJrdkEBcSACQQF0a0E+aiECCyAFIAI2AhwgBUIANwIQIAJBAnRB2LGJgABqIQECQAJAAkBBACgCrK+JgAAiCEEBIAJ0IgRxDQBBACAIIARyNgKsr4mAACABIAU2AgAgBSABNgIYDAELIABBAEEZIAJBAXZrIAJBH0YbdCECIAEoAgAhCANAIAgiASgCBEF4cSAARg0CIAJBHXYhCCACQQF0IQIgASAIQQRxaiIEKAIQIggNAAsgBEEQaiICQQAoAriviYAASQ0DIAIgBTYCACAFIAE2AhgLIAUgBTYCDCAFIAU2AggMAQsgAUEAKAK4r4mAACIASQ0BIAEoAggiAiAASQ0BIAIgBTYCDCABIAU2AgggBUEANgIYIAUgATYCDCAFIAI2AggLIANBCGoPCxC6i4CAAAALxQ8BCn8CQAJAIABFDQAgAEF4aiIBQQAoAriviYAAIgJJDQEgAEF8aigCACIDQQNxQQFGDQEgASADQXhxIgBqIQQCQCADQQFxDQAgA0ECcUUNASABIAEoAgAiBWsiASACSQ0CIAUgAGohAAJAIAFBACgCvK+JgABGDQAgASgCDCEDAkAgBUH/AUsNAAJAIAEoAggiBiAFQQN2IgdBA3RB0K+JgABqIgVGDQAgBiACSQ0FIAYoAgwgAUcNBQsCQCADIAZHDQBBAEEAKAKor4mAAEF+IAd3cTYCqK+JgAAMAwsCQCADIAVGDQAgAyACSQ0FIAMoAgggAUcNBQsgBiADNgIMIAMgBjYCCAwCCyABKAIYIQgCQAJAIAMgAUYNACABKAIIIgUgAkkNBSAFKAIMIAFHDQUgAygCCCABRw0FIAUgAzYCDCADIAU2AggMAQsCQAJAAkAgASgCFCIFRQ0AIAFBFGohBgwBCyABKAIQIgVFDQEgAUEQaiEGCwNAIAYhByAFIgNBFGohBiADKAIUIgUNACADQRBqIQYgAygCECIFDQALIAcgAkkNBSAHQQA2AgAMAQtBACEDCyAIRQ0BAkACQCABIAEoAhwiBkECdCIFKALYsYmAAEcNACAFQdixiYAAaiADNgIAIAMNAUEAQQAoAqyviYAAQX4gBndxNgKsr4mAAAwDCyAIIAJJDQQCQAJAIAgoAhAgAUcNACAIIAM2AhAMAQsgCCADNgIUCyADRQ0CCyADIAJJDQMgAyAINgIYAkAgASgCECIFRQ0AIAUgAkkNBCADIAU2AhAgBSADNgIYCyABKAIUIgVFDQEgBSACSQ0DIAMgBTYCFCAFIAM2AhgMAQsgBCgCBCIDQQNxQQNHDQBBACAANgKwr4mAACAEIANBfnE2AgQgASAAQQFyNgIEIAQgADYCAA8LIAEgBE8NASAEKAIEIgdBAXFFDQECQAJAIAdBAnENAAJAIARBACgCwK+JgABHDQBBACABNgLAr4mAAEEAQQAoArSviYAAIABqIgA2ArSviYAAIAEgAEEBcjYCBCABQQAoAryviYAARw0DQQBBADYCsK+JgABBAEEANgK8r4mAAA8LAkAgBEEAKAK8r4mAACIJRw0AQQAgATYCvK+JgABBAEEAKAKwr4mAACAAaiIANgKwr4mAACABIABBAXI2AgQgASAAaiAANgIADwsgBCgCDCEDAkACQCAHQf8BSw0AAkAgBCgCCCIFIAdBA3YiCEEDdEHQr4mAAGoiBkYNACAFIAJJDQYgBSgCDCAERw0GCwJAIAMgBUcNAEEAQQAoAqiviYAAQX4gCHdxNgKor4mAAAwCCwJAIAMgBkYNACADIAJJDQYgAygCCCAERw0GCyAFIAM2AgwgAyAFNgIIDAELIAQoAhghCgJAAkAgAyAERg0AIAQoAggiBSACSQ0GIAUoAgwgBEcNBiADKAIIIARHDQYgBSADNgIMIAMgBTYCCAwBCwJAAkACQCAEKAIUIgVFDQAgBEEUaiEGDAELIAQoAhAiBUUNASAEQRBqIQYLA0AgBiEIIAUiA0EUaiEGIAMoAhQiBQ0AIANBEGohBiADKAIQIgUNAAsgCCACSQ0GIAhBADYCAAwBC0EAIQMLIApFDQACQAJAIAQgBCgCHCIGQQJ0IgUoAtixiYAARw0AIAVB2LGJgABqIAM2AgAgAw0BQQBBACgCrK+JgABBfiAGd3E2AqyviYAADAILIAogAkkNBQJAAkAgCigCECAERw0AIAogAzYCEAwBCyAKIAM2AhQLIANFDQELIAMgAkkNBCADIAo2AhgCQCAEKAIQIgVFDQAgBSACSQ0FIAMgBTYCECAFIAM2AhgLIAQoAhQiBUUNACAFIAJJDQQgAyAFNgIUIAUgAzYCGAsgASAHQXhxIABqIgBBAXI2AgQgASAAaiAANgIAIAEgCUcNAUEAIAA2ArCviYAADwsgBCAHQX5xNgIEIAEgAEEBcjYCBCABIABqIAA2AgALAkAgAEH/AUsNACAAQXhxQdCviYAAaiEDAkACQEEAKAKor4mAACIFQQEgAEEDdnQiAHENAEEAIAUgAHI2AqiviYAAIAMhAAwBCyADKAIIIgAgAkkNAwsgAyABNgIIIAAgATYCDCABIAM2AgwgASAANgIIDwtBHyEDAkAgAEH///8HSw0AIABBJiAAQQh2ZyIDa3ZBAXEgA0EBdGtBPmohAwsgASADNgIcIAFCADcCECADQQJ0QdixiYAAaiEGAkACQAJAAkBBACgCrK+JgAAiBUEBIAN0IgRxDQBBACAFIARyNgKsr4mAACAGIAE2AgBBCCEAQRghAwwBCyAAQQBBGSADQQF2ayADQR9GG3QhAyAGKAIAIQYDQCAGIgUoAgRBeHEgAEYNAiADQR12IQYgA0EBdCEDIAUgBkEEcWoiBCgCECIGDQALIARBEGoiACACSQ0EIAAgATYCAEEIIQBBGCEDIAUhBgsgASEFIAEhBAwBCyAFIAJJDQIgBSgCCCIGIAJJDQIgBiABNgIMIAUgATYCCEEAIQRBGCEAQQghAwsgASADaiAGNgIAIAEgBTYCDCABIABqIAQ2AgBBAEEAKALIr4mAAEF/aiIBQX8gARs2AsiviYAACw8LELqLgIAAAAueAQECfwJAIAANACABEJSMgIAADwsCQCABQUBJDQAQuIuAgABBMDYCAEEADwsCQCAAQXhqQRAgAUELakF4cSABQQtJGxCYjICAACICRQ0AIAJBCGoPCwJAIAEQlIyAgAAiAg0AQQAPCyACIABBfEF4IABBfGooAgAiA0EDcRsgA0F4cWoiAyABIAMgAUkbEMaLgIAAGiAAEJaMgIAAIAILlQkBCX8CQAJAIABBACgCuK+JgAAiAkkNACAAKAIEIgNBA3EiBEEBRg0AIANBeHEiBUUNACAAIAVqIgYoAgQiB0EBcUUNAAJAIAQNAEEAIQQgAUGAAkkNAgJAIAUgAUEEakkNACAAIQQgBSABa0EAKAKIs4mAAEEBdE0NAwtBACEEDAILAkAgBSABSQ0AAkAgBSABayIFQRBJDQAgACABIANBAXFyQQJyNgIEIAAgAWoiASAFQQNyNgIEIAYgBigCBEEBcjYCBCABIAUQnIyAgAALIAAPC0EAIQQCQCAGQQAoAsCviYAARw0AQQAoArSviYAAIAVqIgUgAU0NAiAAIAEgA0EBcXJBAnI2AgQgACABaiIDIAUgAWsiBUEBcjYCBEEAIAU2ArSviYAAQQAgAzYCwK+JgAAgAA8LAkAgBkEAKAK8r4mAAEcNAEEAIQRBACgCsK+JgAAgBWoiBSABSQ0CAkACQCAFIAFrIgRBEEkNACAAIAEgA0EBcXJBAnI2AgQgACABaiIBIARBAXI2AgQgACAFaiIFIAQ2AgAgBSAFKAIEQX5xNgIEDAELIAAgA0EBcSAFckECcjYCBCAAIAVqIgUgBSgCBEEBcjYCBEEAIQRBACEBC0EAIAE2AryviYAAQQAgBDYCsK+JgAAgAA8LQQAhBCAHQQJxDQEgB0F4cSAFaiIIIAFJDQEgBigCDCEFAkACQCAHQf8BSw0AAkAgBigCCCIEIAdBA3YiCUEDdEHQr4mAAGoiB0YNACAEIAJJDQMgBCgCDCAGRw0DCwJAIAUgBEcNAEEAQQAoAqiviYAAQX4gCXdxNgKor4mAAAwCCwJAIAUgB0YNACAFIAJJDQMgBSgCCCAGRw0DCyAEIAU2AgwgBSAENgIIDAELIAYoAhghCgJAAkAgBSAGRg0AIAYoAggiBCACSQ0DIAQoAgwgBkcNAyAFKAIIIAZHDQMgBCAFNgIMIAUgBDYCCAwBCwJAAkACQCAGKAIUIgRFDQAgBkEUaiEHDAELIAYoAhAiBEUNASAGQRBqIQcLA0AgByEJIAQiBUEUaiEHIAUoAhQiBA0AIAVBEGohByAFKAIQIgQNAAsgCSACSQ0DIAlBADYCAAwBC0EAIQULIApFDQACQAJAIAYgBigCHCIHQQJ0IgQoAtixiYAARw0AIARB2LGJgABqIAU2AgAgBQ0BQQBBACgCrK+JgABBfiAHd3E2AqyviYAADAILIAogAkkNAgJAAkAgCigCECAGRw0AIAogBTYCEAwBCyAKIAU2AhQLIAVFDQELIAUgAkkNASAFIAo2AhgCQCAGKAIQIgRFDQAgBCACSQ0CIAUgBDYCECAEIAU2AhgLIAYoAhQiBEUNACAEIAJJDQEgBSAENgIUIAQgBTYCGAsCQCAIIAFrIgVBD0sNACAAIANBAXEgCHJBAnI2AgQgACAIaiIFIAUoAgRBAXI2AgQgAA8LIAAgASADQQFxckECcjYCBCAAIAFqIgEgBUEDcjYCBCAAIAhqIgMgAygCBEEBcjYCBCABIAUQnIyAgAAgAA8LELqLgIAAAAsgBAsfAAJAIABBCEsNACABEJSMgIAADwsgACABEJqMgIAAC7EDAQV/QRAhAgJAAkAgAEEQIABBEEsbIgMgA0F/anENACADIQAMAQsDQCACIgBBAXQhAiAAIANJDQALCwJAIAFBQCAAa0kNABC4i4CAAEEwNgIAQQAPCwJAQRAgAUELakF4cSABQQtJGyIBIABqQQxqEJSMgIAAIgINAEEADwsgAkF4aiEDAkACQCAAQX9qIAJxDQAgAyEADAELIAJBfGoiBCgCACIFQXhxIAIgAGpBf2pBACAAa3FBeGoiAkEAIAAgAiADa0EPSxtqIgAgA2siAmshBgJAIAVBA3ENACADKAIAIQMgACAGNgIEIAAgAyACajYCAAwBCyAAIAYgACgCBEEBcXJBAnI2AgQgACAGaiIGIAYoAgRBAXI2AgQgBCACIAQoAgBBAXFyQQJyNgIAIAMgAmoiBiAGKAIEQQFyNgIEIAMgAhCcjICAAAsCQCAAKAIEIgJBA3FFDQAgAkF4cSIDIAFBEGpNDQAgACABIAJBAXFyQQJyNgIEIAAgAWoiAiADIAFrIgFBA3I2AgQgACADaiIDIAMoAgRBAXI2AgQgAiABEJyMgIAACyAAQQhqC3wBAn8CQAJAAkAgAUEIRw0AIAIQlIyAgAAhAQwBC0EcIQMgAUEESQ0BIAFBA3ENASABQQJ2IgQgBEF/anENAQJAIAJBQCABa00NAEEwDwsgAUEQIAFBEEsbIAIQmoyAgAAhAQsCQCABDQBBMA8LIAAgATYCAEEAIQMLIAML+Q4BCX8gACABaiECAkACQAJAAkAgACgCBCIDQQFxRQ0AQQAoAriviYAAIQQMAQsgA0ECcUUNASAAIAAoAgAiBWsiAEEAKAK4r4mAACIESQ0CIAUgAWohAQJAIABBACgCvK+JgABGDQAgACgCDCEDAkAgBUH/AUsNAAJAIAAoAggiBiAFQQN2IgdBA3RB0K+JgABqIgVGDQAgBiAESQ0FIAYoAgwgAEcNBQsCQCADIAZHDQBBAEEAKAKor4mAAEF+IAd3cTYCqK+JgAAMAwsCQCADIAVGDQAgAyAESQ0FIAMoAgggAEcNBQsgBiADNgIMIAMgBjYCCAwCCyAAKAIYIQgCQAJAIAMgAEYNACAAKAIIIgUgBEkNBSAFKAIMIABHDQUgAygCCCAARw0FIAUgAzYCDCADIAU2AggMAQsCQAJAAkAgACgCFCIFRQ0AIABBFGohBgwBCyAAKAIQIgVFDQEgAEEQaiEGCwNAIAYhByAFIgNBFGohBiADKAIUIgUNACADQRBqIQYgAygCECIFDQALIAcgBEkNBSAHQQA2AgAMAQtBACEDCyAIRQ0BAkACQCAAIAAoAhwiBkECdCIFKALYsYmAAEcNACAFQdixiYAAaiADNgIAIAMNAUEAQQAoAqyviYAAQX4gBndxNgKsr4mAAAwDCyAIIARJDQQCQAJAIAgoAhAgAEcNACAIIAM2AhAMAQsgCCADNgIUCyADRQ0CCyADIARJDQMgAyAINgIYAkAgACgCECIFRQ0AIAUgBEkNBCADIAU2AhAgBSADNgIYCyAAKAIUIgVFDQEgBSAESQ0DIAMgBTYCFCAFIAM2AhgMAQsgAigCBCIDQQNxQQNHDQBBACABNgKwr4mAACACIANBfnE2AgQgACABQQFyNgIEIAIgATYCAA8LIAIgBEkNAQJAAkAgAigCBCIIQQJxDQACQCACQQAoAsCviYAARw0AQQAgADYCwK+JgABBAEEAKAK0r4mAACABaiIBNgK0r4mAACAAIAFBAXI2AgQgAEEAKAK8r4mAAEcNA0EAQQA2ArCviYAAQQBBADYCvK+JgAAPCwJAIAJBACgCvK+JgAAiCUcNAEEAIAA2AryviYAAQQBBACgCsK+JgAAgAWoiATYCsK+JgAAgACABQQFyNgIEIAAgAWogATYCAA8LIAIoAgwhAwJAAkAgCEH/AUsNAAJAIAIoAggiBSAIQQN2IgdBA3RB0K+JgABqIgZGDQAgBSAESQ0GIAUoAgwgAkcNBgsCQCADIAVHDQBBAEEAKAKor4mAAEF+IAd3cTYCqK+JgAAMAgsCQCADIAZGDQAgAyAESQ0GIAMoAgggAkcNBgsgBSADNgIMIAMgBTYCCAwBCyACKAIYIQoCQAJAIAMgAkYNACACKAIIIgUgBEkNBiAFKAIMIAJHDQYgAygCCCACRw0GIAUgAzYCDCADIAU2AggMAQsCQAJAAkAgAigCFCIFRQ0AIAJBFGohBgwBCyACKAIQIgVFDQEgAkEQaiEGCwNAIAYhByAFIgNBFGohBiADKAIUIgUNACADQRBqIQYgAygCECIFDQALIAcgBEkNBiAHQQA2AgAMAQtBACEDCyAKRQ0AAkACQCACIAIoAhwiBkECdCIFKALYsYmAAEcNACAFQdixiYAAaiADNgIAIAMNAUEAQQAoAqyviYAAQX4gBndxNgKsr4mAAAwCCyAKIARJDQUCQAJAIAooAhAgAkcNACAKIAM2AhAMAQsgCiADNgIUCyADRQ0BCyADIARJDQQgAyAKNgIYAkAgAigCECIFRQ0AIAUgBEkNBSADIAU2AhAgBSADNgIYCyACKAIUIgVFDQAgBSAESQ0EIAMgBTYCFCAFIAM2AhgLIAAgCEF4cSABaiIBQQFyNgIEIAAgAWogATYCACAAIAlHDQFBACABNgKwr4mAAA8LIAIgCEF+cTYCBCAAIAFBAXI2AgQgACABaiABNgIACwJAIAFB/wFLDQAgAUF4cUHQr4mAAGohAwJAAkBBACgCqK+JgAAiBUEBIAFBA3Z0IgFxDQBBACAFIAFyNgKor4mAACADIQEMAQsgAygCCCIBIARJDQMLIAMgADYCCCABIAA2AgwgACADNgIMIAAgATYCCA8LQR8hAwJAIAFB////B0sNACABQSYgAUEIdmciA2t2QQFxIANBAXRrQT5qIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEHYsYmAAGohBQJAAkACQEEAKAKsr4mAACIGQQEgA3QiAnENAEEAIAYgAnI2AqyviYAAIAUgADYCACAAIAU2AhgMAQsgAUEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEGA0AgBiIFKAIEQXhxIAFGDQIgA0EddiEGIANBAXQhAyAFIAZBBHFqIgIoAhAiBg0ACyACQRBqIgEgBEkNAyABIAA2AgAgACAFNgIYCyAAIAA2AgwgACAANgIIDwsgBSAESQ0BIAUoAggiASAESQ0BIAEgADYCDCAFIAA2AgggAEEANgIYIAAgBTYCDCAAIAE2AggLDwsQuouAgAAAC2sCAX8BfgJAAkAgAA0AQQAhAgwBCyAArSABrX4iA6chAiABIAByQYCABEkNAEF/IAIgA0IgiKdBAEcbIQILAkAgAhCUjICAACIARQ0AIABBfGotAABBA3FFDQAgAEEAIAIQv4uAgAAaCyAACwcAPwBBEHQLYQECf0EAKALUpImAACIBIABBB2pBeHEiAmohAAJAAkACQCACRQ0AIAAgAU0NAQsgABCejICAAE0NASAAEJ2AgIAADQELELiLgIAAQTA2AgBBfw8LQQAgADYC1KSJgAAgAQuACwcBfwF+AX8CfgF/AX4BfyOAgICAAEHwAGsiBSSAgICAACAEQv///////////wCDIQYCQAJAAkAgAVAiByACQv///////////wCDIghCgICAgICAwICAf3xCgICAgICAwICAf1QgCFAbDQAgA0IAUiAGQoCAgICAgMCAgH98IglCgICAgICAwICAf1YgCUKAgICAgIDAgIB/URsNAQsCQCAHIAhCgICAgICAwP//AFQgCEKAgICAgIDA//8AURsNACACQoCAgICAgCCEIQQgASEDDAILAkAgA1AgBkKAgICAgIDA//8AVCAGQoCAgICAgMD//wBRGw0AIARCgICAgICAIIQhBAwCCwJAIAEgCEKAgICAgIDA//8AhYRCAFINAEKAgICAgIDg//8AIAIgAyABhSAEIAKFQoCAgICAgICAgH+FhFAiBxshBEIAIAEgBxshAwwCCyADIAZCgICAgICAwP//AIWEUA0BAkAgASAIhEIAUg0AIAMgBoRCAFINAiADIAGDIQMgBCACgyEEDAILIAMgBoRQRQ0AIAEhAyACIQQMAQsgAyABIAMgAVYgBiAIViAGIAhRGyIKGyEGIAQgAiAKGyIJQv///////z+DIQggAiAEIAobIgtCMIinQf//AXEhDAJAIAlCMIinQf//AXEiBw0AIAVB4ABqIAYgCCAGIAggCFAiBxt5QsAAQgAgBxt8pyIHQXFqEKGMgIAAQRAgB2shByAFKQNoIQggBSkDYCEGCyABIAMgChshAyALQv///////z+DIQECQCAMDQAgBUHQAGogAyABIAMgASABUCIKG3lCwABCACAKG3ynIgpBcWoQoYyAgABBECAKayEMIAUpA1ghASAFKQNQIQMLIAFCA4YgA0I9iIRCgICAgICAgASEIQEgCEIDhiAGQj2IhCELIANCA4YhCCAEIAKFIQMCQCAHIAxGDQACQCAHIAxrIgpB/wBNDQBCACEBQgEhCAwBCyAFQcAAaiAIIAFBgAEgCmsQoYyAgAAgBUEwaiAIIAEgChCrjICAACAFKQMwIAUpA0AgBSkDSIRCAFKthCEIIAUpAzghAQsgC0KAgICAgICABIQhCyAGQgOGIQYCQAJAIANCf1UNAEIAIQNCACEEIAYgCIUgCyABhYRQDQIgBiAIfSECIAsgAX0gBiAIVK19IgRC/////////wNWDQEgBUEgaiACIAQgAiAEIARQIgobeULAAEIAIAobfKdBdGoiChChjICAACAHIAprIQcgBSkDKCEEIAUpAyAhAgwBCyABIAt8IAggBnwiAiAIVK18IgRCgICAgICAgAiDUA0AIAJCAYggBEI/hoQgCEIBg4QhAiAHQQFqIQcgBEIBiCEECyAJQoCAgICAgICAgH+DIQgCQCAHQf//AUgNACAIQoCAgICAgMD//wCEIQRCACEDDAELQQAhCgJAAkAgB0EATA0AIAchCgwBCyAFQRBqIAIgBCAHQf8AahChjICAACAFIAIgBEEBIAdrEKuMgIAAIAUpAwAgBSkDECAFKQMYhEIAUq2EIQIgBSkDCCEECyACQgOIIARCPYaEIQMgCq1CMIYgBEIDiEL///////8/g4QgCIQhBCACp0EHcSEHAkACQAJAAkACQBCpjICAAA4DAAECAwsCQCAHQQRGDQAgBCADIAdBBEutfCIIIANUrXwhBCAIIQMMAwsgBCADIANCAYN8IgggA1StfCEEIAghAwwDCyAEIAMgCEIAUiAHQQBHca18IgggA1StfCEEIAghAwwBCyAEIAMgCFAgB0EAR3GtfCIIIANUrXwhBCAIIQMLIAdFDQELEKqMgIAAGgsgACADNwMAIAAgBDcDCCAFQfAAaiSAgICAAAtTAQF+AkACQCADQcAAcUUNACABIANBQGqthiECQgAhAQwBCyADRQ0AIAFBwAAgA2utiCACIAOtIgSGhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAvmAQIBfwJ+QQEhBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNAAJAIAIgAIQgBiAFhIRQRQ0AQQAPCwJAIAMgAYNCAFMNAAJAIAAgAlQgASADUyABIANRG0UNAEF/DwsgACAChSABIAOFhEIAUg8LAkAgACACViABIANVIAEgA1EbRQ0AQX8PCyAAIAKFIAEgA4WEQgBSIQQLIAQL2AECAX8CfkF/IQQCQCAAQgBSIAFC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAJCAFIgA0L///////////8AgyIGQoCAgICAgMD//wBWIAZCgICAgICAwP//AFEbDQACQCACIACEIAYgBYSEUEUNAEEADwsCQCADIAGDQgBTDQAgACACVCABIANTIAEgA1EbDQEgACAChSABIAOFhEIAUg8LIAAgAlYgASADVSABIANRGw0AIAAgAoUgASADhYRCAFIhBAsgBAufEQYBfwN+A38BfgF/C34jgICAgABB0AJrIgUkgICAgAAgBEL///////8/gyEGIAJC////////P4MhByAEIAKFQoCAgICAgICAgH+DIQggBEIwiKdB//8BcSEJAkACQAJAIAJCMIinQf//AXEiCkGBgH5qQYKAfkkNAEEAIQsgCUGBgH5qQYGAfksNAQsCQCABUCACQv///////////wCDIgxCgICAgICAwP//AFQgDEKAgICAgIDA//8AURsNACACQoCAgICAgCCEIQgMAgsCQCADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURsNACAEQoCAgICAgCCEIQggAyEBDAILAkAgASAMQoCAgICAgMD//wCFhEIAUg0AAkAgAyACQoCAgICAgMD//wCFhFBFDQBCACEBQoCAgICAgOD//wAhCAwDCyAIQoCAgICAgMD//wCEIQhCACEBDAILAkAgAyACQoCAgICAgMD//wCFhEIAUg0AQgAhAQwCCwJAIAEgDIRCAFINAEKAgICAgIDg//8AIAggAyAChFAbIQhCACEBDAILAkAgAyAChEIAUg0AIAhCgICAgICAwP//AIQhCEIAIQEMAgtBACELAkAgDEL///////8/Vg0AIAVBwAJqIAEgByABIAcgB1AiCxt5QsAAQgAgCxt8pyILQXFqEKGMgIAAQRAgC2shCyAFKQPIAiEHIAUpA8ACIQELIAJC////////P1YNACAFQbACaiADIAYgAyAGIAZQIg0beULAAEIAIA0bfKciDUFxahChjICAACANIAtqQXBqIQsgBSkDuAIhBiAFKQOwAiEDCyAFQaACaiADQjGIIAZCgICAgICAwACEIg5CD4aEIgJCAEKAgICAsOa8gvUAIAJ9IgRCABCtjICAACAFQZACakIAIAUpA6gCfUIAIARCABCtjICAACAFQYACaiAFKQOQAkI/iCAFKQOYAkIBhoQiBEIAIAJCABCtjICAACAFQfABaiAEQgBCACAFKQOIAn1CABCtjICAACAFQeABaiAFKQPwAUI/iCAFKQP4AUIBhoQiBEIAIAJCABCtjICA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gICAgICAwACFIQcgAikDACEICyAAIAg3AwAgACAErUIwhiADQR92rUI/hoQgB4Q3AwggAkEQaiSAgICAAAuhAQMBfwJ+AX8jgICAgABBEGsiAiSAgICAAAJAAkAgAQ0AQgAhA0IAIQQMAQsgAiABIAFBH3UiBXMgBWsiBa1CACAFZyIFQdEAahChjICAACACKQMIQoCAgICAgMAAhUGegAEgBWutQjCGfEKAgICAgICAgIB/QgAgAUEASBuEIQQgAikDACEDCyAAIAM3AwAgACAENwMIIAJBEGokgICAgAALgQECAX8CfiOAgICAAEEQayICJICAgIAAAkACQCABDQBCACEDQgAhBAwBCyACIAGtQgBB8AAgAWciAUEfc2sQoYyAgAAgAikDCEKAgICAgIDAAIVBnoABIAFrrUIwhnwhBCACKQMAIQMLIAAgAzcDACAAIAQ3AwggAkEQaiSAgICAAAsEAEEACwQAQQALUwEBfgJAAkAgA0HAAHFFDQAgAiADQUBqrYghAUIAIQIMAQsgA0UNACACQcAAIANrrYYgASADrSIEiIQhASACIASIIQILIAAgATcDACAAIAI3AwgLtQsGAX8EfgN/AX4BfwR+I4CAgIAAQeAAayIFJICAgIAAIARC////////P4MhBiAEIAKFQoCAgICAgICAgH+DIQcgAkL///////8/gyIIQiCIIQkgBEIwiKdB//8BcSEKAkACQAJAIAJCMIinQf//AXEiC0GBgH5qQYKAfkkNAEEAIQwgCkGBgH5qQYGAfksNAQsCQCABUCACQv///////////wCDIg1CgICAgICAwP//AFQgDUKAgICAgIDA//8AURsNACACQoCAgICAgCCEIQcMAgsCQCADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURsNACAEQoCAgICAgCCEIQcgAyEBDAILAkAgASANQoCAgICAgMD//wCFhEIAUg0AAkAgAyAChFBFDQBCgICAgICA4P//ACEHQgAhAQwDCyAHQoCAgICAgMD//wCEIQdCACEBDAILAkAgAyACQoCAgICAgMD//wCFhEIAUg0AIAEgDYQhAkIAIQECQCACUEUNAEKAgICAgIDg//8AIQcMAwsgB0KAgICAgIDA//8AhCEHDAILAkAgASANhEIAUg0AQgAhAQwCCwJAIAMgAoRCAFINAEIAIQEMAgtBACEMAkAgDUL///////8/Vg0AIAVB0ABqIAEgCCABIAggCFAiDBt5QsAAQgAgDBt8pyIMQXFqEKGMgIAAQRAgDGshDCAFKQNYIghCIIghCSAFKQNQIQELIAJC////////P1YNACAFQcAAaiADIAYgAyAGIAZQIg4beULAAEIAIA4bfKciDkFxahChjICAACAMIA5rQRBqIQwgBSkDSCEGIAUpA0AhAwsgCyAKaiAMakGBgH9qIQoCQAJAIAZCD4YiD0IgiEKAgICACIQiAiABQiCIIgR+IhAgA0IPhiIRQiCIIgYgCUKAgASEIgl+fCINIBBUrSANIANCMYggD4RC/////w+DIgMgCEL/////D4MiCH58Ig8gDVStfCACIAl+fCAPIBFCgID+/w+DIg0gCH4iESAGIAR+fCIQIBFUrSAQIAMgAUL/////D4MiAX58IhEgEFStfHwiECAPVK18IAMgCX4iEiACIAh+fCIPIBJUrUIghiAPQiCIhHwgECAPQiCGfCIPIBBUrXwgDyANIAl+IhAgBiAIfnwiCSACIAF+fCICIAMgBH58IgNCIIggCSAQVK0gAiAJVK18IAMgAlStfEIghoR8IgIgD1StfCACIBEgDSAEfiIJIAYgAX58IgRCIIggBCAJVK1CIIaEfCIGIBFUrSAGIANCIIZ8IgMgBlStfHwiBiACVK18IAYgAyAEQiCGIgIgDSABfnwiASACVK18IgIgA1StfCIEIAZUrXwiA0KAgICAgIDAAINQDQAgCkEBaiEKDAELIAFCP4ghBiADQgGGIARCP4iEIQMgBEIBhiACQj+IhCEEIAFCAYYhASAGIAJCAYaEIQILAkAgCkH//wFIDQAgB0KAgICAgIDA//8AhCEHQgAhAQwBCwJAAkAgCkEASg0AAkBBASAKayILQf8ASw0AIAVBMGogASACIApB/wBqIgoQoYyAgAAgBUEgaiAEIAMgChChjICAACAFQRBqIAEgAiALEKuMgIAAIAUgBCADIAsQq4yAgAAgBSkDICAFKQMQhCAFKQMwIAUpAziEQgBSrYQhASAFKQMoIAUpAxiEIQIgBSkDCCEDIAUpAwAhBAwCC0IAIQEMAgsgCq1CMIYgA0L///////8/g4QhAwsgAyAHhCEHAkAgAVAgAkJ/VSACQoCAgICAgICAgH9RGw0AIAcgBEIBfCIBUK18IQcMAQsCQCABIAJCgICAgICAgICAf4WEQgBRDQAgBCEBDAELIAcgBCAEQgGDfCIBIARUrXwhBwsgACABNwMAIAAgBzcDCCAFQeAAaiSAgICAAAt1AQF+IAAgBCABfiACIAN+fCADQiCIIgIgAUIgiCIEfnwgA0L/////D4MiAyABQv////8PgyIBfiIFQiCIIAMgBH58IgNCIIh8IANC/////w+DIAIgAX58IgFCIIh8NwMIIAAgAUIghiAFQv////8Pg4Q3AwALIABBgICEgAAkgoCAgABBgICAgABBD2pBcHEkgYCAgAALDwAjgICAgAAjgYCAgABrCwgAI4KAgIAACwgAI4GAgIAAC1QBAX8jgICAgABBEGsiBSSAgICAACAFIAEgAiADIARCgICAgICAgICAf4UQoIyAgAAgBSkDACEEIAAgBSkDCDcDCCAAIAQ3AwAgBUEQaiSAgICAAAupBAMBfwJ+BH8jgICAgABBIGsiAiSAgICAACABQv///////z+DIQMCQAJAIAFCMIhC//8BgyIEpyIFQf+Hf2pB/Q9LDQAgAEI8iCADQgSGhCEDIAVBgIh/aq0hBAJAAkAgAEL//////////w+DIgBCgYCAgICAgIAIVA0AIANCAXwhAwwBCyAAQoCAgICAgICACFINACADQgGDIAN8IQMLQgAgAyADQv////////8HViIFGyEAIAWtIAR8IQMMAQsCQCAAIAOEUA0AIARC//8BUg0AIABCPIggA0IEhoRCgICAgICAgASEIQBC/w8hAwwBCwJAIAVB/ocBTQ0AQv8PIQNCACEADAELAkBBgPgAQYH4ACAEUCIGGyIHIAVrIghB8ABMDQBCACEAQgAhAwwBCyADIANCgICAgICAwACEIAYbIQNBACEGAkAgByAFRg0AIAJBEGogACADQYABIAhrEKGMgIAAIAIpAxAgAikDGIRCAFIhBgsgAiAAIAMgCBCrjICAACACKQMAIgNCPIggAikDCEIEhoQhAAJAAkAgA0L//////////w+DIAathCIDQoGAgICAgICACFQNACAAQgF8IQAMAQsgA0KAgICAgICAgAhSDQAgAEIBgyAAfCEACyAAQoCAgICAgIAIhSAAIABC/////////wdWIgUbIQAgBa0hAwsgAkEgaiSAgICAACADQjSGIAFCgICAgICAgICAf4OEIACEvwseAEEAIAAgAEGZAUsbQQF0LwGQh4mAAEGQ+IiAAGoLDAAgACAAELSMgIAACxEAQbO5hYAAQQAQko2AgAAAC1QBAn8jgICAgABBEGsiAiSAgICAAEEAIQMCQCAAQQNxDQAgASAAcA0AIAJBDGogACABEJuMgIAAIQBBACACKAIMIAAbIQMLIAJBEGokgICAgAAgAwsZAAJAIAAQuYyAgAAiAA0AELqMgIAACyAACz4BAn8gAEEBIABBAUsbIQECQANAIAEQlIyAgAAiAg0BEJWNgIAAIgBFDQEgABGBgICAAICAgIAADAALCyACCwkAELaMgIAAAAsKACAAEJaMgIAACwoAIAAQu4yAgAALGwACQCAAIAEQvoyAgAAiAQ0AELqMgIAACyABC0wBAn8gAUEEIAFBBEsbIQIgAEEBIABBAUsbIQACQANAIAIgABC/jICAACIDDQEQlY2AgAAiAUUNASABEYGAgIAAgICAgAAMAAsLIAMLJAEBfyAAIAEgACABakF/akEAIABrcSICIAEgAksbELeMgIAACwoAIAAQwYyAgAALCgAgABCWjICAAAsMACAAIAIQwIyAgAALIQACQCAAEMuMgIAARQ0AIAAQzIyAgAAPCyAAEM2MgIAACwwAIAAgARDPjICAAAslAQF/QQohAQJAIAAQy4yAgABFDQAgABDQjICAAEF/aiEBCyABCyEAAkAgABDLjICAAEUNACAAENGMgIAADwsgABDSjICAAAsEACAACwIAC7EDAQN/I4CAgIAAQSBrIggkgICAgAACQCACIAAQ1oyAgAAiCSABQX9zaksNACAAEMaMgIAAIQoCQCABIAlBAXZBeGpPDQAgCCABQQF0NgIcIAggAiABajYCECAIQRBqIAhBHGoQ14yAgAAoAgAQ2IyAgABBAWohCQsgABDZjICAACAIQRxqIAhBGGogABDajICAACgCABDbjICAACAIQRBqIAAgCRDcjICAACAIKAIQIgkgCCgCFBDdjICAAAJAIARFDQAgCRDHjICAACAKEMeMgIAAIAQQ3oyAgAAaCwJAIAZFDQAgCRDHjICAACAEaiAHIAYQ3oyAgAAaCyADIAUgBGoiB2shAgJAIAMgB0YNACAJEMeMgIAAIARqIAZqIAoQ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ACACIAEoAhRHDQELIANBAUcNASABQQE2AiAPCyABIAI2AhQgASADNgIgIAEgASgCKEEBajYCKAJAIAEoAiRBAUcNACABKAIYQQJHDQAgAUEBOgA2CyABQQQ2AiwLC0wAAkAgACABKAIIIAUQnY2AgABFDQAgASABIAIgAyAEEKiNgIAADwsgACgCCCIAIAEgAiADIAQgBSAAKAIAKAIUEYmAgIAAgICAgAALJwACQCAAIAEoAgggBRCdjYCAAEUNACABIAEgAiADIAQQqI2AgAALCwQAIAALCgAgACSAgICAAAsaAQJ/I4CAgIAAIABrQXBxIgEkgICAgAAgAQsIACOAgICAAAsL26QFAgBBgIAEC8GNBX4AaGFzT3duUHJvcGVydHkAZ3JvdXAgbmFtZSBpcyBlbXB0eQBpbmZpbml0eQBJbmZpbml0eQBpbmRleCA8IGxpc3QtPmNhcGFjaXR5AG5leHRfY2FwYWNpdHkgPiBsb2NhbHMtPmNhcGFjaXR5AHBhcnNlX3JldHJ5AGZhaWxlZCB0byBhbGxvY2F0ZSBtZW1vcnkAW3BtX2Zsb2F0X25vZGVfcmF0aW9uYWxfY3JlYXRlXSBGYWlsZWQgdG8gYWxsb2NhdGUgbWVtb3J5AGltYWdpbmFyeQBudW1iZXJlZF9wYXJhbWV0ZXJfb3JkaW5hcnkAaXRfbm90X2FsbG93ZWRfb3JkaW5hcnkAaW52YWxpZF9udW1iZXJfYmluYXJ5AGV4cGVyaW1lbnRhbF9jb3B5AHBtX25vZGVfZGVzdHJveQBrYXJhdHN1YmFfbXVsdGlwbHkAd3JpdGVfdGFyZ2V0X3JlYWRvbmx5AHBhdHRlcm5fZXhwcmVzc2lvbl9hZnRlcl9rZXkAcGF0dGVybl9oYXNoX2tleQBkdXBsaWNhdGVkX2hhc2hfa2V5AGV4cGVjdGVkIGEgcGF0dGVybiBleHByZXNzaW9uIGFmdGVyIHRoZSBrZXkASW52YWxpZCByZXR1cm4gaW4gY2xhc3MvbW9kdWxlIGJvZHkAY291bGQgbm90IHBhcnNlIHRoZSBlbmRsZXNzIG1ldGhvZCBib2R5AHVuZXhwZWN0ZWQgY2xhc3MgZGVmaW5pdGlvbiBpbiBtZXRob2QgYm9keQB1bmV4cGVjdGVkIG1vZHVsZSBkZWZpbml0aW9uIGluIG1ldGhvZCBib2R5AGFuYWx5emVkX3J1YnkAZXh0cmFjdFJ1YnkAZXhwZWN0ZWQgYW4gZWxlbWVudCBmb3IgdGhlIGFycmF5AGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYCpgIGluIHRoZSBhcnJheQB1bmV4cGVjdGVkICVzOyBleHBlY3RlZCBhIGBdYCB0byBjbG9zZSB0aGUgYXJyYXkAQXJyYXkAcGFyc2VfZXhwcmVzc2lvbl9pbmZpeABwYXJzZV9leHByZXNzaW9uX3ByZWZpeABhbWJpZ3VvdXMgYCpgIGhhcyBiZWVuIGludGVycHJldGVkIGFzIGFuIGFyZ3VtZW50IHByZWZpeABhbWJpZ3VvdXMgYCoqYCBoYXMgYmVlbiBpbnRlcnByZXRlZCBhcyBhbiBhcmd1bWVudCBwcmVmaXgAYW1iaWd1b3VzIGAmYCBoYXMgYmVlbiBpbnRlcnByZXRlZCBhcyBhbiBhcmd1bWVudCBwcmVmaXgAcGFyc2VyX2xleABmb3JfaW5kZXgAZm9yIGxvb3AgaW5kZXgASW52YWxpZCBlc2NhcGUgY2hhcmFjdGVyIHN5bnRheABceAAtKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AHBhcmFtZXRlcl9ub19kZWZhdWx0X2t3AHBhcmFtZXRlcl91bmV4cGVjdGVkX25vX2t3AEFjdGlvblZpZXcAXHYAJWxsdQBcdQAldQB1bmV4cGVjdGVkX3Rva2VuX2Nsb3NlX2NvbnRleHQAdW5leHBlY3RlZCBtdWx0aXBsZSBhc3NpZ25tZW50OyBtdWx0aXBsZSBhc3NpZ25tZW50IGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgY29udGV4dAB1bmV4cGVjdGVkICVzOyB1bmFyeSBjYWxscyBhcmUgbm90IGFsbG93ZWQgaW4gdGhpcyBjb250ZXh0AHRvcCBsZXZlbCBjb250ZXh0AHBvc3NpYmx5IHVzZWxlc3MgdXNlIG9mICUuKnMgaW4gdm9pZCBjb250ZXh0AG5leHQAdW5leHBlY3RlZCAlcywgZXhwZWN0aW5nIGVuZC1vZi1pbnB1dABubyBSdWJ5IHNjcmlwdCBmb3VuZCBpbiBpbnB1dABlc2NhcGVfaW52YWxpZF91bmljb2RlX2xpc3QAZXhwZWN0ZWQgYSBzdHJpbmcgaW4gYSBgJXdgIGxpc3QAZXhwZWN0ZWQgYSBzeW1ib2wgaW4gYSBgJWlgIGxpc3QAZXhwZWN0ZWQgYSBzdHJpbmcgaW4gYSBgJVdgIGxpc3QAZXhwZWN0ZWQgYSBzeW1ib2wgaW4gYSBgJUlgIGxpc3QAcGF0dGVybl9leHByZXNzaW9uX2FmdGVyX3Jlc3QAcGFyYW1ldGVyX2ZvcndhcmRpbmdfYWZ0ZXJfcmVzdABwYXJzZV9wYXR0ZXJuX3Jlc3QAcGFyc2VfcGF0dGVybl9rZXl3b3JkX3Jlc3QAbXVsdGlfYXNzaWduX3VuZXhwZWN0ZWRfcmVzdABlc2NhcGVfaW52YWxpZF91bmljb2RlX3Nob3J0AHVuc2lnbmVkIHNob3J0AHBtX2NvbnN0YW50X2lkX2xpc3RfaW5zZXJ0AHBtX2J1ZmZlcl9pbnNlcnQAcG1fY29uc3RhbnRfcG9vbF9pbnNlcnQAY29tbWVudF9zdGFydABjdXJzb3IgPj0gbGlzdC0+c3RhcnQAVW5leHBlY3RlZCBFUkIgc3RhcnQAZW5kID49IHN0YXJ0AGNhbm5vdF9wYXJzZV9zdHJpbmdfcGFydABjYW5ub3QgcGFyc2UgdGhlIHN0cmluZyBwYXJ0AHNjcmlwdABub3QAcHJpbnQAcG1fdXRmXzhfY29kZXBvaW50AHVuc2lnbmVkIGludABzdWJzZXF1ZW50AGV4cGVjdF9zdHJpbmdfY29udGVudABzdHJpbmcgY29udGVudABpbnZhbGlkX2Zsb2F0X2V4cG9uZW50AGludmFsaWQgZXhwb25lbnQAZXhwZWN0X2FyZ3VtZW50AGFsaWFzX2FyZ3VtZW50AHVuZXhwZWN0ZWRfYmxvY2tfYXJndW1lbnQAdW5kZWZfYXJndW1lbnQALi4uIGFmdGVyIHJlc3QgYXJndW1lbnQAdW5leHBlY3RlZCBgKmAgc3BsYXQgYXJndW1lbnQgYWZ0ZXIgYSBgKipgIGtleXdvcmQgc3BsYXQgYXJndW1lbnQAdW5leHBlY3RlZCBgKmAgc3BsYXQgYXJndW1lbnQgYWZ0ZXIgYSBgKmAgc3BsYXQgYXJndW1lbnQAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgKmAgc3BsYXQgaW4gYW4gYXJndW1lbnQAdW5leHBlY3RlZCAlczsgZXhwZWN0ZWQgYW4gYXJndW1lbnQAaW52YWxpZCBhcmd1bWVudCBiZWluZyBwYXNzZWQgdG8gYHVuZGVmYDsgZXhwZWN0ZWQgYSBiYXJlIHdvcmQsIGNvbnN0YW50LCBvciBzeW1ib2wgYXJndW1lbnQAdW5leHBlY3RlZCBhcmd1bWVudCBhZnRlciBhIGJsb2NrIGFyZ3VtZW50AHVuZXhwZWN0ZWQgYmFyZSBoYXNoIGFyZ3VtZW50AGhlcmUgZG9jdW1lbnQAZHluYW1pYyBjb25zdGFudCBhc3NpZ25tZW50AGV4cGVjdGVkIGEgYClgIGFmdGVyIG11bHRpcGxlIGFzc2lnbm1lbnQAdW5leHBlY3RlZCAnJS4qcycgcmVzdWx0aW5nIGluIG11bHRpcGxlIHNwbGF0cyBpbiBtdWx0aXBsZSBhc3NpZ25tZW50AHVuZXhwZWN0ZWQgb3BlcmF0b3IgZm9yIGEgbXVsdGlwbGUgYXNzaWdubWVudAB1bmV4cGVjdGVkIGB8fD1gIGluIGEgbXVsdGlwbGUgYXNzaWdubWVudAB1bmV4cGVjdGVkIGAmJj1gIGluIGEgbXVsdGlwbGUgYXNzaWdubWVudABpbnZhbGlkX2VuY29kaW5nX21hZ2ljX2NvbW1lbnQAdW5rbm93biBvciBpbnZhbGlkIGVuY29kaW5nIGluIHRoZSBtYWdpYyBjb21tZW50AGV4cGVjdF9lb2xfYWZ0ZXJfc3RhdGVtZW50AHVucmVhY2hhYmxlX3N0YXRlbWVudAB2b2lkX3N0YXRlbWVudAB1bmxlc3Mgc3RhdGVtZW50AGJlZ2luIHN0YXRlbWVudAB1bnRpbCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYSBwcmVkaWNhdGUgZm9yIGEgY2FzZSBtYXRjaGluZyBzdGF0ZW1lbnQAaWYgc3RhdGVtZW50AGV4cGVjdGVkIGFuIGV4Y2VwdGlvbiB2YXJpYWJsZSBhZnRlciBgPT5gIGluIGEgcmVzY3VlIHN0YXRlbWVudAB3aGlsZSBzdGF0ZW1lbnQAZXhwZWN0ZWQgYSBwcmVkaWNhdGUgZXhwcmVzc2lvbiBmb3IgdGhlIGB1bmxlc3NgIHN0YXRlbWVudABleHBlY3RlZCBhbiBgZW5kYCB0byBjbG9zZSB0aGUgYGNsYXNzYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYW4gYGluYCBhZnRlciB0aGUgaW5kZXggaW4gYSBgZm9yYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYSBjb2xsZWN0aW9uIGFmdGVyIHRoZSBgaW5gIGluIGEgYGZvcmAgc3RhdGVtZW50AGV4cGVjdGVkIGFuIGBlbmRgIHRvIGNsb3NlIHRoZSBgYmVnaW5gIHN0YXRlbWVudABleHBlY3RlZCBhIHByZWRpY2F0ZSBleHByZXNzaW9uIGZvciB0aGUgYHVudGlsYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYW4gYGVuZGAgdG8gY2xvc2UgdGhlIGB1bnRpbGAgc3RhdGVtZW50AGV4cGVjdGVkIGEgcHJlZGljYXRlIGV4cHJlc3Npb24gZm9yIHRoZSBgZWxzaWZgIHN0YXRlbWVudABleHBlY3RlZCBhIHByZWRpY2F0ZSBleHByZXNzaW9uIGZvciB0aGUgYGlmYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYW4gYGVuZGAgdG8gY2xvc2UgdGhlIGBkZWZgIHN0YXRlbWVudABleHBlY3RlZCBhbiBgZW5kYCB0byBjbG9zZSB0aGUgYGNhc2VgIHN0YXRlbWVudABleHBlY3RlZCBhbiBgZW5kYCB0byBjbG9zZSB0aGUgYG1vZHVsZWAgc3RhdGVtZW50AGV4cGVjdGVkIGEgcHJlZGljYXRlIGV4cHJlc3Npb24gZm9yIHRoZSBgd2hpbGVgIHN0YXRlbWVudABleHBlY3RlZCBhbiBgZW5kYCB0byBjbG9zZSB0aGUgYHdoaWxlYCBzdGF0ZW1lbnQAZXhwZWN0ZWQgYSBgfWAgdG8gY2xvc2UgdGhlIGBCRUdJTmAgc3RhdGVtZW50AGV4cGVjdGVkIGEgYH1gIHRvIGNsb3NlIHRoZSBgRU5EYCBzdGF0ZW1lbnQAYXJyYXlfZWxlbWVudABsaXN0X3dfbG93ZXJfZWxlbWVudABsaXN0X2lfbG93ZXJfZWxlbWVudABsaXN0X3dfdXBwZXJfZWxlbWVudABsaXN0X2lfdXBwZXJfZWxlbWVudABleHBlY3RlZCBhbiBleHByZXNzaW9uIGZvciB0aGUgYXJyYXkgZWxlbWVudAB3YXJuX2luZGVudABpbnZhbGlkX3BlcmNlbnQAcG1fY29uc3RhbnRfcG9vbF9pZF90b19jb25zdGFudABjb25zdGFudF9wYXRoX2NvbG9uX2NvbG9uX2NvbnN0YW50AGFyZ3VtZW50X2Zvcm1hbF9jb25zdGFudABpbnZhbGlkIGZvcm1hbCBhcmd1bWVudDsgZm9ybWFsIGFyZ3VtZW50IGNhbm5vdCBiZSBhIGNvbnN0YW50AHBhcmFtZXRlcl9ub19kZWZhdWx0AGxpdGVyYWxfaW5fY29uZGl0aW9uX2RlZmF1bHQARU5EIGluIG1ldGhvZDsgdXNlIGF0X2V4aXQAcGFyc2VfYmxvY2tfZXhpdABpbnZhbGlkX2Jsb2NrX2V4aXQAcG1fcGFyc2VyX2luaXQAcG1fc3RyaW5nX3NoYXJlZF9pbml0AHNwbGl0AHBtX2ludGVnZXJfcGFyc2VfZGlnaXQAcGF0dGVybl9oYXNoX2ltcGxpY2l0AG51bWJlcmVkX3BhcmFtZXRlcl9pdAB1bmV4cGVjdGVkICVzLCBpZ25vcmluZyBpdAB1bmV4cGVjdGVkICd9JywgaWdub3JpbmcgaXQAdW5leHBlY3RlZCAnaW4nLCBpZ25vcmluZyBpdAB1bmV4cGVjdGVkICd3aGVuJywgaWdub3JpbmcgaXQAdW5leHBlY3RlZCAnZWxzaWYnLCBpZ25vcmluZyBpdAB1bmV4cGVjdGVkICdyZXNjdWUnLCBpZ25vcmluZyBpdAB1bmV4cGVjdGVkICdlbHNlJywgaWdub3JpbmcgaXQAdW5leHBlY3RlZCAnZW5zdXJlJywgaWdub3JpbmcgaXQAdW5leHBlY3RlZCAnZW5kJywgaWdub3JpbmcgaXQAcG1fcGFyYW1ldGVyc19ub2RlX2tleXdvcmRfcmVzdF9zZXQAcG1fcGFyYW1ldGVyc19ub2RlX2Jsb2NrX3NldABwbV9ibG9ja19wYXJhbWV0ZXJzX25vZGVfY2xvc2luZ19zZXQAcG1fc3RycGJya19leHBsaWNpdF9lbmNvZGluZ19zZXQAcG1fYXJyYXlfbm9kZV9jbG9zZV9zZXQAcG1fYmVnaW5fbm9kZV9lbmRfa2V5d29yZF9zZXQAaWRlbnRpZmllciAlLipzIGlzIG5vdCB2YWxpZCB0byBzZXQAcGF0dGVybl9pZGVudF9hZnRlcl9ocm9ja2V0AHBhdHRlcm5fZXhwcmVzc2lvbl9hZnRlcl9ocm9ja2V0AGhhc2hfcm9ja2V0AGV4cGVjdF9yYnJhY2tldABwYXR0ZXJuX2V4cHJlc3Npb25fYWZ0ZXJfYnJhY2tldABwYXR0ZXJuX3Rlcm1fYnJhY2tldAB1bmV4cGVjdGVkIHdyaXRlIHRhcmdldABpZGVudGlmaWVyICUuKnMgaXMgbm90IHZhbGlkIHRvIGdldABvYmplY3QAT2JqZWN0AGZsb2F0AGFyZ3VtZW50X3NwbGF0X2FmdGVyX3NwbGF0AGV4cGVjdF9leHByZXNzaW9uX2FmdGVyX3NwbGF0AGFyZ3VtZW50X3NwbGF0X2FmdGVyX2Fzc29jX3NwbGF0AGVzY2FwZV9pbnZhbGlkX2NvbnRyb2xfcmVwZWF0AGVzY2FwZV9pbnZhbGlkX21ldGFfcmVwZWF0AFVua25vd24gcG1fZXJyb3JfbGV2ZWxfdABcdABhbWJpZ3VvdXNfZmlyc3RfYXJndW1lbnRfbWludXMAYW1iaWd1b3VzX2ZpcnN0X2FyZ3VtZW50X3BsdXMAcGF0dGVybl9hcnJheV9tdWx0aXBsZV9yZXN0cwBvcGVyYXRvcl93cml0ZV9hcmd1bWVudHMAdW5leHBlY3RlZCBvcGVyYXRvciBhZnRlciBhIGNhbGwgd2l0aCBhcmd1bWVudHMAdW5leHBlY3RlZCAlczsgZXhwZWN0ZWQgYSBgKWAgdG8gY2xvc2UgdGhlIGFyZ3VtZW50cwBzdGF0ZW1lbnRzAHVuZXhwZWN0ZWQgJXM7IGV4cGVjdGVkIGEgYCxgIHNlcGFyYXRvciBmb3IgdGhlIGFycmF5IGVsZW1lbnRzAHBtX2xvb3BfbW9kaWZpZXJfYmxvY2tfZXhpdHMAZmx1c2hfYmxvY2tfZXhpdHMAaW52YWxpZCBiaW5hcnkgbnVtYmVyOyBudW1lcmljIGxpdGVyYWwgd2l0aG91dCBkaWdpdHMAaW52YWxpZCBvY3RhbCBudW1iZXI7IG51bWVyaWMgbGl0ZXJhbCB3aXRob3V0IGRpZ2l0cwBpbnZhbGlkIGhleGFkZWNpbWFsIG51bWJlcjsgbnVtZXJpYyBsaXRlcmFsIHdpdGhvdXQgZGlnaXRzAGludmFsaWQgZGVjaW1hbCBudW1iZXI7IG51bWVyaWMgbGl0ZXJhbCB3aXRob3V0IGRpZ2l0cwBpbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlOyBtYXhpbXVtIGxlbmd0aCBpcyA2IGRpZ2l0cwBtdWx0aXBsZSB0YXJnZXRzAG11bHRpX2Fzc2lnbl9tdWx0aV9zcGxhdHMAdW5sZXNzAHVuZXhwZWN0ZWQgYGVsc2VgIGluIGBiZWdpbmAgYmxvY2s7IGVsc2Ugd2l0aG91dCByZXNjdWUgaXMgdXNlbGVzcwBkZWZfZW5kbGVzcwBleHBlY3RfZXhwcmVzc2lvbl9hZnRlcl9sZXNzX2xlc3MAY2xhc3Nfc3VwZXJjbGFzcwBhcmd1bWVudF9mb3JtYWxfY2xhc3MAaW5jb21wbGV0ZV92YXJpYWJsZV9jbGFzcwBlbXB0eSBjaGFyLWNsYXNzAHVuZXhwZWN0ZWQgJXM7IGV4cGVjdGVkIGEgbmV3bGluZSBvciBhICc7JyBhZnRlciB0aGUgc2luZ2xldG9uIGNsYXNzAGVycm9ycwBwYXJzZV9ibG9ja2xpa2VfcGFyYW1ldGVycwB1bmV4cGVjdGVkIG11bHRpcGxlIGAqYCBzcGxhdCBwYXJhbWV0ZXJzAHVuZXhwZWN0ZWQgbXVsdGlwbGUgYCoqYCBzcGxhdCBwYXJhbWV0ZXJzAHVuZXhwZWN0ZWQgYC4uLmAgaW4gcGFyYW1ldGVycwB1bmV4cGVjdGVkIGAsYCBpbiBwYXJhbWV0ZXJzAGV4cGVjdGVkIGEgbG9jYWwgdmFyaWFibGUgbmFtZSBpbiB0aGUgYmxvY2sgcGFyYW1ldGVycwBleHBlY3RlZCBhIGRlbGltaXRlciB0byBjbG9zZSB0aGUgcGFyYW1ldGVycwB1bmV4cGVjdGVkICVzOyBleHBlY3RlZCBhIGApYCB0byBjbG9zZSB0aGUgcGFyYW1ldGVycwBtZXRob2QgcGFyYW1ldGVycwAlLjJzIGlzIHJlc2VydmVkIGZvciBudW1iZXJlZCBwYXJhbWV0ZXJzAHJlZ2V4cF91bmtub3duX29wdGlvbnMAY2FzZV9taXNzaW5nX2NvbmRpdGlvbnMATGV4ZXIgc3RhbGxlZCBhZnRlciA1IGl0ZXJhdGlvbnMAdW5leHBlY3RlZCBibG9jayBhcmcgZ2l2ZW4gaW4gaW5kZXggYXNzaWdubWVudDsgYmxvY2tzIGFyZSBub3QgYWxsb3dlZCBpbiBpbmRleCBhc3NpZ25tZW50IGV4cHJlc3Npb25zAHVuZXhwZWN0ZWQga2V5d29yZCBhcmcgZ2l2ZW4gaW4gaW5kZXggYXNzaWdubWVudDsga2V5d29yZHMgYXJlIG5vdCBhbGxvd2VkIGluIGluZGV4IGFzc2lnbm1lbnQgZXhwcmVzc2lvbnMAJ2Zyb3plbl9zdHJpbmdfbGl0ZXJhbCcgaXMgaWdub3JlZCBhZnRlciBhbnkgdG9rZW5zAHNoZWJhbmcgbGluZSBlbmRpbmcgd2l0aCBcciBtYXkgY2F1c2UgcHJvYmxlbXMAZXVjLWpwLW1zAGV1Y0pQLW1zAGVxdWFscwBzaW5nbGV0b25fZm9yX2xpdGVyYWxzAGNhbm5vdCBkZWZpbmUgc2luZ2xldG9uIG1ldGhvZCBmb3IgbGl0ZXJhbHMAcGF0dGVybl9oYXNoX2tleV9sb2NhbHMAdW5leHBlY3RlZCAneycgYWZ0ZXIgYSBtZXRob2QgY2FsbCB3aXRob3V0IHBhcmVudGhlc2lzAHVubWF0Y2hlZCBjbG9zZSBwYXJlbnRoZXNpcwBlbmQgcGF0dGVybiB3aXRoIHVubWF0Y2hlZCBwYXJlbnRoZXNpcwBwYXJzZV9zdHJpbmdzAHdhcm5pbmdzAGVzY2FwZV9pbnZhbGlkX3VuaWNvZGVfY21fZmxhZ3MAaW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZTsgVW5pY29kZSBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBjb250cm9sIG9yIG1ldGEgZmxhZ3MAcGFyc2VfcmVzY3VlcwBhcmd1bWVudF9hZnRlcl9mb3J3YXJkaW5nX2VsbGlwc2VzAGFyZ3VtZW50X25vX2ZvcndhcmRpbmdfZWxsaXBzZXMAcGFyZW50aGVzZXMAaW52YWxpZCBhcmd1bWVudCBiZWluZyBwYXNzZWQgdG8gYGFsaWFzYDsgY2FuJ3QgbWFrZSBhbGlhcyBmb3IgdGhlIG51bWJlciB2YXJpYWJsZXMAa2V5IG11c3QgYmUgdmFsaWQgYXMgbG9jYWwgdmFyaWFibGVzAHBtX2NvbXBhcmVfbnVtYmVyX25vZGVzAHVuZXhwZWN0ZWRfaW5kZXhfa2V5d29yZHMAdW5leHBlY3RlZCAqKm5pbDsgbm8ga2V5d29yZHMgbWFya2VyIGRpc2FsbG93ZWQgYWZ0ZXIga2V5d29yZHMAcG1fbG9jYWxzX3JlYWRzAHBhcnNlX2Fzc29jcwBzdGF0ZW1lbnRfYWxpYXMAXHMAQ2FuJ3QgYXNzaWduIHRvIG51bWJlcmVkIHBhcmFtZXRlciAlLjJzAENhbid0IHNldCB2YXJpYWJsZSAlLipzAGludmFsaWQgVW5pY29kZSBsaXN0OiAlLipzAGludmFsaWQgdmFsdWUgZm9yICUuKnM6ICUuKnMAdG9vIHNob3J0IGVzY2FwZSBzZXF1ZW5jZTogJS4qcwB1bmtub3duIHJlZ2V4cCAlcyAtICUuKnMAYXNzaWduZWQgYnV0IHVudXNlZCB2YXJpYWJsZSAtICUuKnMAY2lyY3VsYXIgYXJndW1lbnQgcmVmZXJlbmNlIC0gJS4qcwBpbnZhbGlkIGNoYXJhY3RlciBzeW50YXg7IHVzZSAlcyVzJXMAdW5leHBlY3RlZCAlcywgYXNzdW1pbmcgaXQgaXMgY2xvc2luZyB0aGUgcGFyZW50ICVzACVzbGl0ZXJhbCBpbiAlcwAnJXMnIGFmdGVyIGxvY2FsIHZhcmlhYmxlIG9yIGxpdGVyYWwgaXMgaW50ZXJwcmV0ZWQgYXMgYmluYXJ5IG9wZXJhdG9yIGV2ZW4gdGhvdWdoIGl0IHNlZW1zIGxpa2UgJXMASW52YWxpZCAlcwAlczogJXMAJXM6JWQ6ICVzACpicmVha3BvaW50ID09IGxleF9tb2RlLT5hcy5saXN0LmluY3JlbWVudG9yAGFtYmlndW91c19iaW5hcnlfb3BlcmF0b3IAZXhwZWN0X2V4cHJlc3Npb25fYWZ0ZXJfb3BlcmF0b3IAbm9uX2Fzc29jaWF0aXZlX29wZXJhdG9yAHVuZXhwZWN0ZWRfcmFuZ2Vfb3BlcmF0b3IAdW5hcnkgb3BlcmF0b3IAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgP2AgaW4gdGhlIHRlcm5hcnkgb3BlcmF0b3IAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgOmAgaW4gdGhlIHRlcm5hcnkgb3BlcmF0b3IAZXhwZWN0ZWQgYSBgOmAgYWZ0ZXIgdGhlIHRydWUgZXhwcmVzc2lvbiBvZiBhIHRlcm5hcnkgb3BlcmF0b3IAZXhwZWN0ZWQgYSBwYXR0ZXJuIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIGBeYCBwaW4gb3BlcmF0b3IAdW5leHBlY3RlZCAlczsgJXMgaXMgYSBub24tYXNzb2NpYXRpdmUgb3BlcmF0b3IAdW5leHBlY3RlZCAlczsgZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciB0aGUgb3BlcmF0b3IAZXhwZWN0ZWQgYSBwYXR0ZXJuIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIHJhbmdlIG9wZXJhdG9yAGV4cGVjdGVkIGEgcGF0dGVybiBleHByZXNzaW9uIGFmdGVyIHRoZSBgfGAgb3BlcmF0b3IAZXhwZWN0ZWQgYSBwYXR0ZXJuIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIGBbYCBvcGVyYXRvcgBleHBlY3RlZCBhbiBpZGVudGlmaWVyIGFmdGVyIHRoZSBgPT5gIG9wZXJhdG9yAGV4cGVjdGVkIGEgY29uc3RhbnQgYWZ0ZXIgdGhlIGA6OmAgb3BlcmF0b3IAYW1iaWd1b3VzIGAvYDsgd3JhcCByZWdleHAgaW4gcGFyZW50aGVzZXMgb3IgYWRkIGEgc3BhY2UgYWZ0ZXIgYC9gIG9wZXJhdG9yAGFtYmlndW91cyBmaXJzdCBhcmd1bWVudDsgcHV0IHBhcmVudGhlc2VzIG9yIGEgc3BhY2UgZXZlbiBhZnRlciBgLWAgb3BlcmF0b3IAYW1iaWd1b3VzIGZpcnN0IGFyZ3VtZW50OyBwdXQgcGFyZW50aGVzZXMgb3IgYSBzcGFjZSBldmVuIGFmdGVyIGArYCBvcGVyYXRvcgBleHBlY3RlZCBhIHBhdHRlcm4gZXhwcmVzc2lvbiBhZnRlciB0aGUgYChgIG9wZXJhdG9yAGFycmF5X3NlcGFyYXRvcgBzdHJpbmcgc2VwYXJhdG9yAGxhYmVsIHRlcm1pbmF0b3IAdW5leHBlY3RlZCAlcywgZXhwZWN0ZWQgYSBzdHJpbmcgbGl0ZXJhbCB0ZXJtaW5hdG9yAHJlZ2V4cF9wYXJzZV9lcnJvcgBUb2tlbiBFcnJvcgBmb3IAaHIAcGFyc2UgZGVwdGggbGltaXQgb3ZlcgB1bmFyeV9yZWNlaXZlcgBkZWZfcmVjZWl2ZXIAdW5leHBlY3RlZCAlczsgZXhwZWN0aW5nIGEgbWVzc2FnZSB0byBzZW5kIHRvIHRoZSByZWNlaXZlcgBkZWZfZW5kbGVzc19zZXR0ZXIAZXhwZWN0X3NpbmdsZXRvbl9jbGFzc19kZWxpbWl0ZXIAZXhwZWN0X2Zvcl9kZWxpbWl0ZXIAZXhwZWN0X2luX2RlbGltaXRlcgBleHBlY3Rfd2hlbl9kZWxpbWl0ZXIAdW50ZXJtaW5hdGVkIHJlZ2V4cCBtZWV0cyBlbmQgb2YgZmlsZTsgZXhwZWN0ZWQgYSBjbG9zaW5nIGRlbGltaXRlcgBleHBlY3RlZCBzdHJpbmcgY29udGVudCBhZnRlciBvcGVuaW5nIHN0cmluZyBkZWxpbWl0ZXIAZXhwZWN0X2lkZW50X3JlcV9wYXJhbWV0ZXIAZXhwZWN0X3JwYXJlbl9yZXFfcGFyYW1ldGVyAGV4cGVjdF9scGFyZW5fcmVxX3BhcmFtZXRlcgBwbV9ub2RlX2ZsYWdfc2V0X3JlcGVhdGVkX3BhcmFtZXRlcgB1bmV4cGVjdGVkIGAqYDsgbm8gYW5vbnltb3VzIHJlc3QgcGFyYW1ldGVyAHVuZXhwZWN0ZWQgYCoqYDsgbm8gYW5vbnltb3VzIGtleXdvcmQgcmVzdCBwYXJhbWV0ZXIAdW5leHBlY3RlZCBgJmA7IG5vIGFub255bW91cyBibG9jayBwYXJhbWV0ZXIAZXhwZWN0ZWQgYSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgcGFyYW1ldGVyAGV4cGVjdGVkIGEgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGtleXdvcmQgcGFyYW1ldGVyAGV4cGVjdGVkIGFuIGlkZW50aWZpZXIgZm9yIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXIAZXhwZWN0ZWQgYSBgKGAgdG8gc3RhcnQgYSByZXF1aXJlZCBwYXJhbWV0ZXIAZXhwZWN0ZWQgYSBgKWAgdG8gZW5kIGEgcmVxdWlyZWQgcGFyYW1ldGVyAHVuZXhwZWN0ZWQgbmFtZSBmb3IgYSBwYXJhbWV0ZXIAaW52YWxpZF9tdWx0aWJ5dGVfY2hhcmFjdGVyAGludmFsaWRfZXNjYXBlX2NoYXJhY3RlcgBpbnZhbGlkX3ByaW50YWJsZV9jaGFyYWN0ZXIAaW52YWxpZF9jaGFyYWN0ZXIAc3VwZXIAcGF0dGVybl9maW5kX21pc3NpbmdfaW5uZXIAaW52YWxpZF9udW1iZXJfdW5kZXJzY29yZV9pbm5lcgBoZXJlZG9jX2lkZW50aWZpZXIAdW50ZXJtaW5hdGVkIGhlcmUgZG9jdW1lbnQgaWRlbnRpZmllcgBwYXJzZV9hbmRfdmFsaWRhdGVfcmVndWxhcl9leHByZXNzaW9uX2VuY29kaW5nX21vZGlmaWVyAGV4cGVjdGVkIGEgdmFsdWUgYWZ0ZXIgdGhlIGByZXNjdWVgIG1vZGlmaWVyACdyZXNjdWUnIG1vZGlmaWVyAGV4cGVjdF9scGFyZW5fYWZ0ZXJfbm90X290aGVyAGludGVnZXIAcGFyYW1ldGVyX29yZGVyAHVuZXhwZWN0ZWQgcGFyYW1ldGVyIG9yZGVyAHBtX251bWJlcmVkX3JlZmVyZW5jZV9yZWFkX25vZGVfbnVtYmVyAGludmFsaWQgdW5kZXJzY29yZSBwbGFjZW1lbnQgaW4gbnVtYmVyAHRyYWlsaW5nICdfJyBpbiBudW1iZXIAd2JyAGFyZ3VtZW50X2Zvcm1hbF9pdmFyAGFtYmlndW91c19wcmVmaXhfc3RhcgBhcmd1bWVudF9jb25mbGljdF9zdGFyAGFycmF5X2V4cHJlc3Npb25fYWZ0ZXJfc3RhcgBleHBlY3RfZXhwcmVzc2lvbl9hZnRlcl9zdGFyAHBhcmFtZXRlcl9zdGFyAGFtYmlndW91c19wcmVmaXhfc3Rhcl9zdGFyAGFyZ3VtZW50X2NvbmZsaWN0X3N0YXJfc3RhcgBhcmd1bWVudF9ub19mb3J3YXJkaW5nX3N0YXJfc3RhcgBhcmd1bWVudF9ub19mb3J3YXJkaW5nX3N0YXIAcGFyYW1ldGVyX2NpcmN1bGFyAGludmFsaWRfbXVsdGlieXRlX2NoYXIAdW5zaWduZWQgY2hhcgBccgBleHBlY3RfZXhwcmVzc2lvbl9hZnRlcl9hbXBhbXBlcQBleHBlY3RfZXhwcmVzc2lvbl9hZnRlcl9waXBlcGlwZWVxAHJlZ2V4cF91dGY4X2NoYXJfbm9uX3V0ZjhfcmVnZXhwAGVuZCBwYXR0ZXJuIGluIGdyb3VwAC9lbXNkay9lbXNjcmlwdGVuL3N5c3RlbS9saWIvbGliY3h4YWJpL3NyYy9wcml2YXRlX3R5cGVpbmZvLmNwcABmb3IgbG9vcABleHBlY3RlZCBhbiBgZW5kYCB0byBjbG9zZSB0aGUgYGZvcmAgbG9vcABpbnRlZ2VyX2luX2ZsaXBfZmxvcABpbnRlZ2VyIGxpdGVyYWwgaW4gZmxpcC1mbG9wAGNob21wAG5lc3RpbmdfdG9vX2RlZXAAbmVzdGluZyB0b28gZGVlcAB0b2tlbl9iZWdpbnNfZXhwcmVzc2lvbl9wAHBtX3BhcnNlcl9zY29wZV90b3BsZXZlbF9wAHBtX3N0YXRpY19saXRlcmFsX3Bvc2l0aXZlX3AAbWFjQ2VudEV1cm8AcmVkbwBTSklTLURvQ29NbwBVVEY4LURvQ29NbwBVbmtub3duAHBhcnNlX3JldHVybgBzaGViYW5nX2NhcnJpYWdlX3JldHVybgB1bmV4cGVjdGVkX2NhcnJpYWdlX3JldHVybgBlc2NhcGVkIGNhcnJpYWdlIHJldHVybgB1bmV4cGVjdGVkIG11bHRpcGxlICcqJyByZXN0IHBhdHRlcm5zIGluIGFuIGFycmF5IHBhdHRlcm4AdW5leHBlY3RlZCByZXN0IHBhdHRlcm4AZmluZCBwYXR0ZXJucyBuZWVkIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBpbm5lciBwYXR0ZXJuAGV4cGVjdGVkIGEgbGFiZWwgYXMgdGhlIGtleSBpbiB0aGUgaGFzaCBwYXR0ZXJuAHVuZXhwZWN0ZWQgJXM7IGV4cGVjdGVkIGEga2V5IGluIHRoZSBoYXNoIHBhdHRlcm4AZXhwZWN0ZWQgYSBsYWJlbCBhZnRlciB0aGUgYCxgIGluIHRoZSBoYXNoIHBhdHRlcm4AY29tcGFyaXNvbl9hZnRlcl9jb21wYXJpc29uAGNvbXBhcmlzb24gJyUuKnMnIGFmdGVyIGNvbXBhcmlzb24AdGVybmFyeV9jb2xvbgBleHBlY3RfZXhwcmVzc2lvbl9hZnRlcl9xdWVzdGlvbgB1bmRlZmluZWQgZ3JvdXAgb3B0aW9uAGRlc2NyaXB0aW9uAHVuZXhwZWN0ZWQgYW4gYGFsaWFzYCBhdCBhIG5vbi1zdGF0ZW1lbnQgcG9zaXRpb24AdW5leHBlY3RlZCBhbiBgdW5kZWZgIGF0IGEgbm9uLXN0YXRlbWVudCBwb3NpdGlvbgB1bmV4cGVjdGVkIGEgYEJFR0lOYCBhdCBhIG5vbi1zdGF0ZW1lbnQgcG9zaXRpb24AdW5leHBlY3RlZCBhbiBgRU5EYCBhdCBhIG5vbi1zdGF0ZW1lbnQgcG9zaXRpb24Ac2luZ2xldG9uIGNsYXNzIGRlZmluaXRpb24AbW9kdWxlIGRlZmluaXRpb24AaW52YWxpZCBtZXRob2QgbmFtZTsgYSBzZXR0ZXIgbWV0aG9kIGNhbm5vdCBiZSBkZWZpbmVkIGluIGFuIGVuZGxlc3MgbWV0aG9kIGRlZmluaXRpb24AZXhwZWN0ZWQgYSByZWNlaXZlciBmb3IgdGhlIG1ldGhvZCBkZWZpbml0aW9uAGV4cGVjdGVkIGEgYC5gIG9yIGA6OmAgYWZ0ZXIgdGhlIHJlY2VpdmVyIGluIGEgbWV0aG9kIGRlZmluaXRpb24AY29uZGl0aW9uAGZvcl9jb2xsZWN0aW9uAHVuZXhwZWN0ZWQgJXM7IGV4cGVjdGVkIGEgJ2RvJywgbmV3bGluZSwgb3IgJzsnIGFmdGVyIHRoZSAnZm9yJyBsb29wIGNvbGxlY3Rpb24AaW52YWxpZF9udW1iZXJfZnJhY3Rpb24AJi4gaW5zaWRlIG11bHRpcGxlIGFzc2lnbm1lbnQgZGVzdGluYXRpb24Ac3RyaW5nX2NvbmNhdGVuYXRpb24AZXhwZWN0ZWQgYSBzdHJpbmcgZm9yIGNvbmNhdGVuYXRpb24AdW5leHBlY3RlZF9zYWZlX25hdmlnYXRpb24AbG9jYXRpb24AYXJyYXlfZXhwcmVzc2lvbgBub3RfZXhwcmVzc2lvbgByZXNjdWVfZXhwcmVzc2lvbgBjYW5ub3RfcGFyc2VfZXhwcmVzc2lvbgB2b2lkX2V4cHJlc3Npb24AZGVmaW5lZF9leHByZXNzaW9uAHRlcm5hcnkgZXhwcmVzc2lvbgBleHBlY3RlZCBhIGB9YCB0byBjbG9zZSB0aGUgcGF0dGVybiBleHByZXNzaW9uAGV4cGVjdGVkIGEgYF1gIHRvIGNsb3NlIHRoZSBwYXR0ZXJuIGV4cHJlc3Npb24AZXhwZWN0ZWQgYSBgKWAgdG8gY2xvc2UgdGhlIHBhdHRlcm4gZXhwcmVzc2lvbgB1bmV4cGVjdGVkIGJhcmUgaGFzaCBpbiBleHByZXNzaW9uAEludmFsaWQgY2hhciAnXHglMDJYJyBpbiBleHByZXNzaW9uAGAlLipzYCBhdCB0aGUgZW5kIG9mIGxpbmUgd2l0aG91dCBhbiBleHByZXNzaW9uAHVuZXhwZWN0ZWQgdm9pZCB2YWx1ZSBleHByZXNzaW9uAGNhbm5vdCBwYXJzZSB0aGUgZXhwcmVzc2lvbgBleHBlY3RlZCBhIHJlc2N1ZWQgZXhwcmVzc2lvbgBleHBlY3RlZCBhIGB9YCB0byBjbG9zZSB0aGUgZW1iZWRkZWQgZXhwcmVzc2lvbgB1bmV4cGVjdGVkIHBhdHRlcm4gZXhwcmVzc2lvbiBhZnRlciB0aGUgYCoqYCBleHByZXNzaW9uACdkZWZpbmVkPycgZXhwcmVzc2lvbgB2ZXJzaW9uAHBtX25ld2xpbmVfbGlzdF9saW5lX2NvbHVtbgBwYXR0ZXJuX2V4cHJlc3Npb25fYWZ0ZXJfcGluAHN0YXRlbWVudF9wcmVleGVfYmVnaW4AZm9yX2luAHBhdHRlcm5fZXhwcmVzc2lvbl9hZnRlcl9pbgBvcGVyYXRvcl9tdWx0aV9hc3NpZ24AYW1wYW1wZXFfbXVsdGlfYXNzaWduAHBpcGVwaXBlZXFfbXVsdGlfYXNzaWduAGJsb2NrIGFyZ3VtZW50IHNob3VsZCBub3QgYmUgZ2l2ZW4AdW5leHBlY3RlZCAnPSc7IHRhcmdldCBjYW5ub3QgYmUgd3JpdHRlbgBjaGlsZHJlbgBleHBlY3RfcnBhcmVuAGV4cGVjdF9scGFyZW5fYWZ0ZXJfbm90X2xwYXJlbgBleHBlY3RfZXhwcmVzc2lvbl9hZnRlcl9scGFyZW4AcGF0dGVybl9leHByZXNzaW9uX2FmdGVyX3BhcmVuAGFyZ3VtZW50X3Rlcm1fcGFyZW4AZGVmX3BhcmFtc190ZXJtX3BhcmVuAHBhdHRlcm5fdGVybV9wYXJlbgBsYW1iZGFfb3BlbgBtaXNzaW5nIHRva2VuAFVuZXhwZWN0ZWQgdG9rZW4Abm90IHByb3ZpZGVkIHRva2VuAFVuZXhwZWN0ZWQgVG9rZW4AY2FzZV9leHByZXNzaW9uX2FmdGVyX3doZW4AdGhlbgBNYWNKYXBhbgBuYW4AY29udGV4dF9odW1hbgBwbV90b2tlbl90eXBlX2h1bWFuAHBtX2RpYWdub3N0aWNfaWRfaHVtYW4AbWFjUm9tYW4AbWFjQ3JvYXRpYW4AXG4AYXJyYXlfdGVybQBjbGFzc190ZXJtAGRlZl9wYXJhbXNfdGVybQBmb3JfdGVybQBsaXN0X3dfbG93ZXJfdGVybQBsaXN0X2lfbG93ZXJfdGVybQBkZWZfcmVjZWl2ZXJfdGVybQBsaXN0X3dfdXBwZXJfdGVybQBsaXN0X2lfdXBwZXJfdGVybQByZWdleHBfdGVybQBiZWdpbl90ZXJtAHVudGlsX3Rlcm0Ac3RyaW5nX2xpdGVyYWxfdGVybQBjb25kaXRpb25hbF90ZXJtAGhhc2hfdGVybQB4c3RyaW5nX3Rlcm0AZGVmX3Rlcm0AcmVzY3VlX3Rlcm0AY29uZGl0aW9uYWxfcHJlZGljYXRlX3Rlcm0AYmVnaW5fdXBjYXNlX3Rlcm0AZW5kX3VwY2FzZV90ZXJtAGJsb2NrX3BhcmFtX3BpcGVfdGVybQBtb2R1bGVfdGVybQB3aGlsZV90ZXJtAGVzY2FwZV9pbnZhbGlkX3VuaWNvZGVfdGVybQBzdHJpbmdfaW50ZXJwb2xhdGVkX3Rlcm0AaGVyZWRvY190ZXJtAGVtYmRvY190ZXJtAFNsaW0AcGFyc2VfcHJvZ3JhbQBwYXJhbQBlc2NhcGVfaW52YWxpZF9jb250cm9sAGJvb2wAZG90X2RvdF9kb3RfZW9sAGtleXdvcmRfZW9sAGNvbABpbnZhbGlkX3N5bWJvbABpbnZhbGlkIHN5bWJvbAB1bnRlcm1pbmF0ZWQgc3ltYm9sOyBleHBlY3RlZCBhIGNsb3NpbmcgZGVsaW1pdGVyIGZvciB0aGUgaW50ZXJwb2xhdGVkIHN5bWJvbAB1bnRlcm1pbmF0ZWQgcXVvdGVkIHN0cmluZzsgZXhwZWN0ZWQgYSBjbG9zaW5nIGRlbGltaXRlciBmb3IgdGhlIGR5bmFtaWMgc3ltYm9sADw/eG1sAEhhbWwAdW5leHBlY3RlZCBgLi4uYCBpbiBhbiBub24tcGFyZW50aGVzaXplZCBjYWxsAHVudGlsAGV4cHJlc3Npb25fbm90X3dyaXRhYmxlX25pbAAnJS4qcycgaXMgdG9vIGJpZyBmb3IgYSBudW1iZXIgdmFyaWFibGUsIGFsd2F5cyBuaWwAQ2FuJ3QgYXNzaWduIHRvIG5pbABiZWdpbl91cGNhc2VfdG9wbGV2ZWwAQkVHSU4gaXMgcGVybWl0dGVkIG9ubHkgYXQgdG9wbGV2ZWwAcG1fZGlhZ25vc3RpY19sZXZlbABwYXR0ZXJuX2hhc2hfa2V5X2xhYmVsAGhhc2hfZXhwcmVzc2lvbl9hZnRlcl9sYWJlbAB1bmV4cGVjdGVkX2xhYmVsAHVuZXhwZWN0ZWQgbGFiZWwAZXhwZWN0X2V4cHJlc3Npb25fYWZ0ZXJfZXF1YWwAaW52YWxpZF9udW1iZXJfb2N0YWwAaWdub3JlZF9mcm96ZW5fc3RyaW5nX2xpdGVyYWwAZXNjYXBlX2ludmFsaWRfdW5pY29kZV9saXRlcmFsAGNoYXJhY3RlciBsaXRlcmFsAHJlZ2V4cCBsaXRlcmFsAHN5bWJvbCBsaXRlcmFsAHVuZXhwZWN0ZWQgJXMsIGV4cGVjdGluZyAnfScgb3IgYSBrZXkgaW4gdGhlIGhhc2ggbGl0ZXJhbAB1bmV4cGVjdGVkICVzOyBleHBlY3RlZCBhIHZhbHVlIGluIHRoZSBoYXNoIGxpdGVyYWwAZXhwZWN0ZWQgYSBgfWAgdG8gY2xvc2UgdGhlIGhhc2ggbGl0ZXJhbABzdHJpbmcgbGl0ZXJhbAB1bmV4cGVjdGVkIGZyYWN0aW9uIHBhcnQgYWZ0ZXIgbnVtZXJpYyBsaXRlcmFsAGEgbGl0ZXJhbABlcXVhbF9pbl9jb25kaXRpb25hbABwYXJzZV9jb25kaXRpb25hbAByYXRpb25hbABpbnZhbGlkX251bWJlcl9oZXhhZGVjaW1hbABlc2NhcGVfaW52YWxpZF9oZXhhZGVjaW1hbABpbnZhbGlkX251bWJlcl9kZWNpbWFsAGFyZ3VtZW50X2Zvcm1hbF9nbG9iYWwAaW52YWxpZF92YXJpYWJsZV9nbG9iYWwAaW5jb21wbGV0ZV9xdWVzdGlvbl9tYXJrAGxpbmsAU0pJUy1Tb2Z0QmFuawBVVEY4LVNvZnRCYW5rAG1hY0dyZWVrAHVuZXhwZWN0ZWRfaW5kZXhfYmxvY2sAbnVtYmVyZWRfcGFyYW1ldGVyX291dGVyX2Jsb2NrAGFyZ3VtZW50X2FmdGVyX2Jsb2NrAG51bWJlcmVkX3BhcmFtZXRlcl9pbm5lcl9ibG9jawBvcGVyYXRvcl93cml0ZV9ibG9jawBwYXJzZV9ibG9jawBhcmd1bWVudF91bmV4cGVjdGVkX2Jsb2NrAG51bWJlcmVkIHBhcmFtZXRlciBpcyBhbHJlYWR5IHVzZWQgaW4gb3V0ZXIgYmxvY2sAbnVtYmVyZWQgcGFyYW1ldGVyIGlzIGFscmVhZHkgdXNlZCBpbiBpbm5lciBibG9jawB1bmV4cGVjdGVkIGAqYDsgYW5vbnltb3VzIHJlc3QgcGFyYW1ldGVyIGlzIGFsc28gdXNlZCB3aXRoaW4gYmxvY2sAdW5leHBlY3RlZCBgKipgOyBhbm9ueW1vdXMga2V5d29yZCByZXN0IHBhcmFtZXRlciBpcyBhbHNvIHVzZWQgd2l0aGluIGJsb2NrAHVuZXhwZWN0ZWQgYCZgOyBhbm9ueW1vdXMgYmxvY2sgcGFyYW1ldGVyIGlzIGFsc28gdXNlZCB3aXRoaW4gYmxvY2sAZXhwZWN0ZWQgYSBgZG9gIGtleXdvcmQgb3IgYSBge2AgdG8gb3BlbiB0aGUgbGFtYmRhIGJsb2NrACd7Jy4uJ30nIGxhbWJkYSBibG9jawAnZG8nLi4nZW5kJyBsYW1iZGEgYmxvY2sAdW5leHBlY3RlZCBvcGVyYXRvciBhZnRlciBhIGNhbGwgd2l0aCBhIGJsb2NrACd7Jy4uJ30nIGJsb2NrACdkbycuLidlbmQnIGJsb2NrACdCRUdJTicgYmxvY2sAJ0VORCcgYmxvY2sAcG1fdm9pZF9zdGF0ZW1lbnRzX2NoZWNrAHRyYWNrAGJyZWFrAHBhcmFtZXRlcl9zcGxhdF9tdWx0aQBwYXJhbWV0ZXJfYXNzb2Nfc3BsYXRfbXVsdGkAZXhwZWN0X3JwYXJlbl9hZnRlcl9tdWx0aQBhcmd1bWVudF9ibG9ja19tdWx0aQBwYXJhbWV0ZXJfYmxvY2tfbXVsdGkAbWFjVGhhaQBtaXNtYXRjaGVkIGluZGVudGF0aW9ucyBhdCAnJS4qcycgd2l0aCAnJS4qcycgYXQgJWkAa2V5ICUuKnMgaXMgZHVwbGljYXRlZCBhbmQgb3ZlcndyaXR0ZW4gb24gbGluZSAlaQBpbmRleCA8PSBidWZmZXItPmxlbmd0aABwbV9lbmNvZGluZ191dGZfOF9jaGFyX3dpZHRoAHB1c2gAbWFjVHVya2lzaABiYWNrc2xhc2gAYW1iaWd1b3VzX3NsYXNoAGV4cGVjdF9leHByZXNzaW9uX2FmdGVyX3NwbGF0X2hhc2gAYXJndW1lbnRfYmFyZV9oYXNoAGV4cHJlc3Npb25fYmFyZV9oYXNoAG5vZGVfaGFzaABleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIHRoZSBsYWJlbCBpbiBhIGhhc2gAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgKipgIGluIGEgaGFzaAByZWdleHBfZW5jb2Rpbmdfb3B0aW9uX21pc21hdGNoAGluZGVudGF0aW9uX21pc21hdGNoAHN2ZwBlc2NhcGVfaW52YWxpZF91bmljb2RlX2xvbmcAdW5zaWduZWQgbG9uZyBsb25nAHVuc2lnbmVkIGxvbmcAdGFnX2Nsb3NpbmcAc3RkOjp3c3RyaW5nAGJhc2ljX3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwB1bmtub3duIHR5cGUgb2YgJXN0cmluZwBleHBlY3RlZCBhIGNsb3NpbmcgZGVsaW1pdGVyIGZvciB0aGUgYCV4YCBvciBiYWNrdGljayBzdHJpbmcAdW50ZXJtaW5hdGVkIHN0cmluZzsgZXhwZWN0ZWQgYSBjbG9zaW5nIGRlbGltaXRlciBmb3IgdGhlIGludGVycG9sYXRlZCBzdHJpbmcAcmVndWxhciBleHByZXNzaW9uIGJlZ2lubmluZwBoZXJlZG9jIGJlZ2lubmluZwB0YWdfb3BlbmluZwBpbnZhbGlkX251bWJlcl91bmRlcnNjb3JlX3RyYWlsaW5nAGV4cGVyaW1lbnRhbF9ldmVyeXRoaW5nAGFyZ3VtZW50X2Jsb2NrX2ZvcndhcmRpbmcAdW5leHBlY3RlZCAuLi4gd2hlbiB0aGUgcGFyZW50IG1ldGhvZCBpcyBub3QgZm9yd2FyZGluZwByZWdleHBfaW5jb21wYXRfY2hhcl9lbmNvZGluZwBleHByZXNzaW9uX25vdF93cml0YWJsZV9lbmNvZGluZwBtaXhlZF9lbmNvZGluZwByZWd1bGFyIGV4cHJlc3Npb24gZW5kaW5nAHN0cmluZyBlbmRpbmcAaGVyZWRvYyBlbmRpbmcAaW1nAG9wZW5fdGFnAGNsb3NpbmdfdGFnAG9wZW5pbmdfdGFnAGNsb3NlX3RhZwBIVE1MT3BlblRhZyBvciBIVE1MU2VsZkNsb3NlVGFnACVnAGludmFsaWRfcGVyY2VudF9lb2YAc3RyaW5nX2xpdGVyYWxfZW9mAGluZgBleHByZXNzaW9uX25vdF93cml0YWJsZV9zZWxmAENhbid0IGNoYW5nZSB0aGUgdmFsdWUgb2Ygc2VsZgBlbHNpZgBzdGF0ZW1lbnRfdW5kZWYAXGYAcG1fbG9jYWxzX3Jlc2l6ZQBwbV9jb25zdGFudF9wb29sX3Jlc2l6ZQBjb25zdGFudF9pZCAhPSBQTV9DT05TVEFOVF9JRF9VTlNFVCAmJiBjb25zdGFudF9pZCA8PSBwb29sLT5zaXplAHRlcm5hcnlfZXhwcmVzc2lvbl90cnVlAGV4cHJlc3Npb25fbm90X3dyaXRhYmxlX3RydWUAQ2FuJ3QgYXNzaWduIHRvIHRydWUAaW52YWxpZF9tYWdpY19jb21tZW50X3ZhbHVlAHNoYXJlYWJsZV9jb25zdGFudF92YWx1ZQByZXNjdWVfbW9kaWZpZXJfdmFsdWUAaGFzaF92YWx1ZQBwbV9zdHJpbmdfdmFsdWUAcG1faW50NjRfdmFsdWUAcGFyYW1ldGVyIGRlZmF1bHQgdmFsdWUAVW5lc2NhcGVkIHF1b3RlIGNoYXJhY3RlciBpbiBhdHRyaWJ1dGUgdmFsdWUAZXhwZWN0ZWQgYSBgPT5gIGJldHdlZW4gdGhlIGhhc2gga2V5IGFuZCB2YWx1ZQBpbnZhbGlkX3JldHJ5X3dpdGhvdXRfcmVzY3VlAEludmFsaWQgcmV0cnkgd2l0aG91dCByZXNjdWUASW52YWxpZCBxdW90ZSBjaGFyYWN0ZXIgZm9yIEhUTUwgYXR0cmlidXRlAG9wZW5fcXVvdGUAY2xvc2luZ19xdW90ZQBvcGVuaW5nX3F1b3RlAGNsb3NlX3F1b3RlAHBtX2xvY2Fsc193cml0ZQB1bmV4cGVjdGVkX211bHRpX3dyaXRlAGludmFsaWRfbG9jYWxfdmFyaWFibGVfd3JpdGUAcG1fZmxvYXRfbm9kZV9yYXRpb25hbF9pbWFnaW5hcnlfY3JlYXRlAHBtX2ludGVnZXJfbm9kZV9yYXRpb25hbF9pbWFnaW5hcnlfY3JlYXRlAHBtX2Zsb2F0X25vZGVfaW1hZ2luYXJ5X2NyZWF0ZQBwbV9pbnRlZ2VyX25vZGVfaW1hZ2luYXJ5X2NyZWF0ZQBwbV9oYXNoX3BhdHRlcm5fbm9kZV9ub2RlX2xpc3RfY3JlYXRlAHBtX2NhbGxfbm9kZV9ub3RfY3JlYXRlAHBtX3N5bWJvbF9ub2RlX2xhYmVsX2NyZWF0ZQBwbV9mbG9hdF9ub2RlX3JhdGlvbmFsX2NyZWF0ZQBwbV9pbnRlZ2VyX25vZGVfcmF0aW9uYWxfY3JlYXRlAHBtX3JldHJ5X25vZGVfY3JlYXRlAHBtX25leHRfbm9kZV9jcmVhdGUAcG1faW1wbGljaXRfcmVzdF9ub2RlX2NyZWF0ZQBwbV9pbmRleF90YXJnZXRfbm9kZV9jcmVhdGUAcG1fZmxvYXRfbm9kZV9jcmVhdGUAcG1fYXNzb2Nfc3BsYXRfbm9kZV9jcmVhdGUAcG1fZm9yd2FyZGluZ19hcmd1bWVudHNfbm9kZV9jcmVhdGUAcG1fbm9fa2V5d29yZHNfcGFyYW1ldGVyX25vZGVfY3JlYXRlAHBtX2Jsb2NrX3BhcmFtZXRlcl9ub2RlX2NyZWF0ZQBwbV9mb3J3YXJkaW5nX3BhcmFtZXRlcl9ub2RlX2NyZWF0ZQBwbV9zdXBlcl9ub2RlX2NyZWF0ZQBwbV9mb3J3YXJkaW5nX3N1cGVyX25vZGVfY3JlYXRlAHBtX2ludGVnZXJfbm9kZV9jcmVhdGUAcG1fcmVkb19ub2RlX2NyZWF0ZQBwbV9maW5kX3BhdHRlcm5fbm9kZV9jcmVhdGUAcG1fbmlsX25vZGVfY3JlYXRlAHBtX2JyZWFrX25vZGVfY3JlYXRlAHBtX2hhc2hfbm9kZV9jcmVhdGUAcG1fc291cmNlX2VuY29kaW5nX25vZGVfY3JlYXRlAHBtX3NlbGZfbm9kZV9jcmVhdGUAcG1fdW5kZWZfbm9kZV9jcmVhdGUAcG1fdHJ1ZV9ub2RlX2NyZWF0ZQBwbV9pbmRleF9vcGVyYXRvcl93cml0ZV9ub2RlX2NyZWF0ZQBwbV9jYWxsX29wZXJhdG9yX3dyaXRlX25vZGVfY3JlYXRlAHBtX2luZGV4X29yX3dyaXRlX25vZGVfY3JlYXRlAHBtX2NvbnN0YW50X29yX3dyaXRlX25vZGVfY3JlYXRlAHBtX2NhbGxfb3Jfd3JpdGVfbm9kZV9jcmVhdGUAcG1fY29uc3RhbnRfcGF0aF9vcl93cml0ZV9ub2RlX2NyZWF0ZQBwbV9jbGFzc192YXJpYWJsZV9vcl93cml0ZV9ub2RlX2NyZWF0ZQBwbV9sb2NhbF92YXJpYWJsZV9vcl93cml0ZV9ub2RlX2NyZWF0ZQBwbV9nbG9iYWxfdmFyaWFibGVfb3Jfd3JpdGVfbm9kZV9jcmVhdGUAcG1faW5zdGFuY2VfdmFyaWFibGVfb3Jfd3JpdGVfbm9kZV9jcmVhdGUAcG1faW5kZXhfYW5kX3dyaXRlX25vZGVfY3JlYXRlAHBtX2NvbnN0YW50X2FuZF93cml0ZV9ub2RlX2NyZWF0ZQBwbV9jYWxsX2FuZF93cml0ZV9ub2RlX2NyZWF0ZQBwbV9jb25zdGFudF9wYXRoX2FuZF93cml0ZV9ub2RlX2NyZWF0ZQBwbV9jbGFzc192YXJpYWJsZV9hbmRfd3JpdGVfbm9kZV9jcmVhdGUAcG1fbG9jYWxfdmFyaWFibGVfYW5kX3dyaXRlX25vZGVfY3JlYXRlAHBtX2dsb2JhbF92YXJpYWJsZV9hbmRfd3JpdGVfbm9kZV9jcmVhdGUAcG1faW5zdGFuY2VfdmFyaWFibGVfYW5kX3dyaXRlX25vZGVfY3JlYXRlAHBtX2ZhbHNlX25vZGVfY3JlYXRlAHBtX3NvdXJjZV9saW5lX25vZGVfY3JlYXRlAHBtX3NvdXJjZV9maWxlX25vZGVfY3JlYXRlAHBtX2FsaWFzX2dsb2JhbF92YXJpYWJsZV9ub2RlX2NyZWF0ZQBwbV9hbGlhc19tZXRob2Rfbm9kZV9jcmVhdGUAcG1fY29uc3RhbnRfcmVhZF9ub2RlX2NyZWF0ZQBwbV9jbGFzc192YXJpYWJsZV9yZWFkX25vZGVfY3JlYXRlAHBtX2luc3RhbmNlX3ZhcmlhYmxlX3JlYWRfbm9kZV9jcmVhdGUAcG1fYmFja19yZWZlcmVuY2VfcmVhZF9ub2RlX2NyZWF0ZQBwbV9udW1iZXJlZF9yZWZlcmVuY2VfcmVhZF9ub2RlX2NyZWF0ZQB1bmV4cGVjdGVkIGltcGxpY2l0IGhhc2ggaW4gcGF0dGVybjsgdXNlICd7JyB0byBkZWxpbmVhdGUAcGF0dGVybl9oYXNoX2tleV9kdXBsaWNhdGUAcGF0dGVybl9jYXB0dXJlX2R1cGxpY2F0ZQBjb25kaXRpb25hbF91bmxlc3NfcHJlZGljYXRlAGNvbmRpdGlvbmFsX3VudGlsX3ByZWRpY2F0ZQBjYXNlX21hdGNoX21pc3NpbmdfcHJlZGljYXRlAGNvbmRpdGlvbmFsX2Vsc2lmX3ByZWRpY2F0ZQBjb25kaXRpb25hbF9pZl9wcmVkaWNhdGUAY29uZGl0aW9uYWxfd2hpbGVfcHJlZGljYXRlAGxvb3AgcHJlZGljYXRlAGR1cGxpY2F0ZWRfd2hlbl9jbGF1c2UAcmVzY3VlX2NsYXVzZQBlbHNlX2NsYXVzZQBlbnN1cmVfY2xhdXNlAGV4cGVjdGVkIGFuIGBlbmRgIHRvIGNsb3NlIHRoZSBjb25kaXRpb25hbCBjbGF1c2UAZXhwZWN0ZWQgYSBkZWxpbWl0ZXIgYWZ0ZXIgdGhlIHBhdHRlcm5zIG9mIGFuIGBpbmAgY2xhdXNlAGV4cGVjdGVkIGEgZGVsaW1pdGVyIGFmdGVyIHRoZSBwcmVkaWNhdGVzIG9mIGEgYHdoZW5gIGNsYXVzZQBleHBlY3RlZCBhIGNsb3NpbmcgZGVsaW1pdGVyIGZvciB0aGUgYHJlc2N1ZWAgY2xhdXNlAGV4cGVjdGVkIGFuIGBlbmRgIHRvIGNsb3NlIHRoZSBgZWxzZWAgY2xhdXNlACdpbicgY2xhdXNlACd3aGVuJyBjbGF1c2UAJ2Vsc2lmJyBjbGF1c2UAJ3Jlc2N1ZScgY2xhdXNlACdlbHNlJyBjbGF1c2UAJ2Vuc3VyZScgY2xhdXNlAGZsb2F0X3BhcnNlAHBtX2ludGVnZXJfcGFyc2UAbGl0ZXJhbF9pbl9jb25kaXRpb25fdmVyYm9zZQBiZWdpbl9sb25lbHlfZWxzZQBpbnZhbGlkX3JldHJ5X2FmdGVyX2Vsc2UAY29uZGl0aW9uYWxfdGVybV9lbHNlAEludmFsaWQgcmV0cnkgYWZ0ZXIgZWxzZQB0ZXJuYXJ5X2V4cHJlc3Npb25fZmFsc2UAZXhwcmVzc2lvbl9ub3Rfd3JpdGFibGVfZmFsc2UAQ2FuJ3QgYXNzaWduIHRvIGZhbHNlAE1hY0phcGFuZXNlAGNhc2VfZXhwcmVzc2lvbl9hZnRlcl9jYXNlAHBtX2ludGVnZXJfY29udmVydF9iYXNlAGludmFsaWRfcmV0cnlfYWZ0ZXJfZW5zdXJlAEludmFsaWQgcmV0cnkgYWZ0ZXIgZW5zdXJlAHVuZXhwZWN0ZWRfdG9rZW5faWdub3JlAG51bWJlcl9saXRlcmFsX3VuZGVyc2NvcmUAY2xhc3NfdmFyaWFibGVfYmFyZQBnbG9iYWxfdmFyaWFibGVfYmFyZQBpbnN0YW5jZV92YXJpYWJsZV9iYXJlAHByb3RvdHlwZQBleHBlY3RlZF90eXBlAFVua25vd24gSFRNTCBvcGVuIHRhZyB0eXBlAHBhdHRlcm5fZXhwcmVzc2lvbl9hZnRlcl9waXBlAHBtX3Rva2VuX2J1ZmZlcl9lc2NhcGUAaW52YWxpZF9tdWx0aWJ5dGVfZXNjYXBlAHVudGVybWluYXRlZCBVbmljb2RlIGVzY2FwZQBub25lAG5leHRfbmV3bGluZQBpZ25vcmVkIG5ld2xpbmUAcG1fbmV3bGluZV9saXN0X2xpbmUAc2hhcmVhYmxlX2NvbnN0YW50X3ZhbHVlX2xpbmUAZXhwcmVzc2lvbl9ub3Rfd3JpdGFibGVfbGluZQAnc2hhcmVhYmxlX2NvbnN0YW50X3ZhbHVlJyBpcyBpZ25vcmVkIHVubGVzcyBpbiBjb21tZW50LW9ubHkgbGluZQBlbWJlZGRlZCBkb2N1bWVudGF0aW9uIGxpbmUAbWFjVWtyYWluZQBjbGFzc19uYW1lAHRhZ19uYW1lAGRlZl9uYW1lAHBtX2dsb2JhbF92YXJpYWJsZV93cml0ZV9uYW1lAG1vZHVsZV9uYW1lAHBhcmFtZXRlcl9tZXRob2RfbmFtZQBkdXBsaWNhdGVkIGtleSBuYW1lAGR1cGxpY2F0ZWQgYXJndW1lbnQgbmFtZQAnQEAnIHdpdGhvdXQgaWRlbnRpZmllcnMgaXMgbm90IGFsbG93ZWQgYXMgYSBjbGFzcyB2YXJpYWJsZSBuYW1lAGAlLipzJyBpcyBub3QgYWxsb3dlZCBhcyBhIGNsYXNzIHZhcmlhYmxlIG5hbWUAJyUuKnMnIGlzIG5vdCBhbGxvd2VkIGFzIGEgY2xhc3MgdmFyaWFibGUgbmFtZQAnJCcgd2l0aG91dCBpZGVudGlmaWVycyBpcyBub3QgYWxsb3dlZCBhcyBhIGdsb2JhbCB2YXJpYWJsZSBuYW1lAGAlLipzJyBpcyBub3QgYWxsb3dlZCBhcyBhIGdsb2JhbCB2YXJpYWJsZSBuYW1lACclLipzJyBpcyBub3QgYWxsb3dlZCBhcyBhIGdsb2JhbCB2YXJpYWJsZSBuYW1lACdAJyB3aXRob3V0IGlkZW50aWZpZXJzIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlIG5hbWUAYCUuKnMnIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlIG5hbWUAJyUuKnMnIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlIG5hbWUAZHVwbGljYXRlZCB2YXJpYWJsZSBuYW1lAHVuZXhwZWN0ZWQgJXM7IGV4cGVjdGVkIGEgbWV0aG9kIG5hbWUAc3R5bGUAbW9kdWxlAEVtYWNzLU11bGUAd2hpbGUAZXhwcmVzc2lvbl9ub3Rfd3JpdGFibGVfZmlsZQBlbWJlZGRlZCBkb2N1bWVudCBtZWV0cyBlbmQgb2YgZmlsZQB1bnRlcm1pbmF0ZWQgcXVvdGVkIHN0cmluZyBtZWV0cyBlbmQgb2YgZmlsZQB1bnRlcm1pbmF0ZWQgc3RyaW5nIG1lZXRzIGVuZCBvZiBmaWxlAGRvdWJsZQBleHByZXNzaW9uX25vdF93cml0YWJsZQBub19sb2NhbF92YXJpYWJsZQBibG9ja19wYXJhbV9sb2NhbF92YXJpYWJsZQB1bnVzZWRfbG9jYWxfdmFyaWFibGUAcmVzY3VlX3ZhcmlhYmxlAGludmFsaWQgZm9ybWFsIGFyZ3VtZW50OyBmb3JtYWwgYXJndW1lbnQgY2Fubm90IGJlIGEgY2xhc3MgdmFyaWFibGUAJS4qczogbm8gc3VjaCBsb2NhbCB2YXJpYWJsZQBpbnZhbGlkIGFyZ3VtZW50IGJlaW5nIHBhc3NlZCB0byBgYWxpYXNgOyBleHBlY3RlZCBhIGJhcmUgd29yZCwgc3ltYm9sLCBjb25zdGFudCwgb3IgZ2xvYmFsIHZhcmlhYmxlAGludmFsaWQgZm9ybWFsIGFyZ3VtZW50OyBmb3JtYWwgYXJndW1lbnQgY2Fubm90IGJlIGEgZ2xvYmFsIHZhcmlhYmxlAGludmFsaWQgZm9ybWFsIGFyZ3VtZW50OyBmb3JtYWwgYXJndW1lbnQgY2Fubm90IGJlIGFuIGluc3RhbmNlIHZhcmlhYmxlAGludmFsaWQgZW1iZWRkZWQgdmFyaWFibGUAYSB2YXJpYWJsZQBwYXR0ZXJuX2V4cHJlc3Npb25fYWZ0ZXJfcmFuZ2UAZmxvYXRfb3V0X29mX3JhbmdlAHJlZ2V4cF9pbnZhbGlkX3VuaWNvZGVfcmFuZ2UARmxvYXQgJS4qcyVzIG91dCBvZiByYW5nZQBleHBlY3RfbWVzc2FnZQBlcnJvcl9tZXNzYWdlAHBtX2RpYWdub3N0aWNfbWVzc2FnZQBwbV9zdGF0aWNfbGl0ZXJhbF9pbnNwZWN0X25vZGUAZW5kX25vZGUAYmFkX2FycmF5X25ld19sZW5ndGggd2FzIHRocm93biBpbiAtZm5vLWV4Y2VwdGlvbnMgbW9kZQBiYWRfYWxsb2Mgd2FzIHRocm93biBpbiAtZm5vLWV4Y2VwdGlvbnMgbW9kZQBlc2NhcGVfaW52YWxpZF91bmljb2RlAFVURi04IG1peGVkIHdpdGhpbiAlcyBzb3VyY2UAaW52YWxpZCBoZXggZXNjYXBlIHNlcXVlbmNlAGludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UAYWxpYXNfYXJndW1lbnRfbnVtYmVyZWRfcmVmZXJlbmNlAGludmFsaWRfbnVtYmVyZWRfcmVmZXJlbmNlAGJhY2sgcmVmZXJlbmNlAG51bWJlcmVkIHJlZmVyZW5jZQBpbmNvbXBsZXRlX3ZhcmlhYmxlX2luc3RhbmNlAHBhdHRlcm5fdGVybV9icmFjZQBibG9ja190ZXJtX2JyYWNlAGxhbWJkYV90ZXJtX2JyYWNlAGJlZ2luX3VwY2FzZV9icmFjZQBlbmRfdXBjYXNlX2JyYWNlAHRyYWNrX3doaXRlc3BhY2UAZW5jb3VudGVyZWQgXHIgaW4gbWlkZGxlIG9mIGxpbmUsIHRyZWF0ZWQgYXMgYSBtZXJlIHNwYWNlAGVzY2FwZWQgc3BhY2UAcGFyYW1ldGVyX3VuZXhwZWN0ZWRfZndkAGV4cGVjdGVkIGEgcGF0dGVybiBleHByZXNzaW9uIGFmdGVyIHRoZSBgaW5gIGtleXdvcmQAd3JpdGVfdGFyZ2V0X2luX21ldGhvZABjbGFzc19pbl9tZXRob2QAbW9kdWxlX2luX21ldGhvZABlbmRfaW5fbWV0aG9kAGxvY2FsIHZhcmlhYmxlIG9yIG1ldGhvZABzY3JpcHRfbm90X2ZvdW5kAGFyZ3VtZW50X2ZvcndhcmRpbmdfdW5ib3VuZABwbV9wYXJzZXJfc2NvcGVfZmluZABwbV9uZXdsaW5lX2xpc3RfYXBwZW5kAHBtX2Nhc2VfbWF0Y2hfbm9kZV9jb25kaXRpb25fYXBwZW5kAHBtX2Nhc2Vfbm9kZV9jb25kaXRpb25fYXBwZW5kAHBtX2ludGVycG9sYXRlZF9zdHJpbmdfbm9kZV9hcHBlbmQAcG1faW50ZXJwb2xhdGVkX25vZGVfYXBwZW5kAGNvbW1lbnRfZW5kAGVtYmV4cHJfZW5kAGJsb2NrX3Rlcm1fZW5kAGxhbWJkYV90ZXJtX2VuZABzdGF0ZW1lbnRfcG9zdGV4ZV9lbmQAY2xhc3NfdW5leHBlY3RlZF9lbmQAcGFyc2VyX2ZsdXNoX2hlcmVkb2NfZW5kAHBhcnNlci0+aGVyZWRvY19lbmQgPD0gcGFyc2VyLT5lbmQAcGFyc2VyLT5jdXJyZW50LmVuZCA8PSBwYXJzZXItPmVuZABzdGFydCA8PSBlbmQAYW1iaWd1b3VzX3ByZWZpeF9hbXBlcnNhbmQAYXJndW1lbnRfY29uZmxpY3RfYW1wZXJzYW5kAGFyZ3VtZW50X25vX2ZvcndhcmRpbmdfYW1wZXJzYW5kAG1hY0ljZWxhbmQAcGFyc2VfeWllbGQAaW52YWxpZF95aWVsZABJbnZhbGlkIHlpZWxkAGlzX3ZvaWQAZW1idmFyX2ludmFsaWQAcmV0dXJuX2ludmFsaWQAc3ltYm9sX2ludmFsaWQAZGlhZ25vc3RpY19pZAB1bmFyeV9kaXNhbGxvd2VkAGludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2U7IE11bHRpcGxlIGNvZGVwb2ludHMgYXQgc2luZ2xlIGNoYXJhY3RlciBsaXRlcmFsIGFyZSBkaXNhbGxvd2VkAHN5bWJvbCBsaXRlcmFsIHdpdGggaW50ZXJwb2xhdGlvbiBpcyBub3QgYWxsb3dlZABtdWx0aXBsZSBibG9jayBwYXJhbWV0ZXJzOyBvbmx5IG9uZSBibG9jayBpcyBhbGxvd2VkAGJvdGggYmxvY2sgYXJnIGFuZCBhY3R1YWwgYmxvY2sgZ2l2ZW47IG9ubHkgb25lIGJsb2NrIGlzIGFsbG93ZWQAcGFyYW1ldGVyX251bWJlcmVkX3Jlc2VydmVkAHF1b3RlZAB3cml0ZV90YXJnZXRfdW5leHBlY3RlZABwYXR0ZXJuX2hhc2hfa2V5X2ludGVycG9sYXRlZABzeW1ib2xfdGVybV9pbnRlcnBvbGF0ZWQAaW52YWxpZCBjb250cm9sIGVzY2FwZSBzZXF1ZW5jZTsgY29udHJvbCBjYW5ub3QgYmUgcmVwZWF0ZWQAaW52YWxpZCBtZXRhIGVzY2FwZSBzZXF1ZW5jZTsgbWV0YSBjYW5ub3QgYmUgcmVwZWF0ZWQAcGFyYW1ldGVyX25hbWVfZHVwbGljYXRlZAAnaXQnIGlzIG5vdCBhbGxvd2VkIHdoZW4gYSBudW1iZXJlZCBwYXJhbWV0ZXIgaXMgYWxyZWFkeSB1c2VkAG51bWJlcmVkIHBhcmFtZXRlcnMgYXJlIG5vdCBhbGxvd2VkIHdoZW4gJ2l0JyBpcyBhbHJlYWR5IHVzZWQAcGFyc2VkACd3aGVuJyBjbGF1c2Ugb24gbGluZSAlaSBkdXBsaWNhdGVzICd3aGVuJyBjbGF1c2Ugb24gbGluZSAlaSBhbmQgaXMgaWdub3JlZABleHByZXNzaW9uX25vdF93cml0YWJsZV9udW1iZXJlZABpdF9ub3RfYWxsb3dlZF9udW1iZXJlZAAnaXQnIGlzIG5vdCBhbGxvd2VkIHdoZW4gYW4gb3JkaW5hcnkgcGFyYW1ldGVyIGlzIGRlZmluZWQAbnVtYmVyZWQgcGFyYW1ldGVycyBhcmUgbm90IGFsbG93ZWQgd2hlbiBhbiBvcmRpbmFyeSBwYXJhbWV0ZXIgaXMgZGVmaW5lZAB1bmV4cGVjdGVkIHJhbmdlIG9wZXJhdG9yOyAuLiBhbmQgLi4uIGFyZSBub24tYXNzb2NpYXRpdmUgYW5kIGNhbm5vdCBiZSBjaGFpbmVkAG1hbGxvY19mYWlsZWQAdGFyZ2V0IG9mIHJlcGVhdCBvcGVyYXRvciBpcyBub3Qgc3BlY2lmaWVkAHN0YXRlbWVudCBub3QgcmVhY2hlZABlc2NhcGVkIGZvcm0gZmVlZABlbWJlZABsb2FkAHBtX2xvY2Fsc191bnJlYWQAcG1fbG9jYWxzX3JlYWQAaW52YWxpZF9sb2NhbF92YXJpYWJsZV9yZWFkACVkAHBhcnNlX25lZ2F0aXZlX251bWVyaWMAc3ltYm9sX3Rlcm1fZHluYW1pYwBtYWNDeXJpbGxpYwByZWdleHBfbm9uX2VzY2FwZWRfbWJjAC9Vc2Vycy9tYXJjb3JvdGgvRGV2ZWxvcG1lbnQvaGVyYi1yZWxlYXNlLTAuNy41L3ZlbmRvci9idW5kbGUvcnVieS8zLjQuMC9idW5kbGVyL2dlbXMvcHJpc20tMjNmMTZkMzFhN2M1L3NyYy91dGlsL3BtX25ld2xpbmVfbGlzdC5jAC9Vc2Vycy9tYXJjb3JvdGgvRGV2ZWxvcG1lbnQvaGVyYi1yZWxlYXNlLTAuNy41L3ZlbmRvci9idW5kbGUvcnVieS8zLjQuMC9idW5kbGVyL2dlbXMvcHJpc20tMjNmMTZkMzFhN2M1L3NyYy9zdGF0aWNfbGl0ZXJhbHMuYwAvVXNlcnMvbWFyY29yb3RoL0RldmVsb3BtZW50L2hlcmItcmVsZWFzZS0wLjcuNS92ZW5kb3IvYnVuZGxlL3J1YnkvMy40LjAvYnVuZGxlci9nZW1zL3ByaXNtLTIzZjE2ZDMxYTdjNS9zcmMvdXRpbC9wbV9pbnRlZ2VyLmMAL1VzZXJzL21hcmNvcm90aC9EZXZlbG9wbWVudC9oZXJiLXJlbGVhc2UtMC43LjUvdmVuZG9yL2J1bmRsZS9ydWJ5LzMuNC4wL2J1bmRsZXIvZ2Vtcy9wcmlzbS0yM2YxNmQzMWE3YzUvc3JjL3V0aWwvcG1fYnVmZmVyLmMAL1VzZXJzL21hcmNvcm90aC9EZXZlbG9wbWVudC9oZXJiLXJlbGVhc2UtMC43LjUvdmVuZG9yL2J1bmRsZS9ydWJ5LzMuNC4wL2J1bmRsZXIvZ2Vtcy9wcmlzbS0yM2YxNmQzMWE3YzUvc3JjL3ByaXNtLmMAL1VzZXJzL21hcmNvcm90aC9EZXZlbG9wbWVudC9oZXJiLXJlbGVhc2UtMC43LjUvdmVuZG9yL2J1bmRsZS9ydWJ5LzMuNC4wL2J1bmRsZXIvZ2Vtcy9wcmlzbS0yM2YxNmQzMWE3YzUvc3JjL3V0aWwvcG1fY29uc3RhbnRfcG9vbC5jAC9Vc2Vycy9tYXJjb3JvdGgvRGV2ZWxvcG1lbnQvaGVyYi1yZWxlYXNlLTAuNy41L3ZlbmRvci9idW5kbGUvcnVieS8zLjQuMC9idW5kbGVyL2dlbXMvcHJpc20tMjNmMTZkMzFhN2M1L3NyYy91dGlsL3BtX3N0cnBicmsuYwAvVXNlcnMvbWFyY29yb3RoL0RldmVsb3BtZW50L2hlcmItcmVsZWFzZS0wLjcuNS92ZW5kb3IvYnVuZGxlL3J1YnkvMy40LjAvYnVuZGxlci9nZW1zL3ByaXNtLTIzZjE2ZDMxYTdjNS9zcmMvdXRpbC9wbV9zdHJpbmcuYwAvVXNlcnMvbWFyY29yb3RoL0RldmVsb3BtZW50L2hlcmItcmVsZWFzZS0wLjcuNS92ZW5kb3IvYnVuZGxlL3J1YnkvMy40LjAvYnVuZGxlci9nZW1zL3ByaXNtLTIzZjE2ZDMxYTdjNS9zcmMvZW5jb2RpbmcuYwAvVXNlcnMvbWFyY29yb3RoL0RldmVsb3BtZW50L2hlcmItcmVsZWFzZS0wLjcuNS92ZW5kb3IvYnVuZGxlL3J1YnkvMy40LjAvYnVuZGxlci9nZW1zL3ByaXNtLTIzZjE2ZDMxYTdjNS9zcmMvdG9rZW5fdHlwZS5jAC9Vc2Vycy9tYXJjb3JvdGgvRGV2ZWxvcG1lbnQvaGVyYi1yZWxlYXNlLTAuNy41L3ZlbmRvci9idW5kbGUvcnVieS8zLjQuMC9idW5kbGVyL2dlbXMvcHJpc20tMjNmMTZkMzFhN2M1L3NyYy9kaWFnbm9zdGljLmMAcHJpc20vdGVtcGxhdGVzL3NyYy9ub2RlLmMuZXJiAGVzY2FwZWQgaG9yaXpvbnRhbCB0YWIAZXNjYXBlZCB2ZXJ0aWNhbCB0YWIAXGIAZXNjYXBlX2ludmFsaWRfbWV0YQBleHBlY3RfZXhwcmVzc2lvbl9hZnRlcl9jb21tYQBwYXR0ZXJuX2V4cHJlc3Npb25fYWZ0ZXJfY29tbWEAcGF0dGVybl9sYWJlbF9hZnRlcl9jb21tYQBwYXJhbWV0ZXJfd2lsZF9sb29zZV9jb21tYQBpbnZhbGlkX2NvbW1hAGludmFsaWQgY29tbWEAbWFjUm9tYW5pYQBhcmVhAFxhAGV4cGVjdGVkIGEgbGFtYmRhIGJsb2NrIGJlZ2lubmluZyB3aXRoIGB7YCB0byBlbmQgd2l0aCBgfWAAZXhwZWN0ZWQgYSBibG9jayBiZWdpbm5pbmcgd2l0aCBge2AgdG8gZW5kIHdpdGggYH1gAGV4cGVjdGVkIHRoZSBibG9jayBwYXJhbWV0ZXJzIHRvIGVuZCB3aXRoIGB8YAB1bnRlcm1pbmF0ZWQgbGlzdDsgZXhwZWN0ZWQgYSBjbG9zaW5nIGRlbGltaXRlciBmb3IgdGhlIGAld2AAZXhwZWN0ZWQgYSBgKGAgaW1tZWRpYXRlbHkgYWZ0ZXIgYG5vdGAAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgbm90YABleHBlY3RlZCBhIGAoYCBhZnRlciBgbm90YABleHBlY3RlZCBhbiBpbmRleCBhZnRlciBgZm9yYABleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGB3aGVuYAB1bnRlcm1pbmF0ZWQgbGlzdDsgZXhwZWN0ZWQgYSBjbG9zaW5nIGRlbGltaXRlciBmb3IgdGhlIGAlaWAAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgY2FzZWAAZXhwZWN0ZWQgYSBgd2hlbmAgb3IgYGluYCBjbGF1c2UgYWZ0ZXIgYGNhc2VgAGV4cGVjdGVkIGEgbGFtYmRhIGJsb2NrIGJlZ2lubmluZyB3aXRoIGBkb2AgdG8gZW5kIHdpdGggYGVuZGAAZXhwZWN0ZWQgYSBibG9jayBiZWdpbm5pbmcgd2l0aCBgZG9gIHRvIGVuZCB3aXRoIGBlbmRgAHVuZXhwZWN0ZWQgJXMsIGV4cGVjdGVkIGEgcmVjZWl2ZXIgZm9yIHVuYXJ5IGAlY2AAaW52YWxpZCBjaGFyYWN0ZXIgYCVjYABudW1iZXIgbGl0ZXJhbCBlbmRpbmcgd2l0aCBhIGBfYABleHBlY3RlZCBhIG1hdGNoaW5nIGBdYAB1bnRlcm1pbmF0ZWQgbGlzdDsgZXhwZWN0ZWQgYSBjbG9zaW5nIGRlbGltaXRlciBmb3IgdGhlIGAlV2AAZXhwZWN0ZWQgYSBge2AgYWZ0ZXIgYEJFR0lOYAB1bnRlcm1pbmF0ZWQgbGlzdDsgZXhwZWN0ZWQgYSBjbG9zaW5nIGRlbGltaXRlciBmb3IgdGhlIGAlSWAAZXhwZWN0ZWQgYSBge2AgYWZ0ZXIgYEVORGAAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgZGVmaW5lZD9gAGluY29tcGxldGUgZXhwcmVzc2lvbiBhdCBgP2AAZXhwZWN0ZWQgYSBwYXR0ZXJuIGV4cHJlc3Npb24gYWZ0ZXIgYD0+YABleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGB8fD1gAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYD1gAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYCYmPWAAZXhwZWN0ZWQgYSBzdXBlcmNsYXNzIGFmdGVyIGA8YABleHBlY3RlZCBhbiBleHByZXNzaW9uIGFmdGVyIGA8PGAAdW5leHBlY3RlZCBhcmd1bWVudCBhZnRlciBgLi4uYABleHBlY3RlZCBhIHBhdHRlcm4gZXhwcmVzc2lvbiBhZnRlciBgLGAAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgLGAAZXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiBhZnRlciBgKmAAdW5leHBlY3RlZCBwYXJhbWV0ZXIgYCpgAGV4cGVjdGVkIGEgbWF0Y2hpbmcgYClgAGV4cGVjdGVkIGFuIGV4cHJlc3Npb24gYWZ0ZXIgYChgAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfX19FTkNPRElOR19fAENhbid0IGFzc2lnbiB0byBfX0VOQ09ESU5HX18AdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9fX0xJTkVfXwBDYW4ndCBhc3NpZ24gdG8gX19MSU5FX18AZmlsZV9rZXl3b3JkLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfX19GSUxFX18AQ2FuJ3QgYXNzaWduIHRvIF9fRklMRV9fAF9fRU5EX18AJF8AW10AbGlzdC0+c2l6ZSA9PSAwIHx8IG5ld2xpbmVfb2Zmc2V0ID4gbGlzdC0+b2Zmc2V0c1tsaXN0LT5zaXplIC0gMV0AXFwAPCFbQ0RBVEFbAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfUkVUUlkAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fRkxPQVRfSU1BR0lOQVJZAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0lOVEVHRVJfSU1BR0lOQVJZAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0ZMT0FUX1JBVElPTkFMX0lNQUdJTkFSWQB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9JTlRFR0VSX1JBVElPTkFMX0lNQUdJTkFSWQBCSU5BUlkAZGlhZ19pZCA8IFBNX0RJQUdOT1NUSUNfSURfTUFYAGluZGV4ICE9IFVJTlQzMl9NQVgAbG9jYWwtPnJlYWRzIDwgVUlOVDMyX01BWABcdSUwNFgAXHglMDJYAGludmFsaWQgbXVsdGlieXRlIGNoYXJhY3RlciAweCVYAGV1Y1RXAEVVQy1UVwBLT0k4LVUAVW5rbm93biBlcnJvcl90eXBlX1QAVW5rbm93biB0b2tlbl90eXBlX1QAVW5rbm93biBhc3Rfbm9kZV90eXBlX1QAa2V5d29yZC0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX05FWFQAVE9LRU5fSFRNTF9DT01NRU5UX1NUQVJUAFRPS0VOX0hUTUxfVEFHX1NUQVJUAFRPS0VOX0lERU5USUZJRVIsIFRPS0VOX1FVT1RFLCBUT0tFTl9FUkJfU1RBUlQAVE9LRU5fQ0RBVEFfU1RBUlQAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fVURPVF9ET1RfRE9UAFRPS0VOX0VSQl9DT05URU5UAFRPS0VOX1BFUkNFTlQAdW5leHBlY3RlZCBjb25zdGFudCBwYXRoIGFmdGVyIGBjbGFzc2A7IGNsYXNzL21vZHVsZSBuYW1lIG11c3QgYmUgQ09OU1RBTlQAdW5leHBlY3RlZCBjb25zdGFudCBwYXRoIGFmdGVyIGBtb2R1bGVgOyBjbGFzcy9tb2R1bGUgbmFtZSBtdXN0IGJlIENPTlNUQU5UAFRPS0VOX0xUAEFTQ0lJLThCSVQAcG1fYmluZGluZ19wb3dlcnNbdHlwZV0ubGVmdCA9PSBQTV9CSU5ESU5HX1BPV0VSX1VOU0VUAGxpc3QtPmlkc1tpbmRleF0gPT0gUE1fQ09OU1RBTlRfSURfVU5TRVQAVE9LRU5fQVQAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fRkxPQVQAVE9LRU5fRVFVQUxTAFNoaWZ0X0pJUwBTSklTAFVURi04LUhGUwBCaWc1LUhLU0NTAGtleXdvcmQtPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9BTElBUwBVTkNMT1NFRF9FTEVNRU5UX0VSUk9SAFVORVhQRUNURURfVE9LRU5fRVJST1IAbm90IFRPS0VOX0VSUk9SAFFVT1RFU19NSVNNQVRDSF9FUlJPUgBUQUdfTkFNRVNfTUlTTUFUQ0hfRVJST1IAVk9JRF9FTEVNRU5UX0NMT1NJTkdfVEFHX0VSUk9SAE1JU1NJTkdfQ0xPU0lOR19UQUdfRVJST1IATUlTU0lOR19PUEVOSU5HX1RBR19FUlJPUgBSVUJZX1BBUlNFX0VSUk9SAFVORVhQRUNURURfRVJST1IAZXVjS1IARVVDLUtSAFRPS0VOX0NIQVJBQ1RFUgB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX1NVUEVSAGtleXdvcmQtPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9TVVBFUgBUT0tFTl9JREVOVElGSUVSAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0lOVEVHRVIAb3BlcmF0b3ItPnR5cGUgPT0gUE1fVE9LRU5fVVNUQVJfU1RBUiB8fCBvcGVyYXRvci0+dHlwZSA9PSBQTV9UT0tFTl9TVEFSX1NUQVIAb3BlcmF0b3ItPnR5cGUgPT0gUE1fVE9LRU5fVVNUQVJfU1RBUgBwYXJzZXItPmN1cnJlbnQudHlwZSA9PSBQTV9UT0tFTl9VU1RBUl9TVEFSAHBhcnNlci0+cHJldmlvdXMudHlwZSA9PSBQTV9UT0tFTl9VU1RBUgBLT0k4LVIAVE9LRU5fTkJTUABldWNKUABFVUMtSlAAc3RhdGVsZXNzLUlTTy0yMDIyLUpQAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfUkVETwBCaWc1LVVBTwBUT0tFTl9DT0xPTgBUT0tFTl9TRU1JQ09MT04AVE9LRU5fWE1MX0RFQ0xBUkFUSU9OAFRPS0VOX0VYQ0xBTUFUSU9OAHBhcnNlci0+Y3VycmVudC50eXBlID09IFBNX1RPS0VOX1NUUklOR19CRUdJTgBldWNDTgBFVUMtQ04ATkFOAGV4dHJhY3RIVE1MAHBhcmFtcy0+a2V5d29yZF9yZXN0ID09IE5VTEwAdGFyZ2V0LT5ibG9jayA9PSBOVUxMAHBhcmFtcy0+YmxvY2sgPT0gTlVMTAByZXN0ICE9IE5VTEwAcGFyc2VyLT5jdXJyZW50X2Jsb2NrX2V4aXRzICE9IE5VTEwAejIudmFsdWVzICE9IE5VTEwAejAudmFsdWVzICE9IE5VTEwAcmVjZWl2ZXIgIT0gTlVMTABvcGVuaW5nICE9IE5VTEwAc2NvcGUgIT0gTlVMTABzb3VyY2UgIT0gTlVMTAB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX05JTABrZXl3b3JkLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfTklMAG9wZXJhdG9yLT50eXBlID09IFBNX1RPS0VOX1BJUEVfUElQRV9FUVVBTABvcGVyYXRvci0+dHlwZSA9PSBQTV9UT0tFTl9BTVBFUlNBTkRfQU1QRVJTQU5EX0VRVUFMAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0ZMT0FUX1JBVElPTkFMAHRva2VuLT50eXBlID09IFBNX1RPS0VOX0lOVEVHRVJfUkFUSU9OQUwAUENLAFRPS0VOX0JBQ0tUSUNLAEdCSwBrZXl3b3JkLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfQlJFQUsAY3NXaW5kb3dzMzFKAFdpbmRvd3MtMzFKAFVTLUFTQ0lJAFNKSVMtS0RESQBzdGF0ZWxlc3MtSVNPLTIwMjItSlAtS0RESQBVVEY4LUtEREkAVE9LRU5fU0xBU0gAVE9LRU5fQkFDS1NMQVNIAFRPS0VOX0RBU0gAY2xvc2luZy0+dHlwZSA9PSBQTV9UT0tFTl9QSVBFIHx8IGNsb3NpbmctPnR5cGUgPT0gUE1fVE9LRU5fUEFSRU5USEVTSVNfUklHSFQgfHwgY2xvc2luZy0+dHlwZSA9PSBQTV9UT0tFTl9NSVNTSU5HAG5hbWUtPnR5cGUgPT0gUE1fVE9LRU5fQ09OU1RBTlQgfHwgbmFtZS0+dHlwZSA9PSBQTV9UT0tFTl9NSVNTSU5HAGVuZF9rZXl3b3JkLT50eXBlID09IFBNX1RPS0VOX0tFWVdPUkRfRU5EIHx8IGVuZF9rZXl3b3JkLT50eXBlID09IFBNX1RPS0VOX01JU1NJTkcAbGV4X21vZGUtPm1vZGUgPT0gUE1fTEVYX1NUUklORwBUT0tFTl9FT0YAdW50ZXJtaW5hdGVkIGhlcmVkb2M7IGNhbid0IGZpbmQgc3RyaW5nICIlLipzIiBhbnl3aGVyZSBiZWZvcmUgRU9GAElORgB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX1NFTEYAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fS0VZV09SRF9VTkRFRgAkRgB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX1RSVUUAVE9LRU5fUVVPVEUAVE9LRU5fSFRNTF9UQUdfU1RBUlRfQ0xPU0UAVE9LRU5fSFRNTF9UQUdfU0VMRl9DTE9TRQB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9LRVlXT1JEX0ZBTFNFAFRPS0VOX1VOREVSU0NPUkUAVE9LRU5fSFRNTF9ET0NUWVBFADwhRE9DVFlQRQBUT0tFTl9FUkJfU1RBUlQsIFRPS0VOX0hUTUxfRE9DVFlQRSwgVE9LRU5fSFRNTF9DT01NRU5UX1NUQVJULCBUT0tFTl9JREVOVElGSUVSLCBUT0tFTl9XSElURVNQQUNFLCBUT0tFTl9OQlNQLCBUT0tFTl9BVCwgb3IgVE9LRU5fTkVXTElORQBUT0tFTl9JREVOVElGSUVSLCBUT0tFTl9BVCwgVE9LRU5fRVJCX1NUQVJULFRPS0VOX1dISVRFU1BBQ0UsIG9yIFRPS0VOX05FV0xJTkUAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fQ0xBU1NfVkFSSUFCTEUAdG9rZW4tPnR5cGUgPT0gUE1fVE9LRU5fSU5TVEFOQ0VfVkFSSUFCTEUAQVNUX0hUTUxfVEVYVF9OT0RFAEFTVF9FUkJfQ09OVEVOVF9OT0RFAEFTVF9ET0NVTUVOVF9OT0RFAEFTVF9IVE1MX0NPTU1FTlRfTk9ERQBBU1RfSFRNTF9FTEVNRU5UX05PREUAQVNUX0VSQl9VTkxFU1NfTk9ERQBBU1RfRVJCX0ZPUl9OT0RFAFBNX05PREVfVFlQRShub2RlKSA9PSBQTV9CTE9DS19MT0NBTF9WQVJJQUJMRV9OT0RFIHx8IFBNX05PREVfVFlQRShub2RlKSA9PSBQTV9CTE9DS19QQVJBTUVURVJfTk9ERSB8fCBQTV9OT0RFX1RZUEUobm9kZSkgPT0gUE1fS0VZV09SRF9SRVNUX1BBUkFNRVRFUl9OT0RFIHx8IFBNX05PREVfVFlQRShub2RlKSA9PSBQTV9PUFRJT05BTF9LRVlXT1JEX1BBUkFNRVRFUl9OT0RFIHx8IFBNX05PREVfVFlQRShub2RlKSA9PSBQTV9PUFRJT05BTF9QQVJBTUVURVJfTk9ERSB8fCBQTV9OT0RFX1RZUEUobm9kZSkgPT0gUE1fUkVRVUlSRURfS0VZV09SRF9QQVJBTUVURVJfTk9ERSB8fCBQTV9OT0RFX1RZUEUobm9kZSkgPT0gUE1fUkVRVUlSRURfUEFSQU1FVEVSX05PREUgfHwgUE1fTk9ERV9UWVBFKG5vZGUpID09IFBNX1JFU1RfUEFSQU1FVEVSX05PREUAQVNUX1hNTF9ERUNMQVJBVElPTl9OT0RFAEFTVF9FUkJfSU5fTk9ERQBBU1RfRVJCX0JFR0lOX05PREUAQVNUX0VSQl9XSEVOX05PREUAQVNUX0VSQl9VTlRJTF9OT0RFAEFTVF9MSVRFUkFMX05PREUAQVNUX0VSQl9CTE9DS19OT0RFAEFTVF9FUkJfQ0FTRV9NQVRDSF9OT0RFAEFTVF9IVE1MX09QRU5fVEFHX05PREUAQVNUX0hUTUxfQ0xPU0VfVEFHX05PREUAQVNUX0VSQl9JRl9OT0RFAEFTVF9IVE1MX0FUVFJJQlVURV9WQUxVRV9OT0RFAEFTVF9FUkJfUkVTQ1VFX05PREUAQVNUX0hUTUxfQVRUUklCVVRFX05PREUAQVNUX0VSQl9FTFNFX05PREUAQVNUX0VSQl9DQVNFX05PREUAQVNUX0VSQl9FTlNVUkVfTk9ERQBBU1RfSFRNTF9ET0NUWVBFX05PREUAQVNUX0hUTUxfQVRUUklCVVRFX05BTUVfTk9ERQBBU1RfRVJCX1dISUxFX05PREUAQVNUX1dISVRFU1BBQ0VfTk9ERQBBU1RfRVJCX0VORF9OT0RFAEFTVF9FUkJfWUlFTERfTk9ERQBBU1RfQ0RBVEFfTk9ERQBuYW1lLT50eXBlID09IFBNX1RPS0VOX0JBQ0tfUkVGRVJFTkNFAG5hbWUtPnR5cGUgPT0gUE1fVE9LRU5fTlVNQkVSRURfUkVGRVJFTkNFAFRPS0VOX1dISVRFU1BBQ0UAVE9LRU5fSFRNTF9DT01NRU5UX0VORABUT0tFTl9YTUxfREVDTEFSQVRJT05fRU5EAFRPS0VOX0hUTUxfVEFHX0VORABUT0tFTl9FUkJfRU5EAFRPS0VOX0NEQVRBX0VORABvcGVyYXRvci0+dHlwZSA9PSBQTV9UT0tFTl9OT1RfUFJPVklERUQgfHwgb3BlcmF0b3ItPnR5cGUgPT0gUE1fVE9LRU5fVUFNUEVSU0FORCB8fCBvcGVyYXRvci0+dHlwZSA9PSBQTV9UT0tFTl9BTVBFUlNBTkQAY2xvc2luZy0+dHlwZSA9PSBQTV9UT0tFTl9CUkFDS0VUX1JJR0hUIHx8IGNsb3NpbmctPnR5cGUgPT0gUE1fVE9LRU5fU1RSSU5HX0VORCB8fCBjbG9zaW5nLT50eXBlID09IFBNX1RPS0VOX01JU1NJTkcgfHwgY2xvc2luZy0+dHlwZSA9PSBQTV9UT0tFTl9OT1RfUFJPVklERUQAcGFyc2VyLT5sZXhfbW9kZXMuY3VycmVudC0+bW9kZSA9PSBQTV9MRVhfSEVSRURPQwBVVEY4LU1BQwB0b2tlbi0+dHlwZSA9PSBQTV9UT0tFTl9DT01NQQBsaWJwcmlzbUAALCBsaWJoZXJiQAAtQAArQABjYXRjaGluZyBhIGNsYXNzIHdpdGhvdXQgYW4gb2JqZWN0PwAuLi4gYXQgRU9MLCBzaG91bGQgYmUgcGFyZW50aGVzaXplZD8AZGVmaW5lZD8AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AIzxFbmNvZGluZzolcz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AXV0+AD8+AD4+ADw9PgA8Lz4APCAvPgAtLT4APSU+AC0lPgAlJT4AW109AD4+PQA8JT09AGZvdW5kIGA9IGxpdGVyYWwnIGluIGNvbmRpdGlvbmFsLCBzaG91bGQgYmUgPT0AZm91bmQgJz0gbGl0ZXJhbCcgaW4gY29uZGl0aW9uYWwsIHNob3VsZCBiZSA9PQA8PD0APCU9ADwlJT0APDwAJDsAOjoAXzkAQ1A4NjkASUJNODY5AENQOTQ5AElTTzg4NTktOQBJU08tODg1OS05AF84AEdCMTk4OABDUDg3OABBTlNJX1gzLjQtMTk2OABDUDEyNTgAV2luZG93cy0xMjU4AEJpZzUtSEtTQ1M6MjAwOABDRVNVLTgAVVRGLTgASVNPODg1OS04AElTTy04ODU5LTgAXzcAQ1A4NTcASUJNODU3AENQMTI1NwBXaW5kb3dzLTEyNTcAQ1A3MzcASUJNNzM3AENQNDM3AElCTTQzNwBJU084ODU5LTcASVNPLTg4NTktNwBfNgBDUDg2NgBJQk04NjYAQ1AxMjU2AFdpbmRvd3MtMTI1NgA2NDYAQ1A5MzYASVNPODg1OS0xNgBJU08tODg1OS0xNgBJU084ODU5LTYASVNPLTg4NTktNgBCaWc1AF81AENQNzc1AElCTTc3NQBDUDg2NQBJQk04NjUAQ1A4NTUASUJNODU1AENQMTI1NQBXaW5kb3dzLTEyNTUAR0IxMjM0NQBJU084ODU5LTE1AElTTy04ODU5LTE1ADAuNy41AElTTzg4NTktNQBJU08tODg1OS01AF80AENQODc0AFdpbmRvd3MtODc0AENQODY0AElCTTg2NABDUDEyNTQAV2luZG93cy0xMjU0AElTTzg4NTktMTQASVNPLTg4NTktMTQARVVDLUpJUy0yMDA0AElTTzg4NTktNABJU08tODg1OS00AGluY29tcGxldGVfdmFyaWFibGVfY2xhc3NfM18zAGVxdWFsX2luX2NvbmRpdGlvbmFsXzNfMwBpbnZhbGlkX3ZhcmlhYmxlX2dsb2JhbF8zXzMAaW5jb21wbGV0ZV92YXJpYWJsZV9pbnN0YW5jZV8zXzMAQ1A4NjMASUJNODYzAENQMTI1MwBXaW5kb3dzLTEyNTMARVVDLUpJU1gwMjEzAElTTzg4NTktMTMASVNPLTg4NTktMTMASVNPODg1OS0zAElTTy04ODU5LTMAXzIAQ1A4NjIASUJNODYyAENQODUyAElCTTg1MgBDUDEyNTIAV2luZG93cy0xMjUyAENQOTMyAENQNTE5MzIAR0IyMzEyAElTTzg4NTktMgBJU08tODg1OS0yAF8xAENQODYxAElCTTg2MQBDUDk1MQBDUDEyNTEAV2luZG93cy0xMjUxAElTTzg4NTktMTEASVNPLTg4NTktMTEAQ1A2NTAwMQAxLjUuMQBJU084ODU5LTEASVNPLTg4NTktMQBDUDg2MABJQk04NjAAQ1A5NTAAQ1A4NTAASUJNODUwAENQMTI1MABXaW5kb3dzLTEyNTAAR0IxODAzMABDUDcyMABJQk03MjAAVElTLTYyMABJU084ODU5LTEwAElTTy04ODU5LTEwADAuMAAoMABsb2NhbC0+cmVhZHMgPiAwAGJpZ2ludHNfbGVuZ3RoID4gMABkaWZmID4gMABzdGF0ZW1lbnRzLT5ib2R5LnNpemUgPiAwAG5vZGUtPmJvZHkuc2l6ZSA+IDAAbiA+PSAwAGxlbmd0aCA+PSAwAChsYWJlbC5lbmQgLSBsYWJlbC5zdGFydCkgPj0gMAAvLi4uL24gaGFzIGEgbm9uIGVzY2FwZWQgbm9uIEFTQ0lJIGNoYXJhY3RlciBpbiBub24gQVNDSUktOEJJVCBzY3JpcHQ6IC8lLipzLwBpbmNvbXBhdGlibGUgY2hhcmFjdGVyIGVuY29kaW5nOiAvJS4qcy8AaW52YWxpZCBtdWx0aWJ5dGUgZXNjYXBlOiAvJS4qcy8AaW52YWxpZCBVbmljb2RlIHJhbmdlOiAvJS4qcy8AVVRGLTggY2hhcmFjdGVyIGluIG5vbiBVVEYtOCByZWdleHA6IC8lcy8APC8AJC8AVGFnIGA8JXM+YCBvcGVuZWQgYXQgKCV6dTolenUpIHdhcyBuZXZlciBjbG9zZWQgYmVmb3JlIHRoZSBlbmQgb2YgZG9jdW1lbnQuAEZvdW5kIGNsb3NpbmcgdGFnIGA8LyVzPmAgYXQgKCV6dTolenUpIHdpdGhvdXQgYSBtYXRjaGluZyBvcGVuaW5nIHRhZy4AJXMuIEV4cGVjdGVkOiBgJXNgLCBmb3VuZDogYCVzYC4AT3BlbmluZyB0YWcgYDwlcz5gIGF0ICglenU6JXp1KSBkb2Vzbid0IGhhdmUgYSBtYXRjaGluZyBjbG9zaW5nIHRhZyBgPC8lcz5gLgBgJXNgIGlzIGEgdm9pZCBlbGVtZW50IGFuZCBzaG91bGQgbm90IGJlIHVzZWQgYXMgYSBjbG9zaW5nIHRhZy4gVXNlIGA8JXM+YCBvciBgPCVzIC8+YCBpbnN0ZWFkIG9mIGA8LyVzPmAuAC4uLgBTdHJpbmcgb3BlbmVkIHdpdGggJXMgYnV0IGNsb3NlZCB3aXRoICVzIGF0ICglenU6JXp1KS4ARm91bmQgYCVzYCB3aGVuIGV4cGVjdGluZyBgJXNgIGF0ICglenU6JXp1KS4AT3BlbmluZyB0YWcgYDwlcz5gIGF0ICglenU6JXp1KSBjbG9zZWQgd2l0aCBgPC8lcz5gIGF0ICglenU6JXp1KS4AXE0tAFxDLQA8IS0tADwlLQAgLQArACoqAGlzX3Bvd2VyX29mX3R3byhwb29sLT5jYXBhY2l0eSkAIChXZWJBc3NlbWJseSkAaW52YWxpZCBtdWx0aWJ5dGUgY2hhciAoJXMpAChudWxsKQBpKQBiYWNrdGljayAoYCkAKG1vZGlmaWVyID09ICduJyAmJiBtb2RpZmllcl9lbmNvZGluZyA9PSBQTV9FTkNPRElOR19BU0NJSV84QklUX0VOVFJZKSB8fCAobW9kaWZpZXIgPT0gJ3UnICYmIG1vZGlmaWVyX2VuY29kaW5nID09IFBNX0VOQ09ESU5HX1VURl84X0VOVFJZKSB8fCAobW9kaWZpZXIgPT0gJ2UnICYmIG1vZGlmaWVyX2VuY29kaW5nID09IFBNX0VOQ09ESU5HX0VVQ19KUF9FTlRSWSkgfHwgKG1vZGlmaWVyID09ICdzJyAmJiBtb2RpZmllcl9lbmNvZGluZyA9PSBQTV9FTkNPRElOR19XSU5ET1dTXzMxSl9FTlRSWSkAIXRhcmdldC0+YmxvY2sgfHwgUE1fTk9ERV9UWVBFX1AodGFyZ2V0LT5ibG9jaywgUE1fQkxPQ0tfQVJHVU1FTlRfTk9ERSkAUE1fTk9ERV9UWVBFX1AocmlnaHQsIFBNX1NQTEFUX05PREUpAFBNX05PREVfVFlQRV9QKGxlZnQsIFBNX1NQTEFUX05PREUpAGJvZHkgPT0gTlVMTCB8fCBQTV9OT0RFX1RZUEVfUChib2R5LCBQTV9TVEFURU1FTlRTX05PREUpAHN0YXRlbWVudHMgPT0gTlVMTCB8fCBQTV9OT0RFX1RZUEVfUChzdGF0ZW1lbnRzLCBQTV9TVEFURU1FTlRTX05PREUpAFBNX05PREVfVFlQRV9QKGNvbmRpdGlvbiwgUE1fSU5fTk9ERSkAUE1fTk9ERV9UWVBFX1AoY29uZGl0aW9uLCBQTV9XSEVOX05PREUpAFBNX05PREVfVFlQRV9QKHRhcmdldCwgUE1fTE9DQUxfVkFSSUFCTEVfUkVBRF9OT0RFKSB8fCBQTV9OT0RFX1RZUEVfUCh0YXJnZXQsIFBNX0lUX0xPQ0FMX1ZBUklBQkxFX1JFQURfTk9ERSkgfHwgUE1fTk9ERV9UWVBFX1AodGFyZ2V0LCBQTV9DQUxMX05PREUpAGFyZ3VtZW50cy0+YmxvY2sgPT0gTlVMTCB8fCBQTV9OT0RFX1RZUEVfUChhcmd1bWVudHMtPmJsb2NrLCBQTV9CTE9DS19OT0RFKQBQTV9OT0RFX1RZUEVfUChub2RlLCBQTV9IQVNIX05PREUpIHx8IFBNX05PREVfVFlQRV9QKG5vZGUsIFBNX0tFWVdPUkRfSEFTSF9OT0RFKQBQTV9OT0RFX1RZUEVfUChub2RlLCBQTV9MT0NBTF9WQVJJQUJMRV9SRUFEX05PREUpAHBvb2wtPnNpemUgPCAoKHVpbnQzMl90KSAoMSA8PCAzMCkpAHNpbmdsZSBxdW90ZSAoJykgb3IgZG91YmxlIHF1b3RlICgiKQBlc2NhcGVkIHF1b3RlIChcJykgb3IgZGlmZmVyZW50IHF1b3RlIHN0eWxlICgiKQAnPX4nACd+JwAnIX4nACd9JwAnfHwnACd8JwAneycAJyN7JwAncmV0cnknACcleCcAJyV3JwAnbmV4dCcAJ25vdCcAJ3VubGVzcycAJ2NsYXNzJwAnYWxpYXMnAGNvdWxkIG5vdCBwYXJzZSB0aGUgZmxvYXQgJyUuKnMnAHJlZ2V4cCBlbmNvZGluZyBvcHRpb24gJyVjJyBkaWZmZXJzIGZyb20gc291cmNlIGVuY29kaW5nICclcycAJ2ZvcicAJ29yJwAnc3VwZXInACdyZWRvJwAnZG8nACdyZXR1cm4nACc9YmVnaW4nACdiZWdpbicAJ2luJwAnd2hlbicAJ3RoZW4nAGV4cGVjdGVkIGB0aGVuYCBvciBgO2Agb3IgJ1xuJwB1bmV4cGVjdGVkIGBlbmRgLCBleHBlY3RpbmcgJzsnIG9yICdcbicAKmN1cnNvciA9PSAnXG4nACd1bnRpbCcAJ25pbCcAJ2JyZWFrJwAnJWknACdzZWxmJwAnZWxzaWYnACdpZicAJ3VuZGVmJwAnZGVmJwAndHJ1ZScAJ3Jlc2N1ZScAJ2Vsc2UnACdmYWxzZScAJ2Nhc2UnACdlbnN1cmUnACdtb2R1bGUnACd3aGlsZScAJz1lbmQnACdlbmQnACdhbmQnACd5aWVsZCcAJ2AnACdfX0VOQ09ESU5HX18nACdfX0xJTkVfXycAJ19fRklMRV9fJwAnX19FTkRfXycAJ14nACdbXScAJ10nACdbJwAnJVcnACdCRUdJTicAJyVJJwAnRU5EJwAnZGVmaW5lZD8nACc/JwAnPD0+JwAnPT4nACctPicAJz4nACd8fD0nACd8PScAJ149JwAnW109JwAnPj0nACc9PT0nACc9PScAJzw9JwAnLz0nACctPScAJys9JwAnKio9JwAnKj0nACc9JwAnJj0nACcmJj0nACclPScAJyE9JwAnPCcAJzsnACc6OicAJzonACcvJwAnLi4uJwAnLi4nACcuJwAnJi4nACctJwAnLCcAJysnACcqKicAJyonACcpJwAnKCcAJyYnACcmJicAJyUnACcjJwAnIScAJgA8JQA8JSUADQpcIwA8JSMAcG9pbnQgJiYgInNob3VsZCBoYXZlIGEgZGVjaW1hbCBwb2ludCIAdmFsdWUgIT0gLTEgJiYgImludmFsaWQgZGlnaXQiAGxlbmd0aF9lcnJvciB3YXMgdGhyb3duIGluIC1mbm8tZXhjZXB0aW9ucyBtb2RlIHdpdGggbWVzc2FnZSAiJXMiAG91dF9vZl9yYW5nZSB3YXMgdGhyb3duIGluIC1mbm8tZXhjZXB0aW9ucyBtb2RlIHdpdGggbWVzc2FnZSAiJXMiAGZhbHNlICYmICJ1bmV4cGVjdGVkIG5vZGUgdHlwZSIAZmFsc2UgJiYgInVucmVhY2hhYmxlIgBcIgAhAHJlZ2V4IABzeW1ib2wgAHN0cmluZyAAbGliYysrYWJpOiAARmFpbGVkIHRvIGFsbG9jYXRlICVkIGJ5dGVzCgBFcnJvcjogRmFpbGVkIHRvIHJlc2l6ZSBidWZmZXIgdG8gJXp1LgoARXJyb3I6IEZhaWxlZCB0byBpbml0aWFsaXplIGJ1ZmZlciB3aXRoIGNhcGFjaXR5IG9mICV6dS4KAEVycm9yOiBCdWZmZXIgY2FwYWNpdHkgd291bGQgb3ZlcmZsb3cgc3lzdGVtIGxpbWl0cy4KAEVycm9yOiBBcnJheSBhbGxvY2F0aW9uIHdvdWxkIGV4Y2VlZCBzeXN0ZW0gbGltaXRzLgoARXJyb3I6IEZhaWxlZCB0byBhbGxvY2F0ZSAlenUgYnl0ZXMuCgBXYXJuaW5nOiBBcHByb2FjaGluZyBhcnJheSBzaXplIGxpbWl0cywgdXNpbmcgY29uc2VydmF0aXZlIGdyb3d0aC4KAEVycm9yOiBNZW1vcnkgcmVhbGxvY2F0aW9uIGZhaWxlZCAoc2l6ZTogJXp1IGJ5dGVzKS4KAFtMZXhlcl0gRXJyb3I6ICVzIChjaGFyYWN0ZXIgJyVjJywgbGluZSAldSwgY29sICV1KQoA62wBAENUAQBBKwEA+TkBAPVlAQDKJQEA7EUBANoFAQBDPgEATWwBALs5AQANXQEANEEBAEArAQAAAAAAAAAAAN+KAQBKiwEARosBABSbAQASkwEAC5sBAAibAQABAAAAAAAAAAAAAABsngEAMEYCAHSeAQBOMTBlbXNjcmlwdGVuM3ZhbEUAAHRFAgBsngEAAAAAAGyeAQDURQIAAAAAAHRFAgDURQIAAAAAAGyeAQC0ngEAMEYCALyeAQBOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAgEUCAGyeAQBsngEAcHBwAGyeAQC0ngEAbJ4BAHBwcHAAAAAAtJ4BALSeAQBwcHAAtJ4BAHBwAAC0ngEAbJ4BAAAAAACARQIAbJ4BAAAAAABsngEAgEUCAAAAAABsngEA7EUCAKBaAQAAAAAAMh4BAAAAAABKCwEAAAAAABAKAQAAAAAAw3EBAAAAAAA7CgEAAAAAAAAAAAAAAAAAeWIBAAAAAAAFQAEAAAAAAHY/AQAAAAAAuT8BAAAAAAA/WgEAAAAAAAsRAQAAAAAABVsBAAAAAABKWwEAAAAAAMQ6AQAAAAAAASgBAAAAAAAvRQEAAAAAAKAnAQAAAAAAzCcBAAAAAADeCAEAAAAAACAJAQAAAAAATBYBAAAAAADNHAEAAAAAAJkCAQAAAAAAZhABAAAAAAC7AgEAAAAAAIwWAQAAAAAA6QIBAAAAAABFGAEAAAAAAKENAQAAAAAAN3ABAAAAAACqDwEAAAAAAHI7AQAAAAAA/hkBAAAAAABibQEAAAAAAC5tAQAAAAAAQW8BAAAAAACzNAEAAAAAANgHAQAAAAAAsW4BAAAAAABQbgEAAAAAADUMAQAAAAAA1W4BAAAAAADdDgEAAAAAACgCAQAAAAAAYXYBAAAAAACBcQEAAAAAAAANAQAAAAAA/pgBAAAAAADyVgEAAAAAAD0OAQAAAAAAdw4BAAAAAADfmAEAAAAAAMZRAQAAAAAApFIBAAAAAADFDAEAAAAAANINAQAAAAAAPw8BAAAAAAD6IwEAAAAAAAACAQAAAAAAQDEBAAAAAAD1WAEAAAAAADUaAQAAAAAAYhoBAAAAAACXMQEAAAAAAMUxAQAAAAAArg4BAAAAAACscAEAAAAAAFZZAQAAAAAA7TQBAAAAAACSWwEAAAAAAJFwAQAAAAAA2A8BAAAAAAAfBAEAAAAAACxjAQAAAAAAFF0BAAAAAAAfBAEAAAAAAGhjAQAAAAAAMF0BAAAAAAB+HQEAAAAAAIwfAQAAAAAAs2EBAAAAAADXFwEAAAAAAMQfAQAAAAAAcVUBAAAAAACPCQEAAAAAAJwFAQAAAAAAXnEBAAAAAAALcgEAAAAAAD1xAQAAAAAAoXEBAAAAAAB+cgEAAAAAAPEiAQAAAAAAGnEBAAAAAAAAAAAAAAAAAFkJAQAAAAAACkMBAAAAAAAscgEAAAAAAB8yAQAAAAAAjCgBAAAAAAD4UQEAAAAAAM1tAQAAAAAAF24BAAAAAAC+KAEAAAAAAAAmAQAAAAAA4m8BAAAAAABmcgEAAAAAAIMKAQAAAAAA6ygBAAAAAAAIGQEAAAAAAPImAQAAAAAAMlIBAAAAAAAbNAEAAAAAAE02AQAAAAAAzHIBAAAAAADzUwEAAAAAAFtzAQAAAAAAEnMBAAAAAABIOwEAAAAAAEwfAQAAAAAAhkYBAAAAAABdRwEAAAAAADSYAQAAAAAAZw0BAAAAAAAxDQEAAAAAADJuAQAAAAAAQC0BAAAAAACRVwEAAAAAANlCAQAAAAAAnzwBAAAAAAAsSAEAAAAAAA09AQAAAAAA2TwBAAAAAADtKQEAAAAAAON+AQAAAAAA1HABAAAAAABiVwEAAAAAADNXAQAAAAAAqVgBAAAAAAB2WAEAAAAAADJYAQAAAAAAESEBAAAAAAA+NAEAAAAAANJsAQAAAAAAkwsBAAEAAAAfBAEAAAAAAG0IAQAAAAAAwhQBAAAAAAD3EwEAAAAAAE2TAQAAAAAAD3UBAAAAAACAkAEAAAAAAPoWAQAAAAAAoBcBAAAAAABFPQEAAAAAAGUXAQAAAAAAMBcBAAAAAAACKwEAAAAAACkrAQAAAAAA/EMBAAAAAAB6WQEAAAAAAKpvAQAAAAAAo1MBAAAAAABjVAEAAAAAAHhIAQAAAAAADDoBAAAAAAACWAEAAAAAANJXAQAAAAAAUWEBAAAAAAC4YwEAAAAAAMBkAQAAAAAASUABAAAAAADzbAEAAAAAAANvAQAAAAAAHQYBAAAAAAB0bgEAAAAAAF8GAQAAAAAAVHABAAAAAAD8BQEAAAAAAJBtAQAAAAAAPgYBAAAAAAD6bwEAAAAAAHsAAQAAAAAA91wBAAAAAABTAgEAAAAAAKx2AQAAAAAADQ8BAAAAAADLCgEAAAAAAKwKAQAAAAAAsy0BAAAAAACDWgEAAAAAAMEiAQAAAAAA9G0BAAAAAADBbwEAAAAAAEQ/AQAAAAAA9mMBAAAAAAD6ZAEAAAAAABI/AQAAAAAA8goBAAAAAAAcFgEAAAAAALJAAQAAAAAAmBkBAAAAAABEYgEAAAAAACEgAQAAAAAAxggBAAAAAAAWKQEAAAAAANlWAQAAAAAALigBAAAAAABZKAEAAAAAAKoaAQAAAAAAwCoBAAAAAABvGQEAAAAAAE1yAQAAAAAAwhkBAAAAAADdHgEAAAAAAOEZAQAAAAAAny4BAAAAAADcWAEAAAAAAJYjAQAAAAAA43EBAAAAAADxcAEAAAAAAJheAQAAAAAAsAEBAAAAAAAMJQEAAAAAAIgiAQAAAAAAYSMBAAAAAAAqIwEAAAAAAB01AQAAAAAA8S4BAAAAAABiUAEAAAAAAFgvAQAAAAAAxVYBAAAAAAATYgEAAAAAACgvAQAAAAAAhh4BAAAAAADLIwEAAAAAAIovAQAAAAAA2S4BAAAAAACOMwEAAAAAAL0zAQAAAAAA7DMBAAAAAAAgCwEAAAAAAFWYAQAAAAAAWJABAAAAAAChkAEAAAAAAAqQAQAAAAAAKiEBAAAAAACuJgEAAAAAAOQfAQAAAAAAv5ABAAAAAADPNAEAAAAAAEsqAQAAAAAAb1IBAAAAAAB1DAEAAAAAANwBAQAAAAAAwgUBAAIAAACJHAEAAAAAAE4wAQAAAAAA4zABAAAAAACyMAEAAAAAAIAwAQAAAAAAxjIBAAAAAABRRAEAAAAAAKdZAQAAAAAAcyUBAAAAAAAMOgEAAAAAAGk6AQAAAAAAGzoBAAAAAABJIgEAAAAAABAiAQAAAAAA1yEBAAAAAAAdBQEAAAAAAHhvAQAAAAAAswkBAAAAAAAqNgEAAAAAACMbAQAAAAAAihsBAAAAAADuOwEAAAAAAMoEAQAAAAAARGUBAAAAAACHMgEAAAAAAGkgAQAAAAAAKBIBAAAAAAAMDgEAAAAAAJI0AQAAAAAAeQ8BAAAAAABnCgEAAAAAAHQfAQAAAAAAqhQBAAAAAAAURAEAAAAAAK0gAQABAAAAciQBAAEAAAC/JAEAAQAAAMIDAQABAAAATwMBAAEAAACIAwEAAQAAACYkAQABAAAA2S8BAAEAAADxhwEAAAAAABOLAQAAAAAA5IoBAAAAAAB7EQEAAAAAAPNBAQAAAAAAO2QBAAEAAAAGXAEAAQAAAPUbAQABAAAAv0EBAAEAAAB/LQEAAAAAAEQgAQAAAAAApx8BAAEAAAAUOwEAAAAAAGI0AQABAAAAnSABAAAAAACdIAEAAQAAAP9VAQABAAAAKRwBAAAAAAA3XgEAAAAAAM1lAQABAAAA/R8BAAEAAABqBQEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAMAAAAAAwAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcABwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQkJCQkJCQkJCQkJCQkJCQkHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwgIAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICCgMDAwMDAwMDAwMDAwQDAwsGBgYFCAgICAgICAgICAgAAQIDBQgHAQEBBAYBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEAAQABAQEBAQEBAgEBAQEBAgECAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQECAQEBAQEBAQIBAQEBAQEBAQEBAQEBAwEDAQEBAQEBAQMBAQEBAQMBAwEBAQEBAQEDAQEBAQEBAQEBAQEBAQEAAQAAwQIAAMYCAADRAgAA4AIAAOQCAADsAgAA7AIAAO4CAADuAgAARQMAAEUDAABwAwAAdAMAAHYDAAB3AwAAegMAAH0DAAB/AwAAfwMAAIYDAACGAwAAiAMAAIoDAACMAwAAjAMAAI4DAAChAwAAowMAAPUDAAD3AwAAgQQAAIoEAAAvBQAAMQUAAFYFAABZBQAAWQUAAGAFAACIBQAAsAUAAL0FAAC/BQAAvwUAAMEFAADCBQAAxAUAAMUFAADHBQAAxwUAANAFAADqBQAA7wUAAPIFAAAQBgAAGgYAACAGAABXBgAAWQYAAF8GAABuBgAA0wYAANUGAADcBgAA4QYAAOgGAADtBgAA7wYAAPoGAAD8BgAA/wYAAP8GAAAQBwAAPwcAAE0HAACxBwAAygcAAOoHAAD0BwAA9QcAAPoHAAD6BwAAAAgAABcIAAAaCAAALAgAAEAIAABYCAAAYAgAAGoIAABwCAAAhwgAAIkIAACOCAAAoAgAAMkIAADUCAAA3wgAAOMIAADpCAAA8AgAADsJAAA9CQAATAkAAE4JAABQCQAAVQkAAGMJAABxCQAAgwkAAIUJAACMCQAAjwkAAJAJAACTCQAAqAkAAKoJAACwCQAAsgkAALIJAAC2CQAAuQkAAL0JAADECQAAxwkAAMgJAADLCQAAzAkAAM4JAADOCQAA1wkAANcJAADcCQAA3QkAAN8JAADjCQAA8AkAAPEJAAD8CQAA/AkAAAEKAAADCgAABQoAAAoKAAAPCgAAEAoAABMKAAAoCgAAKgoAADAKAAAyCgAAMwoAADUKAAA2CgAAOAoAADkKAAA+CgAAQgoAAEcKAABICgAASwoAAEwKAABRCgAAUQoAAFkKAABcCgAAXgoAAF4KAABwCgAAdQoAAIEKAACDCgAAhQoAAI0KAACPCgAAkQoAAJMKAACoCgAAqgoAALAKAACyCgAAswoAALUKAAC5CgAAvQoAAMUKAADHCgAAyQoAAMsKAADMCgAA0AoAANAKAADgCgAA4woAAPkKAAD8CgAAAQsAAAMLAAAFCwAADAsAAA8LAAAQCwAAEwsAACgLAAAqCwAAMAsAADILAAAzCwAANQsAADkLAAA9CwAARAsAAEcLAABICwAASwsAAEwLAABWCwAAVwsAAFwLAABdCwAAXwsAAGMLAABxCwAAcQsAAIILAACDCwAAhQsAAIoLAACOCwAAkAsAAJILAACVCwAAmQsAAJoLAACcCwAAnAsAAJ4LAACfCwAAowsAAKQLAACoCwAAqgsAAK4LAAC5CwAAvgsAAMILAADGCwAAyAsAAMoLAADMCwAA0AsAANALAADXCwAA1wsAAAAMAAAMDAAADgwAABAMAAASDAAAKAwAACoMAAA5DAAAPQwAAEQMAABGDAAASAwAAEoMAABMDAAAVQwAAFYMAABYDAAAWgwAAF0MAABdDAAAYAwAAGMMAACADAAAgwwAAIUMAACMDAAAjgwAAJAMAACSDAAAqAwAAKoMAACzDAAAtQwAALkMAAC9DAAAxAwAAMYMAADIDAAAygwAAMwMAADVDAAA1gwAAN0MAADeDAAA4AwAAOMMAADxDAAA8wwAAAANAAAMDQAADg0AABANAAASDQAAOg0AAD0NAABEDQAARg0AAEgNAABKDQAATA0AAE4NAABODQAAVA0AAFcNAABfDQAAYw0AAHoNAAB/DQAAgQ0AAIMNAACFDQAAlg0AAJoNAACxDQAAsw0AALsNAAC9DQAAvQ0AAMANAADGDQAAzw0AANQNAADWDQAA1g0AANgNAADfDQAA8g0AAPMNAAABDgAAOg4AAEAOAABGDgAATQ4AAE0OAACBDgAAgg4AAIQOAACEDgAAhg4AAIoOAACMDgAAow4AAKUOAAClDgAApw4AALkOAAC7DgAAvQ4AAMAOAADEDgAAxg4AAMYOAADNDgAAzQ4AANwOAADfDgAAAA8AAAAPAABADwAARw8AAEkPAABsDwAAcQ8AAIMPAACIDwAAlw8AAJkPAAC8DwAAABAAADYQAAA4EAAAOBAAADsQAAA/EAAAUBAAAI8QAACaEAAAnRAAAKAQAADFEAAAxxAAAMcQAADNEAAAzRAA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AD8HAABNBwAAsQcAAMAHAADqBwAA9AcAAPUHAAD6BwAA+gcAAAAIAAAXCAAAGggAACwIAABACAAAWAgAAGAIAABqCAAAcAgAAIcIAACJCAAAjggAAKAIAADJCAAA1AgAAN8IAADjCAAA6QgAAPAIAAA7CQAAPQkAAEwJAABOCQAAUAkAAFUJAABjCQAAZgkAAG8JAABxCQAAgwkAAIUJAACMCQAAjwkAAJAJAACTCQAAqAkAAKoJAACwCQAAsgkAALIJAAC2CQAAuQkAAL0JAADECQAAxwkAAMgJAADLCQAAzAkAAM4JAADOCQAA1wkAANcJAADcCQAA3QkAAN8JAADjCQAA5gkAAPEJAAD8CQAA/AkAAAEKAAADCgAABQoAAAoKAAAPCgAAEAoAABMKAAAoCgAAKgoAADAKAAAyCgAAMwoAADUKAAA2CgAAOAoAADkKAAA+CgAAQgoAAEcKAABICgAASwoAAEwKAABRCgAAUQoAAFkKAABcCgAAXgoAAF4KAABmCgAAdQoAAIEKAACDCgAAhQoAAI0KAACPCgAAkQoAAJMKAACoCgAAqgoAALAKAACyCgAAswoAALUKAAC5CgAAvQoAAMUKAADHCgAAyQoAAMsKAADMCgAA0AoAANAKAADgCgAA4woAAOYKAADvCgAA+QoAAPwKAAABCwAAAwsAAAULAAAMCwAADwsAABALAAATCwAAKAsAACoLAAAwCwAAMgsAADMLAAA1CwAAOQsAAD0LAABECwAARwsAAEgLAABLCwAATAsAAFYLAABXCwAAXAsAAF0LAABfCwAAYwsAAGYLAABvCwAAcQsAAHELAACCCwAAgwsAAIULAACKCwAAjgsAAJALAACSCwAAlQsAAJkLAACaCwAAnAsAAJwLAACeCwAAnwsAAKMLAACkCwAAqAsAAKoLAACuCwAAuQsAAL4LAADCCwAAxgsAAMgLAADKCwAAzAsAANALAADQCwAA1wsAANcLAADmCwAA7wsAAAAMAAAMDAAADgwAABAMAAASDAAAKAwAACoMAAA5DAAAPQwAAEQMAABGDAAASAwAAEoMAABMDAAAVQwAAFYMAABYDAAAWgwAAF0MAABdDAAAYAwAAGMMAABmDAAAbwwAAIAMAACDDAAAhQwAAIwMAACODAAAkAwAAJIMAACoDAAAqgwAALMMAAC1DAAAuQwAAL0MAADEDAAAxgwAAMgMAADKDAAAzAwAANUMAADWDAAA3QwAAN4MAADgDAAA4wwAAOYMAADvDAAA8QwAAPMMAAAADQAADA0AAA4NAAAQDQAAEg0AADoNAAA9DQAARA0AAEYNAABIDQAASg0AAEwNAABODQAATg0AAFQNAABXDQAAXw0AAGMNAABmDQAAbw0AAHoNAAB/DQAAgQ0AAIMNAACFDQAAlg0AAJoNAACxDQAAsw0AALsNAAC9DQAAvQ0AAMANAADGDQAAzw0AANQNAADWDQAA1g0AANgNAADfDQAA5g0AAO8NAADyDQAA8w0AAAEOAAA6DgAAQA4AAEYOAABNDgAATQ4AAFAOAABZDgAAgQ4AAIIOAACEDgAAhA4AAIYOAACKDgAAjA4AAKMOAAClDgAApQ4AAKcOAAC5DgAAuw4AAL0OAADADgAAxA4AAMYOAADGDgAAzQ4AAM0OAADQDgAA2Q4AANwOAADfDgAAAA8AAAAPAAAgDwAAKQ8AAEAPAABHDwAASQ8AAGwPAABxDwAAgw8AAIgPAACXDwAAmQ8AALwPAAAAEAAANhAAADgQAAA4EAAAOxAAAEkQAABQEAAAnRAAAKAQAADFEAAAxxAAAMcQAADNEAAAzRAAANAQAAD6EAAA/BAAAEgSAABKEgAATRIAAFASAABWEgAAWBIAAFgSAABaEgAAXRIAAGASAACIEgAAihIAAI0SAACQEgAAsBIAALISAAC1EgAAuBIAAL4SAADAEgAAwBIAAMISAADFEgAAyBIAANYSAADYEgAAEBMAABITAAAVEwAAGBMAAFoTAACAEwAAjxMAAKATAAD1EwAA+BMAAP0TAAABFAAAbBYAAG8WAAB/FgAAgRYAAJoWAACgFgAA6hYAAO4WAAD4FgAAABcAABMXAAAfFwAAMxcAAEAXAABTFwAAYBcAAGwXAABuFwAAcBcAAHIXAABzFwAAgBcAALMXAAC2FwAAyBcAANcXAADXFwAA3BcAANwXAADgFwAA6RcAABAYAAAZGAAAIBgAAHgYAACAGAAAqhgAALAYAAD1GAAAABkAAB4ZAAAgGQAAKxkAADAZAAA4GQAARhkAAG0ZAABwGQAAdBkAAIAZAACrGQAAsBkAAMkZAADQGQAA2RkAAAAaAAAbGgAAIBoAAF4aAABhGgAAdBoAAIAaAACJGgAAkBoAAJkaAACnGgAApxoAAL8aAADAGgAAzBoAAM4aAAAAGwAAMxsAADUbAABDGwAARRsAAEwbAABQGwAAWRsAAIAbAACpGwAArBsAAOUbAADnGwAA8RsAAAAcAAA2HAAAQBwAAEkcAABNHAAAfRwAAIAcAACIHAAAkBwAALocAAC9HAAAvxwAAOkcAADsHAAA7hwAAPMcAAD1HAAA9hwAAPocAAD6HAAAAB0AAL8dAADnHQAA9B0AAAAeAAAVHwAAGB8AAB0fAAAgHwAARR8AAEgfAABNHwAAUB8AAFcfAABZHwAAWR8AAFsfAABbHwAAXR8AAF0fAABfHwAAfR8AAIAfAAC0HwAAth8AALwfAAC+HwAAvh8AAMIfAADEHwAAxh8AAMwfAADQHwAA0x8AANYfAADbHwAA4B8AAOwfAADyHwAA9B8AAPYfAAD8HwAAcSAAAHEgAAB/IAAAfyAAAJAgAACcIAAAAiEAAAIhAAAHIQAAByEAAAohAAATIQAAFSEAABUhAAAZIQAAHSEAACQhAAAkIQAAJiEAACYhAAAoIQAAKCEAACohAAAtIQAALyEAADkhAAA8IQAAPyEAAEUhAABJIQAATiEAAE4hAABgIQAAiCEAALYkAADpJAAAACwAAOQsAADrLAAA7iwAAPIsAADzLAAAAC0AACUtAAAnLQAAJy0AAC0tAAAtLQAAMC0AAGctAABvLQAAby0AAIAtAACWLQAAoC0AAKYtAACoLQAAri0AALAtAAC2LQAAuC0AAL4tAADALQAAxi0AAMgtAADOLQAA0C0AANYtAADYLQAA3i0AAOAtAAD/LQAALy4AAC8uAAAFMAAABzAAACEwAAApMAAAMTAAADUwAAA4MAAAPDAAAEEwAACWMAAAnTAAAJ8wAAChMAAA+jAAAPwwAAD/MAAABTEAAC8xAAAxMQAAjjEAAKAxAAC/MQAA8DEAAP8xAAAANAAAv00AAABOAACMpAAA0KQAAP2kAAAApQAADKYAABCmAAArpgAAQKYAAG6mAAB0pgAAe6YAAH+mAADvpgAAF6cAAB+nAAAipwAAiKcAAIunAADKpwAA0KcAANGnAADTpwAA06cAANWnAADZpwAA8qcAAAWoAAAHqAAAJ6gAAECoAABzqAAAgKgAAMOoAADFqAAAxagAANCoAADZqAAA8qgAAPeoAAD7qAAA+6gAAP2oAAAqqQAAMKkAAFKpAABgqQAAfKkAAICpAACyqQAAtKkAAL+pAADPqQAA2akAAOCpAAD+qQAAAKoAADaqAABAqgAATaoAAFCqAABZqgAAYKoAAHaqAAB6qgAAvqoAAMCqAADAqgAAwqoAAMKqAADbqgAA3aoAAOCqAADvqgAA8qoAAPWqAAABqwAABqsAAAmrAAAOqwAAEasAABarAAAgqwAAJqsAACirAAAuqwAAMKsAAFqrAABcqwAAaasAAHCrAADqqwAA8KsAAPmrAAAArAAAo9cAALDXAADG1wAAy9cAAPvXAAAA+QAAbfoAAHD6AADZ+gAAAPsAAAb7AAAT+wAAF/sAAB37AAAo+wAAKvsAADb7AAA4+wAAPPsAAD77AAA++wAAQPsAAEH7AABD+wAARPsAAEb7AACx+wAA0/sAAD39AABQ/QAAj/0AAJL9AADH/QAA8P0AAPv9AABw/gAAdP4AAHb+AAD8/gAAEP8AABn/AAAh/wAAOv8AAEH/AABa/wAAZv8AAL7/AADC/wAAx/8AAMr/AADP/wAA0v8AANf/AADa/wAA3P8AAAAAAQALAAEADQABACYAAQAoAAEAOgABADwAAQA9AAEAPwABAE0AAQBQAAEAXQABAIAAAQD6AAEAQAEBAHQBAQCAAgEAnAIBAKACAQDQAgEAAAMBAB8DAQAtAwEASgMBAFADAQB6AwEAgAMBAJ0DAQCgAwEAwwMBAMgDAQDPAwEA0QMBANUDAQAABAEAnQQBAKAEAQCpBAEAsAQBANMEAQDYBAEA+wQBAAAFAQAnBQEAMAUBAGMFAQBwBQEAegUBAHwFAQCKBQEAjAUBAJIFAQCUBQEAlQUBAJcFAQChBQEAowUBALEFAQCzBQEAuQUBALsFAQC8BQEAAAYBADYHAQBABwEAVQcBAGAHAQBnBwEAgAcBAIUHAQCHBwEAsAcBALIHAQC6BwEAAAgBAAUIAQAICAEACAgBAAoIAQA1CAEANwgBADgIAQA8CAEAPAgBAD8IAQBVCAEAYAgBAHYIAQCACAEAnggBAOAIAQDyCAEA9AgBAPUIAQAACQEAFQkBACAJAQA5CQEAgAkBALcJAQC+CQEAvwkBAAAKAQADCgEABQoBAAYKAQAMCgEAEwoBABUKAQAXCgEAGQoBADUKAQBgCgEAfAoBAIAKAQCcCgEAwAoBAMcKAQDJCgEA5AoBAAALAQA1CwEAQAsBAFULAQBgCwEAcgsBAIALAQCRCwEAAAwBAEgMAQCADAEAsgwBAMAMAQDyDAEAAA0BACcNAQAwDQEAOQ0BAIAOAQCpDgEAqw4BAKwOAQCwDgEAsQ4BAAAPAQAcDwEAJw8BACcPAQAwDwEARQ8BAHAPAQCBDwEAsA8BAMQPAQDgDwEA9g8BAAAQAQBFEAEAZhABAG8QAQBxEAEAdRABAIAQAQC4EAEAwhABAMIQAQDQEAEA6BABAPAQAQD5EAEAABEBADIRAQA2EQEAPxEBAEQRAQBHEQEAUBEBAHIRAQB2EQEAdhEBAIARAQC/EQEAwREBAMQRAQDOEQEA2hEBANwRAQDcEQEAABIBABESAQATEgEANBIBADcSAQA3EgEAPhIBAEESAQCAEgEAhhIBAIgSAQCIEgEAihIBAI0SAQCPEgEAnRIBAJ8SAQCoEgEAsBIBAOgSAQDwEgEA+RIBAAATAQADEwEABRMBAAwTAQAPEwEAEBMBABMTAQAoEwEAKhMBADATAQAyEwEAMxMBADUTAQA5EwEAPRMBAEQTAQBHEwEASBMBAEsTAQBMEwEAUBMBAFATAQBXEwEAVxMBAF0TAQBjEwEAABQBAEEUAQBDFAEARRQBAEcUAQBKFAEAUBQBAFkUAQBfFAEAYRQBAIAUAQDBFAEAxBQBAMUUAQDHFAEAxxQBANAUAQDZFAEAgBUBALUVAQC4FQEAvhUBANgVAQDdFQEAABYBAD4WAQBAFgEAQBYBAEQWAQBEFgEAUBYBAFkWAQCAFgEAtRYBALgWAQC4FgEAwBYBAMkWAQAAFwEAGhcBAB0XAQAqFwEAMBcBADkXAQBAFwEARhcBAAAYAQA4GAEAoBgBAOkYAQD/GAEABhkBAAkZAQAJGQEADBkBABMZAQAVGQEAFhkBABgZAQA1GQEANxkBADgZAQA7GQEAPBkBAD8ZAQBCGQEAUBkBAFkZAQCgGQEApxkBAKoZAQDXGQEA2hkBAN8ZAQDhGQEA4RkBAOMZAQDkGQEAABoBADIaAQA1GgEAPhoBAFAaAQCXGgEAnRoBAJ0aAQCwGgEA+BoBAAAcAQAIHAEAChwBADYcAQA4HAEAPhwBAEAcAQBAHAEAUBwBAFkcAQByHAEAjxwBAJIcAQCnHAEAqRwBALYcAQAAHQEABh0BAAgdAQAJHQEACx0BADYdAQA6HQEAOh0BADwdAQA9HQEAPx0BAEEdAQBDHQEAQx0BAEYdAQBHHQEAUB0BAFkdAQBgHQEAZR0BAGcdAQBoHQEAah0BAI4dAQCQHQEAkR0BAJMdAQCWHQEAmB0BAJgdAQCgHQEAqR0BAOAeAQD2HgEAAB8BABAfAQASHwEAOh8BAD4fAQBAHwEAUB8BAFkfAQCwHwEAsB8BAAAgAQCZIwEAACQBAG4kAQCAJAEAQyUBAJAvAQDwLwEAADABAC80AQBBNAEARjQBAABEAQBGRgEAAGgBADhqAQBAagEAXmoBAGBqAQBpagEAcGoBAL5qAQDAagEAyWoBANBqAQDtagEAAGsBAC9rAQBAawEAQ2sBAFBrAQBZawEAY2sBAHdrAQB9awEAj2sBAEBuAQB/bgEAAG8BAEpvAQBPbwEAh28BAI9vAQCfbwEA4G8BAOFvAQDjbwEA428BAPBvAQDxbwEAAHABAPeHAQAAiAEA1YwBAACNAQAIjQEA8K8BAPOvAQD1rwEA+68BAP2vAQD+rwEAALABACKxAQAysQEAMrEBAFCxAQBSsQEAVbEBAFWxAQBksQEAZ7EBAHCxAQD7sgEAALwBAGq8AQBwvAEAfLwBAIC8AQCIvAEAkLwBAJm8AQCevAEAnrwBAADUAQBU1AEAVtQBAJzUAQCe1AEAn9QBAKLUAQCi1AEApdQBAKbUAQCp1AEArNQBAK7UAQC51AEAu9QBALvUAQC91AEAw9QBAMXUAQAF1QEAB9UBAArVAQAN1QEAFNUBABbVAQAc1QEAHtUBADnVAQA71QEAPtUBAEDVAQBE1QEARtUBAEbVAQBK1QEAUNUBAFLVAQCl1gEAqNYBAMDWAQDC1gEA2tYBANzWAQD61gEA/NYBABTXAQAW1wEANNcBADbXAQBO1wEAUNcBAG7XAQBw1wEAiNcBAIrXAQCo1wEAqtcBAMLXAQDE1wEAy9cBAM7XAQD/1wEAAN8BAB7fAQAl3wEAKt8BAADgAQAG4AEACOABABjgAQAb4AEAIeABACPgAQAk4AEAJuABACrgAQAw4AEAbeABAI/gAQCP4AEAAOEBACzhAQA34QEAPeEBAEDhAQBJ4QEATuEBAE7hAQCQ4gEAreIBAMDiAQDr4gEA8OIBAPniAQDQ5AEA6+QBAPDkAQD55AEA4OcBAObnAQDo5wEA6+cBAO3nAQDu5wEA8OcBAP7nAQAA6AEAxOgBAADpAQBD6QEAR+kBAEfpAQBL6QEAS+kBAFDpAQBZ6QEAAO4BAAPuAQAF7gEAH+4BACHuAQAi7gEAJO4BACTuAQAn7gEAJ+4BACnuAQAy7gEANO4BADfuAQA57gEAOe4BADvuAQA77gEAQu4BAELuAQBH7gEAR+4BAEnuAQBJ7gEAS+4BAEvuAQBN7gEAT+4BAFHuAQBS7gEAVO4BAFTuAQBX7gEAV+4BAFnuAQBZ7gEAW+4BAFvuAQBd7gEAXe4BAF/uAQBf7gEAYe4BAGLuAQBk7gEAZO4BAGfuAQBq7gEAbO4BAHLuAQB07gEAd+4BAHnuAQB87gEAfu4BAH7uAQCA7gEAie4BAIvuAQCb7gEAoe4BAKPuAQCl7gEAqe4BAKvuAQC77gEAMPEBAEnxAQBQ8QEAafEBAHDxAQCJ8QEA8PsBAPn7AQAAAAIA36YCAACnAgA5twIAQLcCAB24AgAguAIAoc4CALDOAgDg6wIAAPgCAB36AgAAAAMAShMDAFATAwCvIwMAAAEAAAABAAACAQAAAgEAAAQBAAAEAQAABgEAAAYBAAAIAQAACAEAAAoBAAAKAQAADAEAAAwBAAAOAQAADgEAABABAAAQAQAAEgEAABIBAAAUAQAAFAEAABYBAAAWAQAAGAEAABgBAAAaAQAAGgEAABwBAAAcAQAAHgEAAB4BAAAgAQAAIAEAACIBAAAiAQAAJAEAACQBAAAmAQAAJgEAACgBAAAoAQAAKgEAACoBAAAsAQAALAEAAC4BAAAuAQAAMAEAADABAAAyAQAAMgEAADQBAAA0AQAANgEAADYBAAA5AQAAOQEAADsBAAA7AQAAPQEAAD0BAAA/AQAAPwEAAEEBAABBAQAAQwEAAEMBAABFAQAARQEAAEcBAABHAQAASgEAAEoBAABMAQAATAEAAE4BAABOAQAAUAEAAFABAABSAQAAUgEAAFQBAABUAQAAVgEAAFYBAABYAQAAWAEAAFoBAABaAQAAXAEAAFwBAABeAQAAXgEAAGABAABgAQAAYgEAAGIBAABkAQAAZAEAAGYBAABmAQAAaAEAAGgBAABqAQAAagEAAGwBAABsAQAAbgEAAG4BAABwAQAAcAEAAHIBAAByAQAAdAEAAHQBAAB2AQAAdgEAAHgBAAB5AQAAewEAAHsBAAB9AQAAfQEAAIEBAACCAQAAhAEAAIQBAACGAQAAhwEAAIkBAACLAQAAjgEAAJEBAACTAQAAlAEAAJYBAACYAQAAnAEAAJ0BAACfAQAAoAEAAKIBAACiAQAApAEAAKQBAACmAQAApwEAAKkBAACpAQAArAEAAKwBAACuAQAArwEAALEBAACzAQAAtQEAALUBAAC3AQAAuAEAALwBAAC8AQAAxAEAAMUBAADHAQAAyAEAAMoBAADLAQAAzQEAAM0BAADPAQAAzwEAANEBAADRAQAA0wEAANMBAADVAQAA1QEAANcBAADXAQAA2QEAANkBAADbAQAA2wEAAN4BAADeAQAA4AEAAOABAADiAQAA4gEAAOQBAADkAQAA5gEAAOYBAADoAQAA6AEAAOoBAADqAQAA7AEAAOwBAADuAQAA7gEAAPEBAADyAQAA9AEAAPQBAAD2AQAA+AEAAPoBAAD6AQAA/AEAAPwBAAD+AQAA/gEAAAACAAAAAgAAAgIAAAICAAAEAgAABAIAAAYCAAAGAgAACAIAAAgCAAAKAgAACgIAAAwCAAAMAgAADgIAAA4CAAAQAgAAEAIAABICAAASAgAAFAIAABQCAAAWAgAAFgIAABgCAAAYAgAAGgIAABoCAAAcAgAAHAIAAB4CAAAeAgAAIAIAACACAAAiAgAAIgIAACQCAAAkAgAAJgIAACYCAAAoAgAAKAIAACoCAAAqAgAALAIAACwCAAAuAgAALgIAADACAAAwAgAAMgIAADICAAA6AgAAOwIAAD0CAAA+AgAAQQIAAEECAABDAgAARgIAAEgCAABIAgAASgIAAEoCAABMAgAATAIAAE4CAABOAgAAcAMAAHADAAByAwAAcgMAAHYDAAB2AwAAfwMAAH8DAACGAwAAhgMAAIgDAACKAwAAjAMAAIwDAACOAwAAjwMAAJEDAAChAwAAowMAAKsDAADPAwAAzwMAANIDAADUAwAA2AMAANgDAADaAwAA2gMAANwDAADcAwAA3gMAAN4DAADgAwAA4AMAAOIDAADiAwAA5AMAAOQDAADmAwAA5gMAAOgDAADoAwAA6gMAAOoDAADsAwAA7AMAAO4DAADuAwAA9AMAAPQDAAD3AwAA9wMAAPkDAAD6AwAA/QMAAC8EAABgBAAAYAQAAGIEAABiBAAAZAQAAGQEAABmBAAAZgQAAGgEAABoBAAAagQAAGoEAABsBAAAbAQAAG4EAABuBAAAcAQAAHAEAAByBAAAcgQAAHQEAAB0BAAAdgQAAHYEAAB4BAAAeAQAAHoEAAB6BAAAfAQAAHwEAAB+BAAAfgQAAIAEAACABAAAigQAAIoEAACMBAAAjAQAAI4EAACOBAAAkAQAAJAEAACSBAAAkgQAAJQEAACUBAAAlgQAAJYEAACYBAAAmAQAAJoEAACaBAAAnAQAAJwEAACeBAAAngQAAKAEAACgBAAAogQAAKIEAACkBAAApAQAAKYEAACmBAAAqAQAAKgEAACqBAAAqgQAAKwEAACsBAAArgQAAK4EAACwBAAAsAQAALIEAACyBAAAtAQAALQEAAC2BAAAtgQAALgEAAC4BAAAugQAALoEAAC8BAAAvAQAAL4EAAC+BAAAwAQAAMEEAADDBAAAwwQAAMUEAADFBAAAxwQAAMcEAADJBAAAyQQAAMsEAADLBAAAzQQAAM0EAADQBAAA0AQAANIEAADSBAAA1AQAANQEAADWBAAA1gQAANgEAADYBAAA2gQAANoEAADcBAAA3AQAAN4EAADeBAAA4AQAAOAEAADiBAAA4gQAAOQEAADkBAAA5gQAAOYEAADoBAAA6AQAAOoEAADqBAAA7AQAAOwEAADuBAAA7gQAAPAEAADwBAAA8gQAAPIEAAD0BAAA9AQAAPYEAAD2BAAA+AQAAPgEAAD6BAAA+gQAAPwEAAD8BAAA/gQAAP4EAAAABQAAAAUAAAIFAAACBQAABAUAAAQFAAAGBQAABgUAAAgFAAAIBQAACgUAAAoFAAAMBQAADAUAAA4FAAAOBQAAEAUAABAFAAASBQAAEgUAABQFAAAUBQAAFgUAABYFAAAYBQAAGAUAABoFAAAaBQAAHAUAABwFAAAeBQAAHgUAACAFAAAgBQAAIgUAACIFAAAkBQAAJAUAACYFAAAmBQAAKAUAACgFAAAqBQAAKgUAACwFAAAsBQAALgUAAC4FAAAxBQAAVgUAAKAQAADFEAAAxxAAAMcQAADNEAAAzRAAAKATAAD1EwAAkBwAALocAAC9HAAAvxwAAAAeAAAAHgAAAh4AAAIeAAAEHgAABB4AAAYeAAAGHgAACB4AAAgeAAAKHgAACh4AAAweAAAMHgAADh4AAA4eAAAQHgAAEB4AABIeAAASHgAAFB4AABQeAAAWHgAAFh4AABgeAAAYHgAAGh4AABoeAAAcHgAAHB4AAB4eAAAeHgAAIB4AACAeAAAiHgAAIh4AACQeAAAkHgAAJh4AACYeAAAoHgAAKB4AACoeAAAqHgAALB4AACweAAAuHgAALh4AADAeAAAwHgAAMh4AADIeAAA0HgAANB4AADYeAAA2HgAAOB4AADgeAAA6HgAAOh4AADweAAA8HgAAPh4AAD4eAABAHgAAQB4AAEIeAABCHgAARB4AAEQeAABGHgAARh4AAEgeAABIHgAASh4AAEoeAABMHgAATB4AAE4eAABOHgAAUB4AAFAeAABSHgAAUh4AAFQeAABUHgAAVh4AAFYeAABYHgAAWB4AAFoeAABaHgAAXB4AAFweAABeHgAAXh4AAGAeAABgHgAAYh4AAGIeAABkHgAAZB4AAGYeAABmHgAAaB4AAGgeAABqHgAAah4AAGweAABsHgAAbh4AAG4eAABwHgAAcB4AAHIeAAByHgAAdB4AAHQeAAB2HgAAdh4AAHgeAAB4HgAAeh4AAHoeAAB8HgAAfB4AAH4eAAB+HgAAgB4AAIAeAACCHgAAgh4AAIQeAACEHgAAhh4AAIYeAACIHgAAiB4AAIoeAACKHgAAjB4AAIweAACOHgAAjh4AAJAeAACQHgAAkh4AAJIeAACUHgAAlB4AAJ4eAACeHgAAoB4AAKAeAACiHgAAoh4AAKQeAACkHgAAph4AAKYeAACoHgAAqB4AAKoeAACqHgAArB4AAKweAACuHgAArh4AALAeAACwHgAAsh4AALIeAAC0HgAAtB4AALYeAAC2HgAAuB4AALgeAAC6HgAAuh4AALweAAC8HgAAvh4AAL4eAADAHgAAwB4AAMIeAADCHgAAxB4AAMQeAADGHgAAxh4AAMgeAADIHgAAyh4AAMoeAADMHgAAzB4AAM4eAADOHgAA0B4AANAeAADSHgAA0h4AANQeAADUHgAA1h4AANYeAADYHgAA2B4AANoeAADaHgAA3B4AANweAADeHgAA3h4AAOAeAADgHgAA4h4AAOIeAADkHgAA5B4AAOYeAADmHgAA6B4AAOgeAADqHgAA6h4AAOweAADsHgAA7h4AAO4eAADwHgAA8B4AAPIeAADyHgAA9B4AAPQeAAD2HgAA9h4AAPgeAAD4HgAA+h4AAPoeAAD8HgAA/B4AAP4eAAD+HgAACB8AAA8fAAAYHwAAHR8AACgfAAAvHwAAOB8AAD8fAABIHwAATR8AAFkfAABZHwAAWx8AAFsfAABdHwAAXR8AAF8fAABfHwAAaB8AAG8fAACIHwAAjx8AAJgfAACfHwAAqB8AAK8fAAC4HwAAvB8AAMgfAADMHwAA2B8AANsfAADoHwAA7B8AAPgfAAD8HwAAAiEAAAIhAAAHIQAAByEAAAshAAANIQAAECEAABIhAAAVIQAAFSEAABkhAAAdIQAAJCEAACQhAAAmIQAAJiEAACghAAAoIQAAKiEAAC0hAAAwIQAAMyEAAD4hAAA/IQAARSEAAEUhAABgIQAAbyEAAIMhAACDIQAAtiQAAM8kAAAALAAALywAAGAsAABgLAAAYiwAAGQsAABnLAAAZywAAGksAABpLAAAaywAAGssAABtLAAAcCwAAHIsAAByLAAAdSwAAHUsAAB+LAAAgCwAAIIsAACCLAAAhCwAAIQsAACGLAAAhiwAAIgsAACILAAAiiwAAIosAACMLAAAjCwAAI4sAACOLAAAkCwAAJAsAACSLAAAkiwAAJQsAACULAAAliwAAJYsAACYLAAAmCwAAJosAACaLAAAnCwAAJwsAACeLAAAniwAAKAsAACgLAAAoiwAAKIsAACkLAAApCwAAKYsAACmLAAAqCwAAKgsAACqLAAAqiwAAKwsAACsLAAAriwAAK4sAACwLAAAsCwAALIsAACyLAAAtCwAALQsAAC2LAAAtiwAALgsAAC4LAAAuiwAALosAAC8LAAAvCwAAL4sAAC+LAAAwCwAAMAsAADCLAAAwiwAAMQsAADELAAAxiwAAMYsAADILAAAyCwAAMosAADKLAAAzCwAAMwsAADOLAAAziwAANAsAADQLAAA0iwAANIsAADULAAA1CwAANYsAADWLAAA2CwAANgsAADaLAAA2iwAANwsAADcLAAA3iwAAN4sAADgLAAA4CwAAOIsAADiLAAA6ywAAOssAADtLAAA7SwAAPIsAADyLAAAQKYAAECmAABCpgAAQqYAAESmAABEpgAARqYAAEamAABIpgAASKYAAEqmAABKpgAATKYAAEymAABOpgAATqYAAFCmAABQpgAAUqYAAFKmAABUpgAAVKYAAFamAABWpgAAWKYAAFimAABapgAAWqYAAFymAABcpgAAXqYAAF6mAABgpgAAYKYAAGKmAABipgAAZKYAAGSmAABmpgAAZqYAAGimAABopgAAaqYAAGqmAABspgAAbKYAAICmAACApgAAgqYAAIKmAACEpgAAhKYAAIamAACGpgAAiKYAAIimAACKpgAAiqYAAIymAACMpgAAjqYAAI6mAACQpgAAkKYAAJKmAACSpgAAlKYAAJSmAACWpgAAlqYAAJimAACYpgAAmqYAAJqmAAAipwAAIqcAACSnAAAkpwAAJqcAACanAAAopwAAKKcAACqnAAAqpwAALKcAACynAAAupwAALqcAADKnAAAypwAANKcAADSnAAA2pwAANqcAADinAAA4pwAAOqcAADqnAAA8pwAAPKcAAD6nAAA+pwAAQKcAAECnAABCpwAAQqcAAESnAABEpwAARqcAAEanAABIpwAASKcAAEqnAABKpwAATKcAAEynAABOpwAATqcAAFCnAABQpwAAUqcAAFKnAABUpwAAVKcAAFanAABWpwAAWKcAAFinAABapwAAWqcAAFynAABcpwAAXqcAAF6nAABgpwAAYKcAAGKnAABipwAAZKcAAGSnAABmpwAAZqcAAGinAABopwAAaqcAAGqnAABspwAAbKcAAG6nAABupwAAeacAAHmnAAB7pwAAe6cAAH2nAAB+pwAAgKcAAICnAACCpwAAgqcAAISnAACEpwAAhqcAAIanAACLpwAAi6cAAI2nAACNpwAAkKcAAJCnAACSpwAAkqcAAJanAACWpwAAmKcAAJinAACapwAAmqcAAJynAACcpwAAnqcAAJ6nAACgpwAAoKcAAKKnAACipwAApKcAAKSnAACmpwAApqcAAKinAACopwAAqqcAAK6nAACwpwAAtKcAALanAAC2pwAAuKcAALinAAC6pwAAuqcAALynAAC8pwAAvqcAAL6nAADApwAAwKcAAMKnAADCpwAAxKcAAMenAADJpwAAyacAANCnAADQpwAA1qcAANanAADYpwAA2KcAAPWnAAD1pwAAIf8AADr/AAAABAEAJwQBALAEAQDTBAEAcAUBAHoFAQB8BQEAigUBAIwFAQCSBQEAlAUBAJUFAQCADAEAsgwBAKAYAQC/GAEAQG4BAF9uAQAA1AEAGdQBADTUAQBN1AEAaNQBAIHUAQCc1AEAnNQBAJ7UAQCf1AEAotQBAKLUAQCl1AEAptQBAKnUAQCs1AEArtQBALXUAQDQ1AEA6dQBAATVAQAF1QEAB9UBAArVAQAN1QEAFNUBABbVAQAc1QEAONUBADnVAQA71QEAPtUBAEDVAQBE1QEARtUBAEbVAQBK1QEAUNUBAGzVAQCF1QEAoNUBALnVAQDU1QEA7dUBAAjWAQAh1gEAPNYBAFXWAQBw1gEAidYBAKjWAQDA1gEA4tYBAPrWAQAc1wEANNcBAFbXAQBu1wEAkNcBAKjXAQDK1wEAytcBAADpAQAh6QEAMPEBAEnxAQBQ8QEAafEBAHDxAQCJ8QEAAAAAAAAAAAAXAAAAGAAAABkAAAAaAAAAzYsBAAEAAAAbAAAAHAAAAB0AAAAeAAAAUn0BAAAAAAAfAAAAHAAAAB0AAAAeAAAAAXcBAAAAAAAgAAAAIQAAACIAAAAjAAAASnoBAAEAAAAkAAAAJQAAACYAAAAnAAAARn0BAAEAAAAoAAAAIQAAACIAAAApAAAAlYwBAAEAAAAoAAAAIQAAACIAAAApAAAAuXcBAAEAAAAoAAAAIQAAACIAAAApAAAAjHoBAAEAAAAqAAAAKwAAACwAAAAtAAAAxosBAAEAAAAgAAAAIQAAACIAAAAjAAAAho4BAAEAAAAfAAAALgAAAC8AAAAwAAAAIY8BAAAAAAAfAAAAMQAAADIAAAAzAAAAX44BAAAAAAAfAAAANAAAADUAAAA2AAAAt4wBAAAAAAA3AAAAIQAAACIAAAApAAAAaIsBAAEAAAAoAAAAIQAAACIAAAApAAAAG48BAAEAAAAoAAAAIQAAACIAAAApAAAAuo4BAAEAAAA4AAAAIQAAACIAAAApAAAAKFkBAAEAAAAgAAAAIQAAACIAAAAjAAAAYhwBAAEAAAAgAAAAIQAAACIAAAAjAAAAX40BAAEAAAA5AAAAIQAAACIAAAApAAAA1HgBAAEAAAA6AAAAIQAAACIAAAApAAAANnUBAAEAAAA5AAAAIQAAACIAAAApAAAA2IwBAAEAAAA7AAAAIQAAACIAAAApAAAAQo8BAAEAAAAfAAAAPAAAAD0AAAA+AAAAhosBAAAAAAA5AAAAIQAAACIAAAApAAAAjo4BAAEAAAA/AAAAIQAAACIAAAApAAAADX0BAAEAAAAfAAAAQAAAAEEAAABCAAAAH4wBAAAAAAAfAAAAQwAAAEQAAABFAAAAUI8BAAAAAAAfAAAARgAAAEcAAABIAAAAEowBAAAAAAAfAAAASQAAAEoAAABLAAAAo4wBAAAAAAAfAAAATAAAAE0AAABOAAAAZY4BAAAAAAAfAAAATwAAAFAAAABRAAAAvYwBAAAAAAAfAAAAUgAAAFMAAABUAAAA8YsBAAAAAAAfAAAAVQAAAFYAAABXAAAAFI8BAAAAAAAfAAAAWAAAAFkAAABaAAAAs44BAAAAAAAfAAAAWwAAAFwAAABdAAAAWI4BAAAAAAAfAAAAXgAAAF8AAABgAAAA+40BAAAAAAAfAAAAYQAAAGIAAABjAAAALY0BAAAAAAAfAAAAZAAAAGUAAABmAAAAsIwBAAAAAAAfAAAAZwAAAGgAAABpAAAARIwBAAAAAAAfAAAAagAAAGsAAABsAAAAYYsBAAAAAAAfAAAAbQAAAG4AAABvAAAAA48BAAAAAAAfAAAAcAAAAHEAAAByAAAAn44BAAAAAAAfAAAAcwAAAHQAAAB1AAAARI4BAAAAAAAfAAAAdgAAAHcAAAB4AAAAdo0BAAAAAAAfAAAAeQAAAHoAAAB7AAAAB40BAAAAAAAfAAAAfAAAAH0AAAB+AAAAiowBAAAAAAAfAAAAfwAAAIAAAACBAAAAMIwBAAAAAAAfAAAAggAAAIMAAACEAAAA3YsBAAAAAAAfAAAAhQAAAIYAAACHAAAAeIsBAAAAAAAfAAAAiAAAAIkAAACKAAAAao8BAAAAAAAfAAAAiwAAAIwAAACNAAAA344BAAAAAAAfAAAAjgAAAI8AAACQAAAALo4BAAAAAAAfAAAAkQAAAJIAAACTAAAAU40BAAAAAAAfAAAAlAAAAJUAAACWAAAA64wBAAAAAAAfAAAAlwAAAJgAAACZAAAAdIwBAAAAAAAfAAAAmgAAAJsAAACcAAAAMnoBAAAAAAAfAAAAnQAAAJ4AAACfAAAAPXUBAAAAAAAfAAAAoAAAAKEAAACiAAAAFi4BAAAAAAAfAAAAowAAAKQAAAClAAAA5TcBAAAAAAAfAAAApgAAAKcAAACoAAAAamYBAAAAAAAfAAAAqQAAAKoAAACrAAAAZD4BAAAAAAAfAAAArAAAAK0AAACuAAAALGEBAAAAAAAkAAAAJQAAACYAAAAnAAAACVQBAAEAAAAfAAAArwAAALAAAACxAAAA3DcBAAAAAAAfAAAAsgAAALMAAAC0AAAA4GwBAAAAAAAfAAAAtQAAALYAAAC3AAAAt0EBAAAAAAAfAAAAuAAAALkAAAC6AAAAX0IBAAAAAAAfAAAAuwAAALwAAAC9AAAAXVYBAAAAAAAkAAAAJQAAACYAAAAnAAAAoHcBAAEAAAAkAAAAJQAAACYAAAAnAAAAJy4BAAEAAAAkAAAAJQAAACYAAAAnAAAAW30BAAEAAAAkAAAAJQAAACYAAAAnAAAASD4BAAEAAAA4AAAAIQAAACIAAAApAAAAUXoBAAEAAAA4AAAAIQAAACIAAAApAAAAZX0BAAEAAAAfAAAAvgAAAL8AAADAAAAAV48BAAAAAAAXAAAAGAAAABkAAAAaAAAAi4cBAAEAAAAXAAAAGAAAABkAAAAaAAAAMy4BAAEAAAAXAAAAGAAAABkAAAAaAAAAgH0BAAEAAAAXAAAAGAAAABkAAAAaAAAAVj4BAAEAAAAfAAAAwQAAAMIAAADDAAAANY8BAAAAAAAfAAAAxAAAAMUAAADGAAAAx44BAAAAAAAfAAAAxwAAAMgAAADJAAAAc44BAAAAAAAfAAAAygAAAMsAAADMAAAACY4BAAAAAAAfAAAAzQAAAM4AAADPAAAAO40BAAAAAAAfAAAA0AAAANEAAADSAAAAy4wBAAAAAAAfAAAA0wAAANQAAADVAAAAUowBAAAAAAAfAAAA1gAAANcAAADYAAAA/4sBAAAAAAAfAAAA2QAAANoAAADbAAAAqYsBAAAAAAAfAAAA3AAAAN0AAADeAAAAG40BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAADAAAAAAMAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHBwAABwcHBwAHBwADAAMAAwMAAAMDAwMAAwMHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAcAAAcHBwcAAAcAAwAAAAMDAAADAwMDAAADBwcHAAcHBwcHBwcHBwcHBwAHBwcHBwcABwcHBwcHBwMDAwMAAwMDAwMDAwMDAwMDAAMDAwMDAwADAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwMHAAcHAAAHBwcHAAcAAAMAAwADAwAAAwMDAwcDAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcHBwcHBwcHBwcHBwAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwMDAwMDAwMDAwMDAAMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHBwcABwAHBwMHBwcHBwcHBwcHBwcHBwcHBwAHBwcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAMAAAAAAwAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcABwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwcHBwcHAAcHBwcHAAcHAAMDAwMDAwADAwMDAwADAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAcAAAAAAAMAAAMAAwAAAAADBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcABwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwMABwMHAAcABwMHAAAHBwMHAwcDAAcDAwMHAwcDAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwADAAMAAAAAAAAAAAAHAwAAAwADAAcDBwAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAwcAAAcAAwAHAAcAAwcAAAcDBwAAAAMDAwAHAwcDBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMAAwMAAAAAAAMAAAAAAAcHAAcHAAAAAAAHAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAHAAcHBwcAAAAAAAAAAAAAAwADAwMDAAAABwAHAAAAAAcAAAAABwAAAAMAAwAAAAMDAAcAAwMHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAHBwADAAAAAAAABwAHBwcHAwAAAAAAAAAAAAMAAwMDAwAHAwcABwAABwAHAAAAAAcAAAcDAwMAAAMAAwADBwMDBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAcABwAHAAAAAAAAAAAAAAADAAMAAwcAAAAAAAAAAAAAAwAAAAAAAAAAAAADAAAAAAMAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAwcABwcHAAcABwcDBwcHBwcHBwcHBwcHBwcHBwcABwcHBwcHBwcHAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAMAAwAABwAAAAAAAAAAAAADAAAAAAAAAAAAAAMAAAAAAwAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcABwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAgICAgICAgAAAAAAAAAHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAcAAAAAAAMAAAMAAwAAAAADBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcABwcHBwcHBwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgICAgICAgIAAAAAAAAABwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgICAgICAgICAAAAAAAAAAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1twB/AEAABABAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQpcAAAAAA0KXCMAAABcIAkMDQsKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAQAsAAAABAAAAAwAAQAsAAAQAAAAACwAAAAEAAAADAABACwAAQCEAAEAFAAAACwAAAAEAAAADAABACwAAAAsAAAABAAAAAwAAQAsAAAIAAAACAAAACIAAAAABAADAAQAAEAAAAAABAAAABAAAwAEAAAQAAAAACwAAAAEAAAADAABACwAAIBAAAAIAAAAACwAAAAEAAAADAABACwAAAgAAAACAAAAEAAAAAFABAAQAAAACAAAAAAsAAAABAAAAAwAAQAsAAAIAAABAAQAAAAEAAAABAAAAAAAAAAAAAKqOAQBPjgEA8o0BABKNAQCajAEAO4wBAOiLAQCDiwEAWIsBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMBAwMDAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///z8/Pz8/PDwAAAAAAAAAMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKoAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg////////////////////////////////8A/woLDA0OD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////zBGAgC4NgIATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAADBGAgAANwIATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAAAwRgIATDcCAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAMEYCAJg3AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUAADBGAgDANwIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAAAwRgIA6DcCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQAAMEYCABA4AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAADBGAgA4OAIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAAAwRgIAYDgCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAAMEYCAIg4AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAADBGAgCwOAIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAAAwRgIA2DgCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAAMEYCAAA5AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l4RUUAADBGAgAoOQIATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeUVFAAAwRgIAUDkCAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQAAMEYCAHg5AgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUAAAOTAQD/nQEA/50BAP+dAQD/nQEA/50BAP+dAQD/nQEA/50BAP+dAQB/f39/f39/f39/f39/fwAAKFECAAAAAAAAAAAAAAAAANF0ngBXnb0qgHBSD///PicKAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCAlpgAAOH1BRgAAAA1AAAAcQAAAGv////O+///kr///wAAAAAAAAAAGQALABkZGQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAAZAAoKGRkZAwoHAAEACQsYAAAJBgsAAAsABhkAAAAZGRkAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAGQALDRkZGQANAAACAAkOAAAACQAOAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAABMAAAAAEwAAAAAJDAAAAAAADAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAPAAAABA8AAAAACRAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAEQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABoAAAAaGhoAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAXAAAAABcAAAAACRQAAAAAABQAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFgAAAAAAAAAAAAAAFQAAAAAVAAAAAAkWAAAAAAAWAAAWAAAwMTIzNDU2Nzg5QUJDREVGTm8gZXJyb3IgaW5mb3JtYXRpb24ASWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVk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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHgAAAB8AAAABAAAAHgAAAB8AAAABAAAAJAAAACUAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAkAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAcAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAkAAAABAAAAAAAAAAAAAAAAAAAABAAAAAgAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAcAAAABAAAAAAAAAAAAAAAAAAAABgAAAAcAAAABAAAAAAAAAAAAAAAAAAAABgAAAAcAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHgAAAB8AAAABAAAAHgAAAB8AAAABAAAAHAAAAB0AAAABAQAAJAAAACUAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAJgAAACcAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAACkAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACEAAAABAAAALgAAABIAAAABAAAAGAAAABkAAAABAAAALgAAABIAAAABAAAAJgAAACcAAAABAAAALgAAABIAAAABAAAAFAAAABQAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAACkAAAABAAAALgAAABIAAAABAAAAKAAAACkAAAABAAAALgAAABIAAAABAAAALAAAACwAAAABAAAALgAAABIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALgAAAC4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAABgAAAAAAAAAGAAAABgAAAAAAAAAKgAAACoAAAAAAAAAKgAAADQAAAAAAAAALgAAAC4AAAAAAAAAKAAAACgAAAAAAAAALgAAAC4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAFAAAAAAAAAAAAAADnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADoAAAA6QAAAKBTAgAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAA//////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoUQIAAAAAAAUAAAAAAAAAAAAAAOoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOgAAADrAAAAqFMCAAAEAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAD/////CgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMBRAgCgWQIAAJQBD3RhcmdldF9mZWF0dXJlcwgrC2J1bGstbWVtb3J5Kw9idWxrLW1lbW9yeS1vcHQrFmNhbGwtaW5kaXJlY3Qtb3ZlcmxvbmcrCm11bHRpdmFsdWUrD211dGFibGUtZ2xvYmFscysTbm9udHJhcHBpbmctZnB0b2ludCsPcmVmZXJlbmNlLXR5cGVzKwhzaWduLWV4dA==');
}

function getBinarySync(file) {
  if (ArrayBuffer.isView(file)) {
    return file;
  }
  if (file == wasmBinaryFile && wasmBinary) {
    return new Uint8Array(wasmBinary);
  }
  if (readBinary) {
    return readBinary(file);
  }
  throw 'both async and sync fetching of the wasm failed';
}

async function getWasmBinary(binaryFile) {

  // Otherwise, getBinarySync should be able to get it synchronously
  return getBinarySync(binaryFile);
}

async function instantiateArrayBuffer(binaryFile, imports) {
  try {
    var binary = await getWasmBinary(binaryFile);
    var instance = await WebAssembly.instantiate(binary, imports);
    return instance;
  } catch (reason) {
    err(`failed to asynchronously prepare wasm: ${reason}`);

    // Warn on some common problems.
    if (isFileURI(wasmBinaryFile)) {
      err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);
    }
    abort(reason);
  }
}

async function instantiateAsync(binary, binaryFile, imports) {
  return instantiateArrayBuffer(binaryFile, imports);
}

function getWasmImports() {
  // prepare imports
  return {
    'env': wasmImports,
    'wasi_snapshot_preview1': wasmImports,
  }
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
async function createWasm() {
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    wasmExports = instance.exports;

    

    wasmMemory = wasmExports['memory'];
    
    assert(wasmMemory, 'memory not found in wasm exports');
    updateMemoryViews();

    wasmTable = wasmExports['__indirect_function_table'];
    
    assert(wasmTable, 'table not found in wasm exports');

    assignWasmExports(wasmExports);
    removeRunDependency('wasm-instantiate');
    return wasmExports;
  }
  // wait for the pthread pool (if any)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above PTHREADS-enabled path.
    return receiveInstance(result['instance']);
  }

  var info = getWasmImports();

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to
  // run the instantiation parallel to any other async startup actions they are
  // performing.
  // Also pthreads and wasm workers initialize the wasm instance through this
  // path.
  if (Module['instantiateWasm']) {
    return new Promise((resolve, reject) => {
      try {
        Module['instantiateWasm'](info, (mod, inst) => {
          resolve(receiveInstance(mod, inst));
        });
      } catch(e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        reject(e);
      }
    });
  }

  wasmBinaryFile ??= findWasmBinary();
  var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
  var exports = receiveInstantiationResult(result);
  return exports;
}

// end include: preamble.js

// Begin JS library code


  class ExitStatus {
      name = 'ExitStatus';
      constructor(status) {
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
    }

  var callRuntimeCallbacks = (callbacks) => {
      while (callbacks.length > 0) {
        // Pass the module as the first argument.
        callbacks.shift()(Module);
      }
    };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.push(cb);

  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.push(cb);

  /** @noinline */
  var base64Decode = (b64) => {
      {
        var buf = Buffer.from(b64, 'base64');
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
      }
    };

  var noExitRuntime = true;

  var ptrToString = (ptr) => {
      assert(typeof ptr === 'number');
      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
      ptr >>>= 0;
      return '0x' + ptr.toString(16).padStart(8, '0');
    };

  var warnOnce = (text) => {
      warnOnce.shown ||= {};
      if (!warnOnce.shown[text]) {
        warnOnce.shown[text] = 1;
        text = 'warning: ' + text;
        err(text);
      }
    };

  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;
  
  var findStringEnd = (heapOrArray, idx, maxBytesToRead, ignoreNul) => {
      var maxIdx = idx + maxBytesToRead;
      if (ignoreNul) return maxIdx;
      // TextDecoder needs to know the byte length in advance, it doesn't stop on
      // null terminator by itself.
      // As a tiny code save trick, compare idx against maxIdx using a negation,
      // so that maxBytesToRead=undefined/NaN means Infinity.
      while (heapOrArray[idx] && !(idx >= maxIdx)) ++idx;
      return idx;
    };
  
  
    /**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number=} idx
     * @param {number=} maxBytesToRead
     * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.
     * @return {string}
     */
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead, ignoreNul) => {
  
      var endPtr = findStringEnd(heapOrArray, idx, maxBytesToRead, ignoreNul);
  
      // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = '';
      while (idx < endPtr) {
        // For UTF8 byte structure, see:
        // http://en.wikipedia.org/wiki/UTF-8#Description
        // https://www.ietf.org/rfc/rfc2279.txt
        // https://tools.ietf.org/html/rfc3629
        var u0 = heapOrArray[idx++];
        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 0xF0) == 0xE0) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');
          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
        }
  
        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
        }
      }
      return str;
    };
  
    /**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index.
     * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.
     * @return {string}
     */
  var UTF8ToString = (ptr, maxBytesToRead, ignoreNul) => {
      assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead, ignoreNul) : '';
    };
  var ___assert_fail = (condition, filename, line, func) =>
      abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);

  var __abort_js = () =>
      abort('native code called abort()');

  var AsciiToString = (ptr) => {
      var str = '';
      while (1) {
        var ch = HEAPU8[ptr++];
        if (!ch) return str;
        str += String.fromCharCode(ch);
      }
    };
  
  var awaitingDependencies = {
  };
  
  var registeredTypes = {
  };
  
  var typeDependencies = {
  };
  
  var BindingError =  class BindingError extends Error { constructor(message) { super(message); this.name = 'BindingError'; }};
  var throwBindingError = (message) => { throw new BindingError(message); };
  /** @param {Object=} options */
  function sharedRegisterType(rawType, registeredInstance, options = {}) {
      var name = registeredInstance.name;
      if (!rawType) {
        throwBindingError(`type "${name}" must have a positive integer typeid pointer`);
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
        if (options.ignoreDuplicateRegistrations) {
          return;
        } else {
          throwBindingError(`Cannot register type '${name}' twice`);
        }
      }
  
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
  
      if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];
        delete awaitingDependencies[rawType];
        callbacks.forEach((cb) => cb());
      }
    }
  /** @param {Object=} options */
  function registerType(rawType, registeredInstance, options = {}) {
      return sharedRegisterType(rawType, registeredInstance, options);
    }
  
  var integerReadValueFromPointer = (name, width, signed) => {
      // integers are quite common, so generate very specialized functions
      switch (width) {
        case 1: return signed ?
          (pointer) => HEAP8[pointer] :
          (pointer) => HEAPU8[pointer];
        case 2: return signed ?
          (pointer) => HEAP16[((pointer)>>1)] :
          (pointer) => HEAPU16[((pointer)>>1)]
        case 4: return signed ?
          (pointer) => HEAP32[((pointer)>>2)] :
          (pointer) => HEAPU32[((pointer)>>2)]
        case 8: return signed ?
          (pointer) => HEAP64[((pointer)>>3)] :
          (pointer) => HEAPU64[((pointer)>>3)]
        default:
          throw new TypeError(`invalid integer width (${width}): ${name}`);
      }
    };
  
  var embindRepr = (v) => {
      if (v === null) {
          return 'null';
      }
      var t = typeof v;
      if (t === 'object' || t === 'array' || t === 'function') {
          return v.toString();
      } else {
          return '' + v;
      }
    };
  
  var assertIntegerRange = (typeName, value, minRange, maxRange) => {
      if (value < minRange || value > maxRange) {
        throw new TypeError(`Passing a number "${embindRepr(value)}" from JS side to C/C++ side to an argument of type "${typeName}", which is outside the valid range [${minRange}, ${maxRange}]!`);
      }
    };
  /** @suppress {globalThis} */
  var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {
      name = AsciiToString(name);
  
      const isUnsignedType = minRange === 0n;
  
      let fromWireType = (value) => value;
      if (isUnsignedType) {
        // uint64 get converted to int64 in ABI, fix them up like we do for 32-bit integers.
        const bitSize = size * 8;
        fromWireType = (value) => {
          return BigInt.asUintN(bitSize, value);
        };
        maxRange = fromWireType(maxRange);
      }
  
      registerType(primitiveType, {
        name,
        fromWireType: fromWireType,
        toWireType: (destructors, value) => {
          if (typeof value == "number") {
            value = BigInt(value);
          }
          else if (typeof value != "bigint") {
            throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${this.name}`);
          }
          assertIntegerRange(name, value, minRange, maxRange);
          return value;
        },
        readValueFromPointer: integerReadValueFromPointer(name, size, !isUnsignedType),
        destructorFunction: null, // This type does not need a destructor
      });
    };

  
  /** @suppress {globalThis} */
  var __embind_register_bool = (rawType, name, trueValue, falseValue) => {
      name = AsciiToString(name);
      registerType(rawType, {
        name,
        fromWireType: function(wt) {
          // ambiguous emscripten ABI: sometimes return values are
          // true or false, and sometimes integers (0 or 1)
          return !!wt;
        },
        toWireType: function(destructors, o) {
          return o ? trueValue : falseValue;
        },
        readValueFromPointer: function(pointer) {
          return this.fromWireType(HEAPU8[pointer]);
        },
        destructorFunction: null, // This type does not need a destructor
      });
    };

  
  var emval_freelist = [];
  
  var emval_handles = [0,1,,1,null,1,true,1,false,1];
  var __emval_decref = (handle) => {
      if (handle > 9 && 0 === --emval_handles[handle + 1]) {
        assert(emval_handles[handle] !== undefined, `Decref for unallocated handle.`);
        emval_handles[handle] = undefined;
        emval_freelist.push(handle);
      }
    };
  
  
  
  var Emval = {
  toValue:(handle) => {
        if (!handle) {
            throwBindingError(`Cannot use deleted val. handle = ${handle}`);
        }
        // handle 2 is supposed to be `undefined`.
        assert(handle === 2 || emval_handles[handle] !== undefined && handle % 2 === 0, `invalid handle: ${handle}`);
        return emval_handles[handle];
      },
  toHandle:(value) => {
        switch (value) {
          case undefined: return 2;
          case null: return 4;
          case true: return 6;
          case false: return 8;
          default:{
            const handle = emval_freelist.pop() || emval_handles.length;
            emval_handles[handle] = value;
            emval_handles[handle + 1] = 1;
            return handle;
          }
        }
      },
  };
  
  /** @suppress {globalThis} */
  function readPointer(pointer) {
      return this.fromWireType(HEAPU32[((pointer)>>2)]);
    }
  var EmValType = {
      name: 'emscripten::val',
      fromWireType: (handle) => {
        var rv = Emval.toValue(handle);
        __emval_decref(handle);
        return rv;
      },
      toWireType: (destructors, value) => Emval.toHandle(value),
      readValueFromPointer: readPointer,
      destructorFunction: null, // This type does not need a destructor
  
      // TODO: do we need a deleteObject here?  write a test where
      // emval is passed into JS via an interface
    };
  var __embind_register_emval = (rawType) => registerType(rawType, EmValType);

  var floatReadValueFromPointer = (name, width) => {
      switch (width) {
        case 4: return function(pointer) {
          return this.fromWireType(HEAPF32[((pointer)>>2)]);
        };
        case 8: return function(pointer) {
          return this.fromWireType(HEAPF64[((pointer)>>3)]);
        };
        default:
          throw new TypeError(`invalid float width (${width}): ${name}`);
      }
    };
  
  
  
  var __embind_register_float = (rawType, name, size) => {
      name = AsciiToString(name);
      registerType(rawType, {
        name,
        fromWireType: (value) => value,
        toWireType: (destructors, value) => {
          if (typeof value != "number" && typeof value != "boolean") {
            throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);
          }
          // The VM will perform JS to Wasm value conversion, according to the spec:
          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
          return value;
        },
        readValueFromPointer: floatReadValueFromPointer(name, size),
        destructorFunction: null, // This type does not need a destructor
      });
    };

  var createNamedFunction = (name, func) => Object.defineProperty(func, 'name', { value: name });
  
  var runDestructors = (destructors) => {
      while (destructors.length) {
        var ptr = destructors.pop();
        var del = destructors.pop();
        del(ptr);
      }
    };
  
  
  function usesDestructorStack(argTypes) {
      // Skip return value at index 0 - it's not deleted here.
      for (var i = 1; i < argTypes.length; ++i) {
        // The type does not define a destructor function - must use dynamic stack
        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
          return true;
        }
      }
      return false;
    }
  
  
  function checkArgCount(numArgs, minArgs, maxArgs, humanName, throwBindingError) {
      if (numArgs < minArgs || numArgs > maxArgs) {
        var argCountMessage = minArgs == maxArgs ? minArgs : `${minArgs} to ${maxArgs}`;
        throwBindingError(`function ${humanName} called with ${numArgs} arguments, expected ${argCountMessage}`);
      }
    }
  function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {
      var needsDestructorStack = usesDestructorStack(argTypes);
      var argCount = argTypes.length - 2;
      var argsList = [];
      var argsListWired = ['fn'];
      for (var i = 0; i < argCount; ++i) {
        argsList.push(`arg${i}`);
        argsListWired.push(`arg${i}Wired`);
      }
      argsList = argsList.join(',');
      argsListWired = argsListWired.join(',');
  
      var invokerFnBody = `return function (${argsList}) {\n`;
  
      invokerFnBody += "checkArgCount(arguments.length, minArgs, maxArgs, humanName, throwBindingError);\n";
  
      if (needsDestructorStack) {
        invokerFnBody += "var destructors = [];\n";
      }
  
      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = ["humanName", "throwBindingError", "invoker", "fn", "runDestructors", "fromRetWire", "toClassParamWire"];
  
      for (var i = 0; i < argCount; ++i) {
        var argName = `toArg${i}Wire`;
        invokerFnBody += `var arg${i}Wired = ${argName}(${dtorStack}, arg${i});\n`;
        args1.push(argName);
      }
  
      invokerFnBody += (returns || isAsync ? "var rv = ":"") + `invoker(${argsListWired});\n`;
  
      if (needsDestructorStack) {
        invokerFnBody += "runDestructors(destructors);\n";
      } else {
        for (var i = 2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
          var paramName = (i === 1 ? "thisWired" : ("arg"+(i - 2)+"Wired"));
          if (argTypes[i].destructorFunction !== null) {
            invokerFnBody += `${paramName}_dtor(${paramName});\n`;
            args1.push(`${paramName}_dtor`);
          }
        }
      }
  
      if (returns) {
        invokerFnBody += "var ret = fromRetWire(rv);\n" +
                         "return ret;\n";
      }
  
      invokerFnBody += "}\n";
  
      args1.push('checkArgCount', 'minArgs', 'maxArgs');
      invokerFnBody = `if (arguments.length !== ${args1.length}){ throw new Error(humanName + "Expected ${args1.length} closure arguments " + arguments.length + " given."); }\n${invokerFnBody}`;
      return new Function(args1, invokerFnBody);
    }
  
  function getRequiredArgCount(argTypes) {
      var requiredArgCount = argTypes.length - 2;
      for (var i = argTypes.length - 1; i >= 2; --i) {
        if (!argTypes[i].optional) {
          break;
        }
        requiredArgCount--;
      }
      return requiredArgCount;
    }
  
  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, /** boolean= */ isAsync) {
      // humanName: a human-readable string name for the function to be generated.
      // argTypes: An array that contains the embind type objects for all types in the function signature.
      //    argTypes[0] is the type object for the function return value.
      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.
      //    argTypes[2...] are the actual function parameters.
      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.
      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.
      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.
      // isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.
      var argCount = argTypes.length;
  
      if (argCount < 2) {
        throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }
  
      assert(!isAsync, 'Async bindings are only supported with JSPI.');
      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);
  
      // Free functions with signature "void function()" do not need an invoker that marshalls between wire types.
      // TODO: This omits argument count check - enable only at -O3 or similar.
      //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == "void" && !isClassMethodFunc) {
      //       return FUNCTION_TABLE[fn];
      //    }
  
      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.
      // TODO: Remove this completely once all function invokers are being dynamically generated.
      var needsDestructorStack = usesDestructorStack(argTypes);
  
      var returns = !argTypes[0].isVoid;
  
      var expectedArgCount = argCount - 2;
      var minArgs = getRequiredArgCount(argTypes);
      // Builld the arguments that will be passed into the closure around the invoker
      // function.
      var retType = argTypes[0];
      var instType = argTypes[1];
      var closureArgs = [humanName, throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, retType.fromWireType.bind(retType), instType?.toWireType.bind(instType)];
      for (var i = 2; i < argCount; ++i) {
        var argType = argTypes[i];
        closureArgs.push(argType.toWireType.bind(argType));
      }
      if (!needsDestructorStack) {
        // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
        for (var i = 2; i < argTypes.length; ++i) {
          if (argTypes[i].destructorFunction !== null) {
            closureArgs.push(argTypes[i].destructorFunction);
          }
        }
      }
      closureArgs.push(checkArgCount, minArgs, expectedArgCount);
  
      let invokerFactory = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);
      var invokerFn = invokerFactory(...closureArgs);
      return createNamedFunction(humanName, invokerFn);
    }
  
  var ensureOverloadTable = (proto, methodName, humanName) => {
      if (undefined === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];
        // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.
        proto[methodName] = function(...args) {
          // TODO This check can be removed in -O3 level "unsafe" optimizations.
          if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {
            throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);
          }
          return proto[methodName].overloadTable[args.length].apply(this, args);
        };
        // Move the previous function into the overload table.
        proto[methodName].overloadTable = [];
        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    };
  
  /** @param {number=} numArguments */
  var exposePublicSymbol = (name, value, numArguments) => {
      if (Module.hasOwnProperty(name)) {
        if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {
          throwBindingError(`Cannot register public name '${name}' twice`);
        }
  
        // We are exposing a function with the same name as an existing function. Create an overload table and a function selector
        // that routes between the two.
        ensureOverloadTable(Module, name, name);
        if (Module[name].overloadTable.hasOwnProperty(numArguments)) {
          throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
        }
        // Add the new function into the overload table.
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;
        Module[name].argCount = numArguments;
      }
    };
  
  var heap32VectorToArray = (count, firstElement) => {
      var array = [];
      for (var i = 0; i < count; i++) {
        // TODO(https://github.com/emscripten-core/emscripten/issues/17310):
        // Find a way to hoist the `>> 2` or `>> 3` out of this loop.
        array.push(HEAPU32[(((firstElement)+(i * 4))>>2)]);
      }
      return array;
    };
  
  
  var InternalError =  class InternalError extends Error { constructor(message) { super(message); this.name = 'InternalError'; }};
  var throwInternalError = (message) => { throw new InternalError(message); };
  /** @param {number=} numArguments */
  var replacePublicSymbol = (name, value, numArguments) => {
      if (!Module.hasOwnProperty(name)) {
        throwInternalError('Replacing nonexistent public symbol');
      }
      // If there's an overload table for this symbol, replace the symbol in the overload table instead.
      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;
        Module[name].argCount = numArguments;
      }
    };
  
  
  
  var wasmTableMirror = [];
  
  /** @type {WebAssembly.Table} */
  var wasmTable;
  var getWasmTableEntry = (funcPtr) => {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        /** @suppress {checkTypes} */
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      /** @suppress {checkTypes} */
      assert(wasmTable.get(funcPtr) == func, 'JavaScript-side Wasm function table mirror is out of date!');
      return func;
    };
  var embind__requireFunction = (signature, rawFunction, isAsync = false) => {
      assert(!isAsync, 'Async bindings are only supported with JSPI.');
  
      signature = AsciiToString(signature);
  
      function makeDynCaller() {
        var rtn = getWasmTableEntry(rawFunction);
        return rtn;
      }
  
      var fp = makeDynCaller();
      if (typeof fp != 'function') {
          throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
      }
      return fp;
    };
  
  
  
  class UnboundTypeError extends Error {}
  
  
  
  var getTypeName = (type) => {
      var ptr = ___getTypeName(type);
      var rv = AsciiToString(ptr);
      _free(ptr);
      return rv;
    };
  var throwUnboundTypeError = (message, types) => {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
        if (seen[type]) {
          return;
        }
        if (registeredTypes[type]) {
          return;
        }
        if (typeDependencies[type]) {
          typeDependencies[type].forEach(visit);
          return;
        }
        unboundTypes.push(type);
        seen[type] = true;
      }
      types.forEach(visit);
  
      throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([', ']));
    };
  
  
  
  
  var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {
      myTypes.forEach((type) => typeDependencies[type] = dependentTypes);
  
      function onComplete(typeConverters) {
        var myTypeConverters = getTypeConverters(typeConverters);
        if (myTypeConverters.length !== myTypes.length) {
          throwInternalError('Mismatched type converter count');
        }
        for (var i = 0; i < myTypes.length; ++i) {
          registerType(myTypes[i], myTypeConverters[i]);
        }
      }
  
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach((dt, i) => {
        if (registeredTypes.hasOwnProperty(dt)) {
          typeConverters[i] = registeredTypes[dt];
        } else {
          unregisteredTypes.push(dt);
          if (!awaitingDependencies.hasOwnProperty(dt)) {
            awaitingDependencies[dt] = [];
          }
          awaitingDependencies[dt].push(() => {
            typeConverters[i] = registeredTypes[dt];
            ++registered;
            if (registered === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          });
        }
      });
      if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
      }
    };
  
  var getFunctionName = (signature) => {
      signature = signature.trim();
      const argsIndex = signature.indexOf("(");
      if (argsIndex === -1) return signature;
      assert(signature.endsWith(")"), "Parentheses for argument names should match.");
      return signature.slice(0, argsIndex);
    };
  var __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync, isNonnullReturn) => {
      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      name = AsciiToString(name);
      name = getFunctionName(name);
  
      rawInvoker = embind__requireFunction(signature, rawInvoker, isAsync);
  
      exposePublicSymbol(name, function() {
        throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);
      }, argCount - 1);
  
      whenDependentTypesAreResolved([], argTypes, (argTypes) => {
        var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);
        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn, isAsync), argCount - 1);
        return [];
      });
    };

  
  
  
  
  /** @suppress {globalThis} */
  var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {
      name = AsciiToString(name);
  
      const isUnsignedType = minRange === 0;
  
      let fromWireType = (value) => value;
      if (isUnsignedType) {
        var bitshift = 32 - 8*size;
        fromWireType = (value) => (value << bitshift) >>> bitshift;
        maxRange = fromWireType(maxRange);
      }
  
      registerType(primitiveType, {
        name,
        fromWireType: fromWireType,
        toWireType: (destructors, value) => {
          if (typeof value != "number" && typeof value != "boolean") {
            throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${name}`);
          }
          assertIntegerRange(name, value, minRange, maxRange);
          // The VM will perform JS to Wasm value conversion, according to the spec:
          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue
          return value;
        },
        readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0),
        destructorFunction: null, // This type does not need a destructor
      });
    };

  
  var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {
      var typeMapping = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
        BigInt64Array,
        BigUint64Array,
      ];
  
      var TA = typeMapping[dataTypeIndex];
  
      function decodeMemoryView(handle) {
        var size = HEAPU32[((handle)>>2)];
        var data = HEAPU32[(((handle)+(4))>>2)];
        return new TA(HEAP8.buffer, data, size);
      }
  
      name = AsciiToString(name);
      registerType(rawType, {
        name,
        fromWireType: decodeMemoryView,
        readValueFromPointer: decodeMemoryView,
      }, {
        ignoreDuplicateRegistrations: true,
      });
    };

  
  
  
  
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);
      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
      // undefined and false each don't write out any bytes.
      if (!(maxBytesToWrite > 0))
        return 0;
  
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
      for (var i = 0; i < str.length; ++i) {
        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
        // and https://www.ietf.org/rfc/rfc2279.txt
        // and https://tools.ietf.org/html/rfc3629
        var u = str.codePointAt(i);
        if (u <= 0x7F) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 0x7FF) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 0xC0 | (u >> 6);
          heap[outIdx++] = 0x80 | (u & 63);
        } else if (u <= 0xFFFF) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 0xE0 | (u >> 12);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');
          heap[outIdx++] = 0xF0 | (u >> 18);
          heap[outIdx++] = 0x80 | ((u >> 12) & 63);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
          // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.
          // We need to manually skip over the second code unit for correct iteration.
          i++;
        }
      }
      // Null-terminate the pointer to the buffer.
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    };
  
  var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        var c = str.charCodeAt(i); // possibly a lead surrogate
        if (c <= 0x7F) {
          len++;
        } else if (c <= 0x7FF) {
          len += 2;
        } else if (c >= 0xD800 && c <= 0xDFFF) {
          len += 4; ++i;
        } else {
          len += 3;
        }
      }
      return len;
    };
  
  
  
  var __embind_register_std_string = (rawType, name) => {
      name = AsciiToString(name);
  
      registerType(rawType, {
        name,
        // For some method names we use string keys here since they are part of
        // the public/external API and/or used by the runtime-generated code.
        fromWireType(value) {
          var length = HEAPU32[((value)>>2)];
          var payload = value + 4;
  
          var str;
          {
            str = UTF8ToString(payload, length, true);
          }
  
          _free(value);
  
          return str;
        },
        toWireType(destructors, value) {
          if (value instanceof ArrayBuffer) {
            value = new Uint8Array(value);
          }
  
          var length;
          var valueIsOfTypeString = (typeof value == 'string');
  
          // We accept `string` or array views with single byte elements
          if (!(valueIsOfTypeString || (ArrayBuffer.isView(value) && value.BYTES_PER_ELEMENT == 1))) {
            throwBindingError('Cannot pass non-string to std::string');
          }
          if (valueIsOfTypeString) {
            length = lengthBytesUTF8(value);
          } else {
            length = value.length;
          }
  
          // assumes POINTER_SIZE alignment
          var base = _malloc(4 + length + 1);
          var ptr = base + 4;
          HEAPU32[((base)>>2)] = length;
          if (valueIsOfTypeString) {
            {
              stringToUTF8(value, ptr, length + 1);
            }
          } else {
            HEAPU8.set(value, ptr);
          }
  
          if (destructors !== null) {
            destructors.push(_free, base);
          }
          return base;
        },
        readValueFromPointer: readPointer,
        destructorFunction(ptr) {
          _free(ptr);
        },
      });
    };

  
  
  
  var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;  
  var UTF16ToString = (ptr, maxBytesToRead, ignoreNul) => {
      assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
      var idx = ((ptr)>>1);
      var endIdx = findStringEnd(HEAPU16, idx, maxBytesToRead / 2, ignoreNul);
  
      // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.
      if (endIdx - idx > 16 && UTF16Decoder)
        return UTF16Decoder.decode(HEAPU16.subarray(idx, endIdx));
  
      // Fallback: decode without UTF16Decoder
      var str = '';
  
      // If maxBytesToRead is not passed explicitly, it will be undefined, and the
      // for-loop's condition will always evaluate to true. The loop is then
      // terminated on the first null char.
      for (var i = idx; i < endIdx; ++i) {
        var codeUnit = HEAPU16[i];
        // fromCharCode constructs a character from a UTF-16 code unit, so we can
        // pass the UTF16 string right through.
        str += String.fromCharCode(codeUnit);
      }
  
      return str;
    };
  
  var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
      assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
      assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
      maxBytesToWrite ??= 0x7FFFFFFF;
      if (maxBytesToWrite < 2) return 0;
      maxBytesToWrite -= 2; // Null terminator.
      var startPtr = outPtr;
      var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
      for (var i = 0; i < numCharsToWrite; ++i) {
        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
        HEAP16[((outPtr)>>1)] = codeUnit;
        outPtr += 2;
      }
      // Null-terminate the pointer to the HEAP.
      HEAP16[((outPtr)>>1)] = 0;
      return outPtr - startPtr;
    };
  
  var lengthBytesUTF16 = (str) => str.length*2;
  
  var UTF32ToString = (ptr, maxBytesToRead, ignoreNul) => {
      assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
      var str = '';
      var startIdx = ((ptr)>>2);
      // If maxBytesToRead is not passed explicitly, it will be undefined, and this
      // will always evaluate to true. This saves on code size.
      for (var i = 0; !(i >= maxBytesToRead / 4); i++) {
        var utf32 = HEAPU32[startIdx + i];
        if (!utf32 && !ignoreNul) break;
        str += String.fromCodePoint(utf32);
      }
      return str;
    };
  
  var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
      assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
      assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
      maxBytesToWrite ??= 0x7FFFFFFF;
      if (maxBytesToWrite < 4) return 0;
      var startPtr = outPtr;
      var endPtr = startPtr + maxBytesToWrite - 4;
      for (var i = 0; i < str.length; ++i) {
        var codePoint = str.codePointAt(i);
        // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.
        // We need to manually skip over the second code unit for correct iteration.
        if (codePoint > 0xFFFF) {
          i++;
        }
        HEAP32[((outPtr)>>2)] = codePoint;
        outPtr += 4;
        if (outPtr + 4 > endPtr) break;
      }
      // Null-terminate the pointer to the HEAP.
      HEAP32[((outPtr)>>2)] = 0;
      return outPtr - startPtr;
    };
  
  var lengthBytesUTF32 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var codePoint = str.codePointAt(i);
        // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.
        // We need to manually skip over the second code unit for correct iteration.
        if (codePoint > 0xFFFF) {
          i++;
        }
        len += 4;
      }
  
      return len;
    };
  var __embind_register_std_wstring = (rawType, charSize, name) => {
      name = AsciiToString(name);
      var decodeString, encodeString, lengthBytesUTF;
      if (charSize === 2) {
        decodeString = UTF16ToString;
        encodeString = stringToUTF16;
        lengthBytesUTF = lengthBytesUTF16;
      } else {
        assert(charSize === 4, 'only 2-byte and 4-byte strings are currently supported');
        decodeString = UTF32ToString;
        encodeString = stringToUTF32;
        lengthBytesUTF = lengthBytesUTF32;
      }
      registerType(rawType, {
        name,
        fromWireType: (value) => {
          // Code mostly taken from _embind_register_std_string fromWireType
          var length = HEAPU32[((value)>>2)];
          var str = decodeString(value + 4, length * charSize, true);
  
          _free(value);
  
          return str;
        },
        toWireType: (destructors, value) => {
          if (!(typeof value == 'string')) {
            throwBindingError(`Cannot pass non-string to C++ string type ${name}`);
          }
  
          // assumes POINTER_SIZE alignment
          var length = lengthBytesUTF(value);
          var ptr = _malloc(4 + length + charSize);
          HEAPU32[((ptr)>>2)] = length / charSize;
  
          encodeString(value, ptr + 4, length + charSize);
  
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr;
        },
        readValueFromPointer: readPointer,
        destructorFunction(ptr) {
          _free(ptr);
        }
      });
    };

  
  var __embind_register_void = (rawType, name) => {
      name = AsciiToString(name);
      registerType(rawType, {
        isVoid: true, // void return values can be optimized out sometimes
        name,
        fromWireType: () => undefined,
        // TODO: assert if anything else is given?
        toWireType: (destructors, o) => undefined,
      });
    };

  var emval_methodCallers = [];
  var emval_addMethodCaller = (caller) => {
      var id = emval_methodCallers.length;
      emval_methodCallers.push(caller);
      return id;
    };
  
  
  
  var requireRegisteredType = (rawType, humanName) => {
      var impl = registeredTypes[rawType];
      if (undefined === impl) {
        throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);
      }
      return impl;
    };
  var emval_lookupTypes = (argCount, argTypes) => {
      var a = new Array(argCount);
      for (var i = 0; i < argCount; ++i) {
        a[i] = requireRegisteredType(HEAPU32[(((argTypes)+(i*4))>>2)],
                                     `parameter ${i}`);
      }
      return a;
    };
  
  
  var emval_returnValue = (toReturnWire, destructorsRef, handle) => {
      var destructors = [];
      var result = toReturnWire(destructors, handle);
      if (destructors.length) {
        // void, primitives and any other types w/o destructors don't need to allocate a handle
        HEAPU32[((destructorsRef)>>2)] = Emval.toHandle(destructors);
      }
      return result;
    };
  
  
  var emval_symbols = {
  };
  
  var getStringOrSymbol = (address) => {
      var symbol = emval_symbols[address];
      if (symbol === undefined) {
        return AsciiToString(address);
      }
      return symbol;
    };
  var __emval_create_invoker = (argCount, argTypesPtr, kind) => {
      var GenericWireTypeSize = 8;
  
      var [retType, ...argTypes] = emval_lookupTypes(argCount, argTypesPtr);
      var toReturnWire = retType.toWireType.bind(retType);
      var argFromPtr = argTypes.map(type => type.readValueFromPointer.bind(type));
      argCount--; // remove the extracted return type
  
      var captures = {'toValue': Emval.toValue};
      var args = argFromPtr.map((argFromPtr, i) => {
        var captureName = `argFromPtr${i}`;
        captures[captureName] = argFromPtr;
        return `${captureName}(args${i ? '+' + i * GenericWireTypeSize : ''})`;
      });
      var functionBody;
      switch (kind){
        case 0:
          functionBody = 'toValue(handle)';
          break;
        case 2:
          functionBody = 'new (toValue(handle))';
          break;
        case 3:
          functionBody = '';
          break;
        case 1:
          captures['getStringOrSymbol'] = getStringOrSymbol;
          functionBody = 'toValue(handle)[getStringOrSymbol(methodName)]';
          break;
      }
      functionBody += `(${args})`;
      if (!retType.isVoid) {
        captures['toReturnWire'] = toReturnWire;
        captures['emval_returnValue'] = emval_returnValue;
        functionBody = `return emval_returnValue(toReturnWire, destructorsRef, ${functionBody})`;
      }
      functionBody = `return function (handle, methodName, destructorsRef, args) {
  ${functionBody}
  }`;
  
      var invokerFunction = new Function(Object.keys(captures), functionBody)(...Object.values(captures));
      var functionName = `methodCaller<(${argTypes.map(t => t.name)}) => ${retType.name}>`;
      return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));
    };


  
  
  var emval_get_global = () => globalThis;
  var __emval_get_global = (name) => {
      if (name===0) {
        return Emval.toHandle(emval_get_global());
      } else {
        name = getStringOrSymbol(name);
        return Emval.toHandle(emval_get_global()[name]);
      }
    };

  var __emval_get_property = (handle, key) => {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      return Emval.toHandle(handle[key]);
    };

  var __emval_incref = (handle) => {
      if (handle > 9) {
        emval_handles[handle + 1] += 1;
      }
    };

  
  
  var __emval_invoke = (caller, handle, methodName, destructorsRef, args) => {
      return emval_methodCallers[caller](handle, methodName, destructorsRef, args);
    };

  var __emval_new_array = () => Emval.toHandle([]);

  
  var __emval_new_cstring = (v) => Emval.toHandle(getStringOrSymbol(v));

  var __emval_new_object = () => Emval.toHandle({});

  
  
  var __emval_run_destructors = (handle) => {
      var destructors = Emval.toValue(handle);
      runDestructors(destructors);
      __emval_decref(handle);
    };

  var __emval_set_property = (handle, key, value) => {
      handle = Emval.toValue(handle);
      key = Emval.toValue(key);
      value = Emval.toValue(value);
      handle[key] = value;
    };

  var __emval_typeof = (handle) => {
      handle = Emval.toValue(handle);
      return Emval.toHandle(typeof handle);
    };
  function __munmap_js(addr, len, prot, flags, fd, offset) {
  }

  var getHeapMax = () =>
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      2147483648;
  
  var alignMemory = (size, alignment) => {
      assert(alignment, "alignment argument is required");
      return Math.ceil(size / alignment) * alignment;
    };
  
  var growMemory = (size) => {
      var oldHeapSize = wasmMemory.buffer.byteLength;
      var pages = ((size - oldHeapSize + 65535) / 65536) | 0;
      try {
        // round size grow request up to wasm page size (fixed 64KB per spec)
        wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size
        updateMemoryViews();
        return 1 /*success*/;
      } catch(e) {
        err(`growMemory: Attempted to grow heap from ${oldHeapSize} bytes to ${size} bytes, but got error: ${e}`);
      }
      // implicit 0 return to save code size (caller will cast "undefined" into 0
      // anyhow)
    };
  var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = HEAPU8.length;
      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
      requestedSize >>>= 0;
      // With multithreaded builds, races can happen (another thread might increase the size
      // in between), so return a failure, and let the caller retry.
      assert(requestedSize > oldSize);
  
      // Memory resize rules:
      // 1.  Always increase heap size to at least the requested size, rounded up
      //     to next page multiple.
      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
      //     geometrically: increase the heap size according to
      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
      //     linearly: increase the heap size by at least
      //     MEMORY_GROWTH_LINEAR_STEP bytes.
      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
      // 4.  If we were unable to allocate as much memory, it may be due to
      //     over-eager decision to excessively reserve due to (3) above.
      //     Hence if an allocation fails, cut down on the amount of excess
      //     growth, in an attempt to succeed to perform a smaller allocation.
  
      // A limit is set for how much we can grow. We should not exceed that
      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        err(`Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
        return false;
      }
  
      // Loop through potential heap size increases. If we attempt a too eager
      // reservation that fails, cut down on the attempted size and reserve a
      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
        // but limit overreserving (default to capping at +96MB overgrowth at most)
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
  
        var replacement = growMemory(newSize);
        if (replacement) {
  
          return true;
        }
      }
      err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
      return false;
    };

  
  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
      if (!keepRuntimeAlive()) {
        Module['onExit']?.(code);
        ABORT = true;
      }
      quit_(code, new ExitStatus(code));
    };
  
  
  /** @suppress {duplicate } */
  /** @param {boolean|number=} implicit */
  var exitJS = (status, implicit) => {
  
      checkUnflushedContent();
  
      // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down
      if (keepRuntimeAlive() && !implicit) {
        var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;
        readyPromiseReject?.(msg);
        err(msg);
      }
  
      _proc_exit(status);
    };
  var _exit = exitJS;
  var _fd_close = (fd) => {
      abort('fd_close called without SYSCALLS_REQUIRE_FILESYSTEM');
    };

  function _fd_seek(fd, offset, whence, newOffset) {
  
  
      return 70;
  }

  var printCharBuffers = [null,[],[]];
  
  var printChar = (stream, curr) => {
      var buffer = printCharBuffers[stream];
      assert(buffer);
      if (curr === 0 || curr === 10) {
        (stream === 1 ? out : err)(UTF8ArrayToString(buffer));
        buffer.length = 0;
      } else {
        buffer.push(curr);
      }
    };
  
  var flush_NO_FILESYSTEM = () => {
      // flush anything remaining in the buffers during shutdown
      _fflush(0);
      if (printCharBuffers[1].length) printChar(1, 10);
      if (printCharBuffers[2].length) printChar(2, 10);
    };
  
  
  var _fd_write = (fd, iov, iovcnt, pnum) => {
      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0
      var num = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        for (var j = 0; j < len; j++) {
          printChar(fd, HEAPU8[ptr+j]);
        }
        num += len;
      }
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    };

    // Precreate a reverse lookup table from chars
    // "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" back to
    // bytes to make decoding fast.
    for (var base64ReverseLookup = new Uint8Array(123/*'z'+1*/), i = 25; i >= 0; --i) {
      base64ReverseLookup[48+i] = 52+i; // '0-9'
      base64ReverseLookup[65+i] = i; // 'A-Z'
      base64ReverseLookup[97+i] = 26+i; // 'a-z'
    }
    base64ReverseLookup[43] = 62; // '+'
    base64ReverseLookup[47] = 63; // '/'
assert(emval_handles.length === 5 * 2);
// End JS library code

// include: postlibrary.js
// This file is included after the automatically-generated JS library code
// but before the wasm module is created.

{

  // Begin ATMODULES hooks
  if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];
if (Module['print']) out = Module['print'];
if (Module['printErr']) err = Module['printErr'];
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];

Module['FS_createDataFile'] = FS.createDataFile;
Module['FS_createPreloadedFile'] = FS.createPreloadedFile;

  // End ATMODULES hooks

  checkIncomingModuleAPI();

  if (Module['arguments']) Module['arguments'];
  if (Module['thisProgram']) Module['thisProgram'];

  // Assertions on removed incoming Module JS APIs.
  assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['read'] == 'undefined', 'Module.read option was removed');
  assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
  assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
  assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');
  assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
  assert(typeof Module['ENVIRONMENT'] == 'undefined', 'Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');
  assert(typeof Module['STACK_SIZE'] == 'undefined', 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time');
  // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY
  assert(typeof Module['wasmMemory'] == 'undefined', 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');
  assert(typeof Module['INITIAL_MEMORY'] == 'undefined', 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');

}

// Begin runtime exports
  var missingLibrarySymbols = [
  'writeI53ToI64',
  'writeI53ToI64Clamped',
  'writeI53ToI64Signaling',
  'writeI53ToU64Clamped',
  'writeI53ToU64Signaling',
  'readI53FromI64',
  'readI53FromU64',
  'convertI32PairToI53',
  'convertI32PairToI53Checked',
  'convertU32PairToI53',
  'stackAlloc',
  'getTempRet0',
  'setTempRet0',
  'zeroMemory',
  'withStackSave',
  'strError',
  'inetPton4',
  'inetNtop4',
  'inetPton6',
  'inetNtop6',
  'readSockaddr',
  'writeSockaddr',
  'readEmAsmArgs',
  'jstoi_q',
  'getExecutableName',
  'autoResumeAudioContext',
  'getDynCaller',
  'dynCall',
  'handleException',
  'runtimeKeepalivePush',
  'runtimeKeepalivePop',
  'callUserCallback',
  'maybeExit',
  'asmjsMangle',
  'asyncLoad',
  'mmapAlloc',
  'HandleAllocator',
  'getNativeTypeSize',
  'getUniqueRunDependency',
  'addOnInit',
  'addOnPostCtor',
  'addOnPreMain',
  'addOnExit',
  'STACK_SIZE',
  'STACK_ALIGN',
  'POINTER_SIZE',
  'ASSERTIONS',
  'ccall',
  'cwrap',
  'convertJsFunctionToWasm',
  'getEmptyTableSlot',
  'updateTableMap',
  'getFunctionAddress',
  'addFunction',
  'removeFunction',
  'intArrayFromString',
  'intArrayToString',
  'stringToAscii',
  'stringToNewUTF8',
  'stringToUTF8OnStack',
  'writeArrayToMemory',
  'registerKeyEventCallback',
  'maybeCStringToJsString',
  'findEventTarget',
  'getBoundingClientRect',
  'fillMouseEventData',
  'registerMouseEventCallback',
  'registerWheelEventCallback',
  'registerUiEventCallback',
  'registerFocusEventCallback',
  'fillDeviceOrientationEventData',
  'registerDeviceOrientationEventCallback',
  'fillDeviceMotionEventData',
  'registerDeviceMotionEventCallback',
  'screenOrientation',
  'fillOrientationChangeEventData',
  'registerOrientationChangeEventCallback',
  'fillFullscreenChangeEventData',
  'registerFullscreenChangeEventCallback',
  'JSEvents_requestFullscreen',
  'JSEvents_resizeCanvasForFullscreen',
  'registerRestoreOldStyle',
  'hideEverythingExceptGivenElement',
  'restoreHiddenElements',
  'setLetterbox',
  'softFullscreenResizeWebGLRenderTarget',
  'doRequestFullscreen',
  'fillPointerlockChangeEventData',
  'registerPointerlockChangeEventCallback',
  'registerPointerlockErrorEventCallback',
  'requestPointerLock',
  'fillVisibilityChangeEventData',
  'registerVisibilityChangeEventCallback',
  'registerTouchEventCallback',
  'fillGamepadEventData',
  'registerGamepadEventCallback',
  'registerBeforeUnloadEventCallback',
  'fillBatteryEventData',
  'registerBatteryEventCallback',
  'setCanvasElementSize',
  'getCanvasElementSize',
  'jsStackTrace',
  'getCallstack',
  'convertPCtoSourceLocation',
  'getEnvStrings',
  'checkWasiClock',
  'wasiRightsToMuslOFlags',
  'wasiOFlagsToMuslOFlags',
  'initRandomFill',
  'randomFill',
  'safeSetTimeout',
  'setImmediateWrapped',
  'safeRequestAnimationFrame',
  'clearImmediateWrapped',
  'registerPostMainLoop',
  'registerPreMainLoop',
  'getPromise',
  'makePromise',
  'idsToPromises',
  'makePromiseCallback',
  'ExceptionInfo',
  'findMatchingCatch',
  'Browser_asyncPrepareDataCounter',
  'isLeapYear',
  'ydayFromDate',
  'arraySum',
  'addDays',
  'getSocketFromFD',
  'getSocketAddress',
  'FS_createPreloadedFile',
  'FS_modeStringToFlags',
  'FS_getMode',
  'FS_stdin_getChar',
  'FS_mkdirTree',
  '_setNetworkCallback',
  'heapObjectForWebGLType',
  'toTypedArrayIndex',
  'webgl_enable_ANGLE_instanced_arrays',
  'webgl_enable_OES_vertex_array_object',
  'webgl_enable_WEBGL_draw_buffers',
  'webgl_enable_WEBGL_multi_draw',
  'webgl_enable_EXT_polygon_offset_clamp',
  'webgl_enable_EXT_clip_control',
  'webgl_enable_WEBGL_polygon_mode',
  'emscriptenWebGLGet',
  'computeUnpackAlignedImageSize',
  'colorChannelsInGlTextureFormat',
  'emscriptenWebGLGetTexPixelData',
  'emscriptenWebGLGetUniform',
  'webglGetUniformLocation',
  'webglPrepareUniformLocationsBeforeFirstUse',
  'webglGetLeftBracePos',
  'emscriptenWebGLGetVertexAttrib',
  '__glGetActiveAttribOrUniform',
  'writeGLArray',
  'registerWebGlEventCallback',
  'runAndAbortIfError',
  'ALLOC_NORMAL',
  'ALLOC_STACK',
  'allocate',
  'writeStringToMemory',
  'writeAsciiToMemory',
  'demangle',
  'stackTrace',
  'getFunctionArgsName',
  'createJsInvokerSignature',
  'PureVirtualError',
  'getBasestPointer',
  'registerInheritedInstance',
  'unregisterInheritedInstance',
  'getInheritedInstance',
  'getInheritedInstanceCount',
  'getLiveInheritedInstances',
  'enumReadValueFromPointer',
  'genericPointerToWireType',
  'constNoSmartPtrRawPointerToWireType',
  'nonConstNoSmartPtrRawPointerToWireType',
  'init_RegisteredPointer',
  'RegisteredPointer',
  'RegisteredPointer_fromWireType',
  'runDestructor',
  'releaseClassHandle',
  'detachFinalizer',
  'attachFinalizer',
  'makeClassHandle',
  'init_ClassHandle',
  'ClassHandle',
  'throwInstanceAlreadyDeleted',
  'flushPendingDeletes',
  'setDelayFunction',
  'RegisteredClass',
  'shallowCopyInternalPointer',
  'downcastPointer',
  'upcastPointer',
  'validateThis',
  'char_0',
  'char_9',
  'makeLegalFunctionName',
  'count_emval_handles',
];
missingLibrarySymbols.forEach(missingLibrarySymbol);

  var unexportedSymbols = [
  'run',
  'addRunDependency',
  'removeRunDependency',
  'out',
  'err',
  'callMain',
  'abort',
  'wasmMemory',
  'wasmExports',
  'HEAPF32',
  'HEAPF64',
  'HEAP8',
  'HEAPU8',
  'HEAP16',
  'HEAPU16',
  'HEAP32',
  'HEAPU32',
  'HEAP64',
  'HEAPU64',
  'writeStackCookie',
  'checkStackCookie',
  'INT53_MAX',
  'INT53_MIN',
  'bigintToI53Checked',
  'stackSave',
  'stackRestore',
  'ptrToString',
  'exitJS',
  'getHeapMax',
  'growMemory',
  'ENV',
  'ERRNO_CODES',
  'DNS',
  'Protocols',
  'Sockets',
  'timers',
  'warnOnce',
  'readEmAsmArgsArray',
  'keepRuntimeAlive',
  'alignMemory',
  'wasmTable',
  'noExitRuntime',
  'addOnPreRun',
  'addOnPostRun',
  'freeTableIndexes',
  'functionsInTableMap',
  'setValue',
  'getValue',
  'PATH',
  'PATH_FS',
  'UTF8Decoder',
  'UTF8ArrayToString',
  'UTF8ToString',
  'stringToUTF8Array',
  'stringToUTF8',
  'lengthBytesUTF8',
  'AsciiToString',
  'UTF16Decoder',
  'UTF16ToString',
  'stringToUTF16',
  'lengthBytesUTF16',
  'UTF32ToString',
  'stringToUTF32',
  'lengthBytesUTF32',
  'JSEvents',
  'specialHTMLTargets',
  'findCanvasEventTarget',
  'currentFullscreenStrategy',
  'restoreOldWindowedStyle',
  'UNWIND_CACHE',
  'ExitStatus',
  'flush_NO_FILESYSTEM',
  'emSetImmediate',
  'emClearImmediate_deps',
  'emClearImmediate',
  'promiseMap',
  'uncaughtExceptionCount',
  'exceptionLast',
  'exceptionCaught',
  'Browser',
  'requestFullscreen',
  'requestFullScreen',
  'setCanvasSize',
  'getUserMedia',
  'createContext',
  'getPreloadedImageData__data',
  'wget',
  'MONTH_DAYS_REGULAR',
  'MONTH_DAYS_LEAP',
  'MONTH_DAYS_REGULAR_CUMULATIVE',
  'MONTH_DAYS_LEAP_CUMULATIVE',
  'base64Decode',
  'SYSCALLS',
  'preloadPlugins',
  'FS_stdin_getChar_buffer',
  'FS_unlink',
  'FS_createPath',
  'FS_createDevice',
  'FS_readFile',
  'FS',
  'FS_root',
  'FS_mounts',
  'FS_devices',
  'FS_streams',
  'FS_nextInode',
  'FS_nameTable',
  'FS_currentPath',
  'FS_initialized',
  'FS_ignorePermissions',
  'FS_filesystems',
  'FS_syncFSRequests',
  'FS_readFiles',
  'FS_lookupPath',
  'FS_getPath',
  'FS_hashName',
  'FS_hashAddNode',
  'FS_hashRemoveNode',
  'FS_lookupNode',
  'FS_createNode',
  'FS_destroyNode',
  'FS_isRoot',
  'FS_isMountpoint',
  'FS_isFile',
  'FS_isDir',
  'FS_isLink',
  'FS_isChrdev',
  'FS_isBlkdev',
  'FS_isFIFO',
  'FS_isSocket',
  'FS_flagsToPermissionString',
  'FS_nodePermissions',
  'FS_mayLookup',
  'FS_mayCreate',
  'FS_mayDelete',
  'FS_mayOpen',
  'FS_checkOpExists',
  'FS_nextfd',
  'FS_getStreamChecked',
  'FS_getStream',
  'FS_createStream',
  'FS_closeStream',
  'FS_dupStream',
  'FS_doSetAttr',
  'FS_chrdev_stream_ops',
  'FS_major',
  'FS_minor',
  'FS_makedev',
  'FS_registerDevice',
  'FS_getDevice',
  'FS_getMounts',
  'FS_syncfs',
  'FS_mount',
  'FS_unmount',
  'FS_lookup',
  'FS_mknod',
  'FS_statfs',
  'FS_statfsStream',
  'FS_statfsNode',
  'FS_create',
  'FS_mkdir',
  'FS_mkdev',
  'FS_symlink',
  'FS_rename',
  'FS_rmdir',
  'FS_readdir',
  'FS_readlink',
  'FS_stat',
  'FS_fstat',
  'FS_lstat',
  'FS_doChmod',
  'FS_chmod',
  'FS_lchmod',
  'FS_fchmod',
  'FS_doChown',
  'FS_chown',
  'FS_lchown',
  'FS_fchown',
  'FS_doTruncate',
  'FS_truncate',
  'FS_ftruncate',
  'FS_utime',
  'FS_open',
  'FS_close',
  'FS_isClosed',
  'FS_llseek',
  'FS_read',
  'FS_write',
  'FS_mmap',
  'FS_msync',
  'FS_ioctl',
  'FS_writeFile',
  'FS_cwd',
  'FS_chdir',
  'FS_createDefaultDirectories',
  'FS_createDefaultDevices',
  'FS_createSpecialDirectories',
  'FS_createStandardStreams',
  'FS_staticInit',
  'FS_init',
  'FS_quit',
  'FS_findObject',
  'FS_analyzePath',
  'FS_createFile',
  'FS_createDataFile',
  'FS_forceLoadFile',
  'FS_createLazyFile',
  'FS_absolutePath',
  'FS_createFolder',
  'FS_createLink',
  'FS_joinPath',
  'FS_mmapAlloc',
  'FS_standardizePath',
  'MEMFS',
  'TTY',
  'PIPEFS',
  'SOCKFS',
  'tempFixedLengthArray',
  'miniTempWebGLFloatBuffers',
  'miniTempWebGLIntBuffers',
  'GL',
  'AL',
  'GLUT',
  'EGL',
  'GLEW',
  'IDBStore',
  'SDL',
  'SDL_gfx',
  'allocateUTF8',
  'allocateUTF8OnStack',
  'print',
  'printErr',
  'jstoi_s',
  'InternalError',
  'BindingError',
  'throwInternalError',
  'throwBindingError',
  'registeredTypes',
  'awaitingDependencies',
  'typeDependencies',
  'tupleRegistrations',
  'structRegistrations',
  'sharedRegisterType',
  'whenDependentTypesAreResolved',
  'getTypeName',
  'getFunctionName',
  'heap32VectorToArray',
  'requireRegisteredType',
  'usesDestructorStack',
  'checkArgCount',
  'getRequiredArgCount',
  'createJsInvoker',
  'UnboundTypeError',
  'EmValType',
  'EmValOptionalType',
  'throwUnboundTypeError',
  'ensureOverloadTable',
  'exposePublicSymbol',
  'replacePublicSymbol',
  'createNamedFunction',
  'embindRepr',
  'registeredInstances',
  'registeredPointers',
  'registerType',
  'integerReadValueFromPointer',
  'floatReadValueFromPointer',
  'assertIntegerRange',
  'readPointer',
  'runDestructors',
  'craftInvokerFunction',
  'embind__requireFunction',
  'finalizationRegistry',
  'detachFinalizer_deps',
  'deletionQueue',
  'delayFunction',
  'emval_freelist',
  'emval_handles',
  'emval_symbols',
  'getStringOrSymbol',
  'Emval',
  'emval_get_global',
  'emval_returnValue',
  'emval_lookupTypes',
  'emval_methodCallers',
  'emval_addMethodCaller',
];
unexportedSymbols.forEach(unexportedRuntimeSymbol);

  // End runtime exports
  // Begin JS library exports
  // End JS library exports

// end include: postlibrary.js

function checkIncomingModuleAPI() {
  ignoredModuleProp('fetchSettings');
}

// Imports from the Wasm binary.
var _malloc = makeInvalidEarlyAccess('_malloc');
var _free = makeInvalidEarlyAccess('_free');
var _fflush = makeInvalidEarlyAccess('_fflush');
var ___getTypeName = makeInvalidEarlyAccess('___getTypeName');
var _emscripten_stack_get_end = makeInvalidEarlyAccess('_emscripten_stack_get_end');
var _emscripten_stack_init = makeInvalidEarlyAccess('_emscripten_stack_init');

function assignWasmExports(wasmExports) {
  _malloc = createExportWrapper('malloc', 1);
  _free = createExportWrapper('free', 1);
  _fflush = createExportWrapper('fflush', 1);
  ___getTypeName = createExportWrapper('__getTypeName', 1);
  _emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'];
  wasmExports['emscripten_stack_get_base'];
  _emscripten_stack_init = wasmExports['emscripten_stack_init'];
  wasmExports['emscripten_stack_get_free'];
  wasmExports['_emscripten_stack_restore'];
  wasmExports['_emscripten_stack_alloc'];
  wasmExports['emscripten_stack_get_current'];
}
var wasmImports = {
  /** @export */
  __assert_fail: ___assert_fail,
  /** @export */
  _abort_js: __abort_js,
  /** @export */
  _embind_register_bigint: __embind_register_bigint,
  /** @export */
  _embind_register_bool: __embind_register_bool,
  /** @export */
  _embind_register_emval: __embind_register_emval,
  /** @export */
  _embind_register_float: __embind_register_float,
  /** @export */
  _embind_register_function: __embind_register_function,
  /** @export */
  _embind_register_integer: __embind_register_integer,
  /** @export */
  _embind_register_memory_view: __embind_register_memory_view,
  /** @export */
  _embind_register_std_string: __embind_register_std_string,
  /** @export */
  _embind_register_std_wstring: __embind_register_std_wstring,
  /** @export */
  _embind_register_void: __embind_register_void,
  /** @export */
  _emval_create_invoker: __emval_create_invoker,
  /** @export */
  _emval_decref: __emval_decref,
  /** @export */
  _emval_get_global: __emval_get_global,
  /** @export */
  _emval_get_property: __emval_get_property,
  /** @export */
  _emval_incref: __emval_incref,
  /** @export */
  _emval_invoke: __emval_invoke,
  /** @export */
  _emval_new_array: __emval_new_array,
  /** @export */
  _emval_new_cstring: __emval_new_cstring,
  /** @export */
  _emval_new_object: __emval_new_object,
  /** @export */
  _emval_run_destructors: __emval_run_destructors,
  /** @export */
  _emval_set_property: __emval_set_property,
  /** @export */
  _emval_typeof: __emval_typeof,
  /** @export */
  _munmap_js: __munmap_js,
  /** @export */
  emscripten_resize_heap: _emscripten_resize_heap,
  /** @export */
  exit: _exit,
  /** @export */
  fd_close: _fd_close,
  /** @export */
  fd_seek: _fd_seek,
  /** @export */
  fd_write: _fd_write
};
var wasmExports = await createWasm();


// include: postamble.js
// === Auto-generated postamble setup entry stuff ===

var calledRun;

function stackCheckInit() {
  // This is normally called automatically during __wasm_call_ctors but need to
  // get these values before even running any of the ctors so we call it redundantly
  // here.
  _emscripten_stack_init();
  // TODO(sbc): Move writeStackCookie to native to to avoid this.
  writeStackCookie();
}

function run() {

  if (runDependencies > 0) {
    dependenciesFulfilled = run;
    return;
  }

  stackCheckInit();

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    dependenciesFulfilled = run;
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    assert(!calledRun);
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    readyPromiseResolve?.(Module);
    Module['onRuntimeInitialized']?.();
    consumedModuleProp('onRuntimeInitialized');

    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(() => {
      setTimeout(() => Module['setStatus'](''), 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var oldOut = out;
  var oldErr = err;
  var has = false;
  out = err = (x) => {
    has = true;
  };
  try { // it doesn't matter if it fails
    flush_NO_FILESYSTEM();
  } catch(e) {}
  out = oldOut;
  err = oldErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');
    warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');
  }
}

function preInit() {
  if (Module['preInit']) {
    if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
    while (Module['preInit'].length > 0) {
      Module['preInit'].shift()();
    }
  }
  consumedModuleProp('preInit');
}

preInit();
run();

// end include: postamble.js

// include: postamble_modularize.js
// In MODULARIZE mode we wrap the generated code in a factory function
// and return either the Module itself, or a promise of the module.
//
// We assign to the `moduleRtn` global here and configure closure to see
// this as and extern so it won't get minified.

if (runtimeInitialized)  {
  moduleRtn = Module;
} else {
  // Set up the promise that indicates the Module is initialized
  moduleRtn = new Promise((resolve, reject) => {
    readyPromiseResolve = resolve;
    readyPromiseReject = reject;
  });
}

// Assertion for attempting to access module properties on the incoming
// moduleArg.  In the past we used this object as the prototype of the module
// and assigned properties to it, but now we return a distinct object.  This
// keeps the instance private until it is ready (i.e the promise has been
// resolved).
for (const prop of Object.keys(Module)) {
  if (!(prop in moduleArg)) {
    Object.defineProperty(moduleArg, prop, {
      configurable: true,
      get() {
        abort(`Access to module property ('${prop}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`);
      }
    });
  }
}
// end include: postamble_modularize.js



  return moduleRtn;
}

/**
 * An instance of the `Herb` class using a Node.js WASM backend.
 * This loads `libherb` in Node.js using WebAssembly (WASM).
 */
const Herb = new HerbBackendNodeWASM(Herb$1);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const dedent = createDedent({});
function createDedent(options) {
  dedent.withOptions = newOptions => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
  return dedent;
  function dedent(strings, ...values) {
    const raw = typeof strings === "string" ? [strings] : strings.raw;
    const {
      escapeSpecialCharacters = Array.isArray(strings),
      trimWhitespace = true
    } = options;

    // first, perform interpolation
    let result = "";
    for (let i = 0; i < raw.length; i++) {
      let next = raw[i];
      if (escapeSpecialCharacters) {
        // handle escaped newlines, backticks, and interpolation characters
        next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{");
      }
      result += next;
      if (i < values.length) {
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        result += values[i];
      }
    }

    // now strip indentation
    const lines = result.split("\n");
    let mindent = null;
    for (const l of lines) {
      const m = l.match(/^(\s+)\S+/);
      if (m) {
        const indent = m[1].length;
        if (!mindent) {
          // this is the first indented line
          mindent = indent;
        } else {
          mindent = Math.min(mindent, indent);
        }
      }
    }
    if (mindent !== null) {
      const m = mindent; // appease TypeScript
      result = lines
      // https://github.com/typescript-eslint/typescript-eslint/issues/7140
      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
      .map(l => l[0] === " " || l[0] === "\t" ? l.slice(m) : l).join("\n");
    }

    // dedent eats leading and trailing whitespace too
    if (trimWhitespace) {
      result = result.trim();
    }

    // handle escaped newlines at the end to ensure they don't get stripped too
    if (escapeSpecialCharacters) {
      result = result.replace(/\\n/g, "\n");
    }
    return result;
  }
}

const colors = {
    reset: "\x1b[0m",
    bold: "\x1b[1m",
    dim: "\x1b[2m",
    black: "\x1b[30m",
    red: "\x1b[31m",
    green: "\x1b[32m",
    yellow: "\x1b[33m",
    blue: "\x1b[34m",
    magenta: "\x1b[35m",
    cyan: "\x1b[36m",
    white: "\x1b[37m",
    gray: "\x1b[90m",
    brightRed: "\x1b[91m",
    brightGreen: "\x1b[92m",
    brightYellow: "\x1b[93m",
    brightBlue: "\x1b[94m",
    brightMagenta: "\x1b[95m",
    brightCyan: "\x1b[96m",
    bgBlack: "\x1b[40m",
    bgRed: "\x1b[41m",
    bgGreen: "\x1b[42m",
    bgYellow: "\x1b[43m",
    bgBlue: "\x1b[44m",
    bgMagenta: "\x1b[45m",
    bgCyan: "\x1b[46m",
    bgWhite: "\x1b[47m",
    bgGray: "\x1b[100m",
};
const hexToAnsi = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `\x1b[38;2;${r};${g};${b}m`;
};
const colorize = (text, color, backgroundColor) => {
    if (process.env.NO_COLOR === undefined) {
        let foreground;
        let background = "";
        if (typeof color === "string" && color.startsWith("#")) {
            foreground = hexToAnsi(color);
        }
        else {
            foreground = colors[color];
        }
        return `${background}${foreground}${text}${colors.reset}`;
    }
    return text;
};

function applyDimToStyledText(text) {
    const isColorEnabled = process.env.NO_COLOR === undefined;
    if (!isColorEnabled)
        return text;
    const parts = text.split(/(\x1b\[[0-9;]*m)/g);
    let result = "";
    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (part.match(/^\x1b\[[0-9;]*m$/)) {
            if (part === "\x1b[0m") {
                result += part;
            }
            else {
                const codes = part.match(/\x1b\[([0-9;]*)m/)?.[1];
                if (codes && codes !== "0" && codes !== "") {
                    result += `\x1b[2;${codes}m`;
                }
                else {
                    result += part;
                }
            }
        }
        else if (part.length > 0) {
            result += `\x1b[2m${part}\x1b[22m`;
        }
    }
    return result;
}

class LineWrapper {
    static wrapLine(line, maxWidth, indent = "") {
        if (maxWidth <= 0)
            return [line];
        const ansiRegex = /\x1b\[[0-9;]*m/g;
        const plainLine = line.replace(ansiRegex, "");
        if (plainLine.length <= maxWidth) {
            return [line];
        }
        const wrappedLines = [];
        let currentLine = line;
        let currentPlain = plainLine;
        while (currentPlain.length > maxWidth) {
            let breakPoint = maxWidth;
            // First pass: look for whitespace (ideal breaks)
            for (let i = maxWidth - 1; i >= Math.max(0, maxWidth - 40); i--) {
                const char = currentPlain[i];
                if (char === " " || char === "\t") {
                    breakPoint = i + 1;
                    break;
                }
            }
            // Second pass: if no whitespace found, look for punctuation but not within quoted strings
            if (breakPoint === maxWidth) {
                for (let i = maxWidth - 1; i >= Math.max(0, maxWidth - 30); i--) {
                    const char = currentPlain[i];
                    const prevChar = i > 0 ? currentPlain[i - 1] : "";
                    const nextChar = i < currentPlain.length - 1 ? currentPlain[i + 1] : "";
                    if ((char === ">" || char === "," || char === ";") &&
                        prevChar !== "=" && nextChar !== "\"" && nextChar !== "'") {
                        breakPoint = i + 1;
                        break;
                    }
                }
            }
            if (breakPoint === maxWidth) {
                for (let i = maxWidth - 1; i >= Math.max(0, maxWidth - 10); i--) {
                    const char = currentPlain[i];
                    if (char !== "=" && char !== "\"" && char !== "'") {
                        breakPoint = i;
                        break;
                    }
                }
            }
            const wrapPortion = this.extractPortionWithAnsi(currentLine, breakPoint);
            wrappedLines.push(wrapPortion);
            currentLine = this.extractRemainingWithAnsi(currentLine, currentPlain, breakPoint);
            currentPlain = currentPlain.slice(breakPoint).trimStart();
            if (currentPlain.length > 0) {
                currentLine = indent + currentLine.trimStart();
            }
        }
        if (currentPlain.length > 0) {
            wrappedLines.push(currentLine);
        }
        return wrappedLines;
    }
    static extractPortionWithAnsi(styledLine, endIndex) {
        let styledIndex = 0;
        let plainIndex = 0;
        let result = "";
        while (plainIndex < endIndex && styledIndex < styledLine.length) {
            const char = styledLine[styledIndex];
            if (char === "\x1b") {
                const ansiMatch = styledLine.slice(styledIndex).match(/^\x1b\[[0-9;]*m/);
                if (ansiMatch) {
                    result += ansiMatch[0];
                    styledIndex += ansiMatch[0].length;
                    continue;
                }
            }
            result += char;
            styledIndex++;
            plainIndex++;
        }
        return result;
    }
    static extractRemainingWithAnsi(styledLine, _plainLine, startIndex) {
        let styledIndex = 0;
        let plainIndex = 0;
        while (plainIndex < startIndex && styledIndex < styledLine.length) {
            const char = styledLine[styledIndex];
            if (char === "\x1b") {
                const ansiMatch = styledLine.slice(styledIndex).match(/^\x1b\[[0-9;]*m/);
                if (ansiMatch) {
                    styledIndex += ansiMatch[0].length;
                    continue;
                }
            }
            styledIndex++;
            plainIndex++;
        }
        return styledLine.slice(styledIndex);
    }
    static truncateLine(line, maxWidth) {
        if (maxWidth <= 0)
            return line;
        const ansiRegex = /\x1b\[[0-9;]*m/g;
        const plainLine = line.replace(ansiRegex, "");
        if (plainLine.length <= maxWidth) {
            return line;
        }
        const ellipsisChar = "";
        const ellipsis = colorize(ellipsisChar, "dim");
        const rightPadding = 2;
        const availableWidth = maxWidth - ellipsisChar.length - rightPadding;
        if (availableWidth <= 0) {
            return ellipsis;
        }
        const truncatedPortion = this.extractPortionWithAnsi(line, availableWidth);
        return truncatedPortion + ellipsis;
    }
    static getTerminalWidth() {
        if (process.stdout.isTTY && process.stdout.columns) {
            return process.stdout.columns;
        }
        return 80;
    }
}

/**
 * Configuration for gutter formatting in the highlighter
 */
// Calculate the gutter width based on the format: "    123  "
// - 4 spaces for indentation
// - 3 characters for line number (supports up to 999 lines)
// - 1 space after line number
// - 1 character for separator ()
// - 1 space after separator
const GUTTER_WIDTH = 4 + 3 + 1 + 1 + 1; // = 10
// Minimum content width to ensure readability
const MIN_CONTENT_WIDTH = 40;

class DiagnosticRenderer {
    syntaxRenderer;
    constructor(syntaxRenderer) {
        this.syntaxRenderer = syntaxRenderer;
    }
    highlightBackticks(text) {
        if (process.stdout.isTTY && process.env.NO_COLOR === undefined) {
            const boldWhite = "\x1b[1m\x1b[37m";
            const reset = "\x1b[0m";
            return text.replace(/`([^`]+)`/g, `${boldWhite}$1${reset}`);
        }
        return text;
    }
    truncateLineForDiagnostic(line, diagnosticStart, diagnosticEnd, maxWidth) {
        const ansiRegex = /\x1b\[[0-9;]*m/g;
        const plainLine = line.replace(ansiRegex, "");
        if (plainLine.length <= maxWidth) {
            return { line, adjustedStart: diagnosticStart, adjustedEnd: diagnosticEnd };
        }
        const ellipsisChar = "";
        const ellipsis = colorize(ellipsisChar, "dim");
        const rightPadding = 2;
        const ellipsisCharLength = ellipsisChar.length;
        const ellipsisLength = ellipsisCharLength + rightPadding;
        if (diagnosticStart < maxWidth / 3) {
            const availableWidth = maxWidth - ellipsisLength;
            const truncated = LineWrapper.truncateLine(line, availableWidth);
            return {
                line: truncated,
                adjustedStart: diagnosticStart,
                adjustedEnd: Math.min(diagnosticEnd, availableWidth)
            };
        }
        if (diagnosticStart > plainLine.length - maxWidth / 3) {
            const availableWidth = maxWidth - ellipsisLength;
            const startPos = Math.max(0, plainLine.length - availableWidth);
            const visiblePortion = this.extractPortionFromPosition(line, startPos, plainLine.length);
            const truncated = ellipsis + visiblePortion;
            return {
                line: truncated,
                adjustedStart: Math.max(0, diagnosticStart - startPos + ellipsisCharLength),
                adjustedEnd: Math.max(0, diagnosticEnd - startPos + ellipsisCharLength)
            };
        }
        const contextWidth = maxWidth - (ellipsisLength * 2);
        const contextStart = Math.max(0, diagnosticStart - contextWidth / 3);
        const contextEnd = Math.min(plainLine.length, contextStart + contextWidth);
        const visiblePortion = this.extractPortionFromPosition(line, contextStart, contextEnd);
        const truncated = ellipsis + visiblePortion + ellipsis;
        return {
            line: truncated,
            adjustedStart: diagnosticStart - contextStart + ellipsisCharLength,
            adjustedEnd: diagnosticEnd - contextStart + ellipsisCharLength
        };
    }
    extractPortionFromPosition(styledLine, startPos, endPos) {
        let styledIndex = 0;
        let plainIndex = 0;
        let result = "";
        let inRange = false;
        while (styledIndex < styledLine.length && plainIndex <= endPos) {
            const char = styledLine[styledIndex];
            if (char === "\x1b") {
                const ansiMatch = styledLine.slice(styledIndex).match(/^\x1b\[[0-9;]*m/);
                if (ansiMatch) {
                    if (inRange || plainIndex >= startPos) {
                        result += ansiMatch[0];
                    }
                    styledIndex += ansiMatch[0].length;
                    continue;
                }
            }
            if (plainIndex >= startPos && !inRange) {
                inRange = true;
            }
            if (inRange) {
                result += char;
            }
            styledIndex++;
            plainIndex++;
        }
        return result;
    }
    renderSingle(path, diagnostic, content, options = {}) {
        const { contextLines = 2, showLineNumbers: _showLineNumbers = true, optimizeHighlighting = true, wrapLines = true, maxWidth = LineWrapper.getTerminalWidth(), truncateLines = false, } = options;
        const shouldWrap = wrapLines && !truncateLines;
        const shouldTruncate = truncateLines;
        const isError = diagnostic.severity === "error";
        const fileHeader = `${colorize(path, "cyan")}:${colorize(`${diagnostic.location.start.line}:${diagnostic.location.start.column}`, "cyan")}`;
        const severityText = isError
            ? colorize("error", "brightRed")
            : colorize("warning", "brightYellow");
        const diagnosticId = colorize(diagnostic.code || "-", "gray");
        const originalLines = content.split("\n");
        const targetLineNumber = diagnostic.location.start.line;
        const column = diagnostic.location.start.column - 1;
        const startLine = Math.max(1, targetLineNumber - contextLines);
        const endLine = Math.min(originalLines.length, targetLineNumber + contextLines);
        let lines;
        let lineOffset = 0;
        if (optimizeHighlighting) {
            const relevantLines = [];
            for (let i = startLine; i <= endLine; i++) {
                relevantLines.push(originalLines[i - 1] || "");
            }
            const relevantContent = relevantLines.join("\n");
            const highlightedContent = this.syntaxRenderer.highlight(relevantContent);
            lines = highlightedContent.split("\n");
            lineOffset = startLine - 1;
        }
        else {
            const highlightedContent = this.syntaxRenderer.highlight(content);
            lines = highlightedContent.split("\n");
            lineOffset = 0;
        }
        let contextOutput = "";
        let adjustedColumn = column;
        let adjustedPointerLength = Math.max(1, diagnostic.location.end.column - diagnostic.location.start.column);
        for (let i = startLine; i <= endLine; i++) {
            const line = lines[i - 1 - lineOffset] || "";
            const isTargetLine = i === targetLineNumber;
            const lineNumber = isTargetLine
                ? colorize(i.toString().padStart(3, " "), "bold")
                : colorize(i.toString().padStart(3, " "), "gray");
            const prefix = isTargetLine
                ? colorize("   ", isError ? "brightRed" : "brightYellow")
                : "    ";
            const separator = colorize("", "gray");
            let displayLine = line;
            if (isTargetLine) {
                displayLine = line;
            }
            else {
                displayLine = applyDimToStyledText(line);
            }
            if (shouldWrap) {
                const linePrefix = `${prefix}${lineNumber} ${separator} `;
                const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const wrappedLines = LineWrapper.wrapLine(displayLine, availableWidth, "");
                for (let j = 0; j < wrappedLines.length; j++) {
                    if (j === 0) {
                        contextOutput += `${linePrefix}${wrappedLines[j]}\n`;
                    }
                    else {
                        contextOutput += `        ${separator} ${wrappedLines[j]}\n`;
                    }
                }
            }
            else if (shouldTruncate) {
                const linePrefix = `${prefix}${lineNumber} ${separator} `;
                const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                let truncatedLine;
                if (isTargetLine) {
                    const diagnosticEnd = diagnostic.location.end.column - 1;
                    const result = this.truncateLineForDiagnostic(displayLine, column, diagnosticEnd, availableWidth);
                    truncatedLine = result.line;
                    adjustedColumn = result.adjustedStart;
                    adjustedPointerLength = Math.max(1, result.adjustedEnd - result.adjustedStart);
                }
                else {
                    truncatedLine = LineWrapper.truncateLine(displayLine, availableWidth);
                }
                contextOutput += `${linePrefix}${truncatedLine}\n`;
            }
            else {
                contextOutput += `${prefix}${lineNumber} ${separator} ${displayLine}\n`;
            }
            if (isTargetLine) {
                const pointerPrefix = `        ${colorize("", "gray")}`;
                const pointerSpacing = " ".repeat(adjustedColumn + 2);
                const adjustedPointer = colorize("~".repeat(adjustedPointerLength), isError ? "brightRed" : "brightYellow");
                contextOutput += `${pointerPrefix}${pointerSpacing}${adjustedPointer}\n`;
            }
        }
        const highlightedMessage = this.highlightBackticks(diagnostic.message);
        return `[${severityText}] ${highlightedMessage} (${diagnosticId})

${fileHeader}

${contextOutput.trimEnd()}
`;
    }
}

class FileRenderer {
    syntaxRenderer;
    constructor(syntaxRenderer) {
        this.syntaxRenderer = syntaxRenderer;
    }
    renderWithLineNumbers(path, content, wrapLines = false, maxWidth = LineWrapper.getTerminalWidth(), truncateLines = false) {
        const highlightedContent = this.syntaxRenderer.highlight(content);
        const lines = highlightedContent.split("\n");
        let output = `${colorize(path, "cyan")}\n\n`;
        for (let i = 1; i <= lines.length; i++) {
            const line = lines[i - 1] || "";
            const lineNumber = colorize(i.toString().padStart(3, " "), "gray");
            const separator = colorize("", "gray");
            if (wrapLines) {
                const linePrefix = `    ${lineNumber} ${separator} `;
                const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const wrappedLines = LineWrapper.wrapLine(line, availableWidth, "");
                for (let j = 0; j < wrappedLines.length; j++) {
                    if (j === 0) {
                        output += `${linePrefix}${wrappedLines[j]}\n`;
                    }
                    else {
                        output += `        ${separator} ${wrappedLines[j]}\n`;
                    }
                }
            }
            else if (truncateLines) {
                const linePrefix = `    ${lineNumber} ${separator} `;
                const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const truncatedLine = LineWrapper.truncateLine(line, availableWidth);
                output += `${linePrefix}${truncatedLine}\n`;
            }
            else {
                output += `    ${lineNumber} ${separator} ${line}\n`;
            }
        }
        return output.trimEnd();
    }
    renderWithFocusLine(path, content, focusLine, contextLines, showLineNumbers = true, maxWidth = LineWrapper.getTerminalWidth(), wrapLines = false, truncateLines = false) {
        const highlightedContent = this.syntaxRenderer.highlight(content);
        const lines = highlightedContent.split("\n");
        const startLine = Math.max(1, focusLine - contextLines);
        const endLine = Math.min(lines.length, focusLine + contextLines);
        let output = showLineNumbers ? `${colorize(path, "cyan")}\n\n` : "";
        for (let i = startLine; i <= endLine; i++) {
            const line = lines[i - 1] || "";
            const isFocusLine = i === focusLine;
            if (showLineNumbers) {
                const lineNumber = isFocusLine
                    ? colorize(i.toString().padStart(3, " "), "bold")
                    : colorize(i.toString().padStart(3, " "), "gray");
                const prefix = isFocusLine ? colorize("   ", "cyan") : "    ";
                const separator = colorize("", "gray");
                let displayLine = line;
                if (!isFocusLine) {
                    displayLine = applyDimToStyledText(line);
                }
                if (wrapLines) {
                    const linePrefix = `${prefix}${lineNumber} ${separator} `;
                    const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                    const wrappedLines = LineWrapper.wrapLine(displayLine, availableWidth, "");
                    for (let j = 0; j < wrappedLines.length; j++) {
                        if (j === 0) {
                            output += `${linePrefix}${wrappedLines[j]}\n`;
                        }
                        else {
                            output += `        ${separator} ${wrappedLines[j]}\n`;
                        }
                    }
                }
                else if (truncateLines) {
                    const linePrefix = `${prefix}${lineNumber} ${separator} `;
                    const availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                    const truncatedLine = LineWrapper.truncateLine(displayLine, availableWidth);
                    output += `${linePrefix}${truncatedLine}\n`;
                }
                else {
                    output += `${prefix}${lineNumber} ${separator} ${displayLine}\n`;
                }
            }
            else {
                let displayLine = line;
                if (!isFocusLine) {
                    displayLine = applyDimToStyledText(line);
                }
                if (wrapLines) {
                    const wrappedLines = LineWrapper.wrapLine(displayLine, maxWidth);
                    for (const wrappedLine of wrappedLines) {
                        output += `${wrappedLine}\n`;
                    }
                }
                else if (truncateLines) {
                    const truncatedLine = LineWrapper.truncateLine(displayLine, maxWidth);
                    output += `${truncatedLine}\n`;
                }
                else {
                    output += `${displayLine}\n`;
                }
            }
        }
        return output.trimEnd();
    }
    renderPlain(content, maxWidth = LineWrapper.getTerminalWidth(), wrapLines = false, truncateLines = false) {
        const highlighted = this.syntaxRenderer.highlight(content);
        if (wrapLines) {
            const lines = highlighted.split("\n");
            const wrappedLines = [];
            for (const line of lines) {
                const wrapped = LineWrapper.wrapLine(line, maxWidth);
                wrappedLines.push(...wrapped);
            }
            return wrappedLines.join("\n");
        }
        else if (truncateLines) {
            const lines = highlighted.split("\n");
            const truncatedLines = [];
            for (const line of lines) {
                const truncated = LineWrapper.truncateLine(line, maxWidth);
                truncatedLines.push(truncated);
            }
            return truncatedLines.join("\n");
        }
        return highlighted;
    }
}

class SyntaxRenderer {
    colors;
    isColorEnabled;
    herb;
    constructor(colors, herb) {
        this.colors = colors;
        this.isColorEnabled = process.env.NO_COLOR === undefined;
        this.herb = herb || Herb;
    }
    async initialize() {
        if (this.herb.isLoaded) {
            return;
        }
        await this.herb.load();
    }
    get initialized() {
        return this.herb.isLoaded;
    }
    highlight(content) {
        if (!this.initialized || !this.herb) {
            throw new Error("SyntaxRenderer must be initialized before use. Call await initialize() first.");
        }
        const lexResult = this.herb.lex(content);
        if (lexResult.errors.length > 0) {
            return content;
        }
        const tokens = [...lexResult.value];
        return this.highlightTokens(tokens, content);
    }
    applyColor(text, color) {
        if (!this.isColorEnabled || !color)
            return text;
        return colorize(text, color);
    }
    // TODO: in the future we should leverage Prism tokens here
    highlightRubyCode(code) {
        if (!this.isColorEnabled)
            return code;
        const words = code.split(/(\s+|[^\w\s]+)/);
        const keywords = [
            "if",
            "unless",
            "else",
            "elsif",
            "end",
            "def",
            "class",
            "module",
            "return",
            "yield",
            "break",
            "next",
            "case",
            "when",
            "then",
            "while",
            "until",
            "for",
            "in",
            "do",
            "begin",
            "rescue",
            "ensure",
            "retry",
            "raise",
            "super",
            "self",
            "nil",
            "true",
            "false",
            "and",
            "or",
            "not",
        ];
        return words
            .map((word) => {
            if (keywords.includes(word)) {
                return this.applyColor(word, this.colors.RUBY_KEYWORD);
            }
            return word;
        }).join("");
    }
    highlightTokens(tokens, content) {
        if (!tokens || tokens.length === 0) {
            return content;
        }
        let highlighted = "";
        let lastEnd = 0;
        let state = {
            inTag: false,
            inQuotes: false,
            quoteChar: "",
            tagName: "",
            isClosingTag: false,
            expectingAttributeName: false,
            expectingAttributeValue: false,
            inComment: false,
        };
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            const nextToken = tokens[i + 1];
            const prevToken = tokens[i - 1];
            if (token.range.start > lastEnd) {
                highlighted += content.slice(lastEnd, token.range.start);
            }
            const tokenText = content.slice(token.range.start, token.range.end);
            this.updateState(state, token, tokenText, nextToken, prevToken);
            const color = this.getContextualColor(state, token, tokenText);
            if (token.type === "TOKEN_ERB_CONTENT") {
                const highlightedRuby = this.highlightRubyCode(tokenText);
                highlighted += highlightedRuby;
            }
            else if (color !== undefined) {
                highlighted += this.applyColor(tokenText, color);
            }
            else {
                highlighted += tokenText;
            }
            lastEnd = token.range.end;
        }
        if (lastEnd < content.length) {
            highlighted += content.slice(lastEnd);
        }
        return highlighted;
    }
    updateState(state, token, tokenText, _nextToken, _prevToken) {
        switch (token.type) {
            case "TOKEN_HTML_TAG_START":
                state.inTag = true;
                state.isClosingTag = false;
                state.expectingAttributeName = false;
                state.expectingAttributeValue = false;
                break;
            case "TOKEN_HTML_TAG_START_CLOSE":
                state.inTag = true;
                state.isClosingTag = true;
                state.expectingAttributeName = false;
                state.expectingAttributeValue = false;
                break;
            case "TOKEN_HTML_TAG_END":
            case "TOKEN_HTML_TAG_SELF_CLOSE":
                state.inTag = false;
                state.tagName = "";
                state.isClosingTag = false;
                state.expectingAttributeName = false;
                state.expectingAttributeValue = false;
                break;
            case "TOKEN_IDENTIFIER":
                if (state.inTag && !state.tagName) {
                    state.tagName = tokenText;
                    state.expectingAttributeName = !state.isClosingTag;
                }
                else if (state.inTag && state.expectingAttributeName) {
                    state.expectingAttributeName = false;
                    state.expectingAttributeValue = true;
                }
                break;
            case "TOKEN_EQUALS":
                if (state.inTag) {
                    state.expectingAttributeValue = true;
                }
                break;
            case "TOKEN_QUOTE":
                if (state.inTag) {
                    if (!state.inQuotes) {
                        state.inQuotes = true;
                        state.quoteChar = tokenText;
                    }
                    else if (tokenText === state.quoteChar) {
                        state.inQuotes = false;
                        state.quoteChar = "";
                        state.expectingAttributeName = true;
                        state.expectingAttributeValue = false;
                    }
                }
                break;
            case "TOKEN_WHITESPACE":
                if (state.inTag && !state.inQuotes && state.tagName) {
                    state.expectingAttributeName = true;
                    state.expectingAttributeValue = false;
                }
                break;
            case "TOKEN_HTML_COMMENT_START":
                state.inComment = true;
                break;
            case "TOKEN_HTML_COMMENT_END":
                state.inComment = false;
                break;
        }
    }
    getContextualColor(state, token, tokenText) {
        if (state.inComment &&
            token.type !== "TOKEN_HTML_COMMENT_START" &&
            token.type !== "TOKEN_HTML_COMMENT_END" &&
            token.type !== "TOKEN_ERB_START" &&
            token.type !== "TOKEN_ERB_CONTENT" &&
            token.type !== "TOKEN_ERB_END") {
            return this.colors.TOKEN_HTML_COMMENT_START;
        }
        switch (token.type) {
            case "TOKEN_IDENTIFIER":
                if (state.inTag && tokenText === state.tagName) {
                    return this.colors.TOKEN_HTML_TAG_START;
                }
                else if (state.inTag &&
                    state.expectingAttributeValue &&
                    !state.inQuotes) {
                    return "#D19A66";
                }
                else if (state.inTag && state.expectingAttributeName) {
                    return "#D19A66";
                }
                else if (state.inTag && state.inQuotes) {
                    return "#98C379";
                }
                break;
            case "TOKEN_QUOTE":
                if (state.inTag) {
                    return "#98C379";
                }
                break;
        }
        if (!this.colors) {
            return null;
        }
        const color = this.colors[token.type];
        return color !== undefined ? color : null;
    }
}

class InitializationManager {
    _initialized = false;
    herb;
    constructor(herb) {
        this.herb = herb;
    }
    async initialize() {
        if (this.herb) {
            await this.herb.load();
        }
        this._initialized = true;
    }
    get initialized() {
        return this._initialized;
    }
    requireInitialized() {
        if (!this._initialized) {
            throw new Error("Highlighter must be initialized before use. Call await highlighter.initialize() first.");
        }
    }
}

class TextFormatter {
    static applyDimToStyledText(text) {
        const isColorEnabled = process.env.NO_COLOR === undefined;
        if (!isColorEnabled)
            return text;
        return text.replace(/\x1b\[([0-9;]*)m/g, (match, codes) => {
            if (codes === "0" || codes === "") {
                return match;
            }
            return `\x1b[2;${codes}m`;
        });
    }
    static highlightBackticks(text) {
        if (process.stdout.isTTY && process.env.NO_COLOR === undefined) {
            const boldWhite = "\x1b[1m\x1b[37m";
            const reset = "\x1b[0m";
            return text.replace(/`([^`]+)`/g, `${boldWhite}$1${reset}`);
        }
        return text;
    }
}

class InlineDiagnosticRenderer {
    syntaxRenderer;
    constructor(syntaxRenderer) {
        this.syntaxRenderer = syntaxRenderer;
    }
    render(path, content, diagnostics, _contextLines, showLineNumbers = true, wrapLines = false, maxWidth = LineWrapper.getTerminalWidth(), truncateLines = false) {
        const highlightedContent = this.syntaxRenderer.highlight(content);
        const diagnosticsByLine = new Map();
        for (const diagnostic of diagnostics) {
            const lineNumber = diagnostic.location.start.line;
            if (!diagnosticsByLine.has(lineNumber)) {
                diagnosticsByLine.set(lineNumber, []);
            }
            diagnosticsByLine.get(lineNumber).push(diagnostic);
        }
        for (const lineDiagnostics of diagnosticsByLine.values()) {
            lineDiagnostics.sort((a, b) => {
                if (a.severity === "error" && b.severity === "warning")
                    return -1;
                if (a.severity === "warning" && b.severity === "error")
                    return 1;
                return 0;
            });
        }
        const lines = highlightedContent.split("\n");
        let output = showLineNumbers ? `${colorize(path, "cyan")}\n\n` : "";
        let previousLineHadDiagnostics = false;
        for (let i = 1; i <= lines.length; i++) {
            const line = lines[i - 1] || "";
            const lineDiagnostics = diagnosticsByLine.get(i) || [];
            const hasDiagnostics = lineDiagnostics.length > 0;
            if (hasDiagnostics && previousLineHadDiagnostics) {
                output += "\n";
            }
            const hasErrors = lineDiagnostics.some((diagnostic) => diagnostic.severity === "error");
            let displayLine = line;
            let availableWidth = maxWidth;
            if (wrapLines && showLineNumbers) {
                const lineNumber = hasDiagnostics
                    ? colorize(i.toString().padStart(3, " "), "bold")
                    : colorize(i.toString().padStart(3, " "), "gray");
                const prefix = hasDiagnostics
                    ? colorize("   ", hasErrors ? "brightRed" : "brightYellow")
                    : "    ";
                const separator = colorize("", "gray");
                const linePrefix = `${prefix}${lineNumber} ${separator} `;
                availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const wrappedLines = LineWrapper.wrapLine(displayLine, availableWidth, "");
                for (let j = 0; j < wrappedLines.length; j++) {
                    if (j === 0) {
                        output += `${linePrefix}${wrappedLines[j]}\n`;
                    }
                    else {
                        output += `        ${separator} ${wrappedLines[j]}\n`;
                    }
                }
            }
            else if (truncateLines && showLineNumbers) {
                const lineNumber = hasDiagnostics
                    ? colorize(i.toString().padStart(3, " "), "bold")
                    : colorize(i.toString().padStart(3, " "), "gray");
                const prefix = hasDiagnostics
                    ? colorize("   ", hasErrors ? "brightRed" : "brightYellow")
                    : "    ";
                const separator = colorize("", "gray");
                const linePrefix = `${prefix}${lineNumber} ${separator} `;
                availableWidth = Math.max(MIN_CONTENT_WIDTH, maxWidth - GUTTER_WIDTH);
                const truncatedLine = LineWrapper.truncateLine(displayLine, availableWidth);
                output += `${linePrefix}${truncatedLine}\n`;
            }
            else if (showLineNumbers) {
                const lineNumber = hasDiagnostics
                    ? colorize(i.toString().padStart(3, " "), "bold")
                    : colorize(i.toString().padStart(3, " "), "gray");
                const prefix = hasDiagnostics
                    ? colorize("   ", hasErrors ? "brightRed" : "brightYellow")
                    : "    ";
                const separator = colorize("", "gray");
                output += `${prefix}${lineNumber} ${separator} ${displayLine}\n`;
            }
            else if (wrapLines) {
                availableWidth = maxWidth;
                const wrappedLines = LineWrapper.wrapLine(displayLine, maxWidth);
                for (const wrappedLine of wrappedLines) {
                    output += `${wrappedLine}\n`;
                }
            }
            else if (truncateLines) {
                const truncatedLine = LineWrapper.truncateLine(displayLine, maxWidth);
                output += `${truncatedLine}\n`;
            }
            else {
                output += `${displayLine}\n`;
            }
            if (hasDiagnostics) {
                for (const diagnostic of lineDiagnostics) {
                    const column = diagnostic.location.start.column - 1;
                    const pointerLength = Math.max(1, diagnostic.location.end.column - diagnostic.location.start.column);
                    const isError = diagnostic.severity === "error";
                    if (showLineNumbers) {
                        const pointerPrefix = `        ${colorize("", "gray")}`;
                        const pointerSpacing = " ".repeat(column + 2);
                        const pointer = colorize("~".repeat(pointerLength), isError ? "brightRed" : "brightYellow");
                        output += `${pointerPrefix}${pointerSpacing}${pointer}\n`;
                        const severityText = isError
                            ? colorize("error", "brightRed")
                            : colorize("warning", "brightYellow");
                        const diagnosticId = colorize(diagnostic.code || "-", "gray");
                        const highlightedMessage = TextFormatter.highlightBackticks(diagnostic.message);
                        const diagnosticText = `[${severityText}] ${highlightedMessage} (${diagnosticId})`;
                        const dimmedDiagnosticText = TextFormatter.applyDimToStyledText(diagnosticText);
                        output += `${pointerPrefix}${pointerSpacing}${dimmedDiagnosticText}\n`;
                    }
                    else {
                        const pointerSpacing = " ".repeat(column);
                        const pointer = colorize("~".repeat(pointerLength), isError ? "brightRed" : "brightYellow");
                        output += `${pointerSpacing}${pointer}\n`;
                        const severityText = isError
                            ? colorize("error", "brightRed")
                            : colorize("warning", "brightYellow");
                        const diagnosticId = colorize(diagnostic.code || "-", "gray");
                        const highlightedMessage = TextFormatter.highlightBackticks(diagnostic.message);
                        const diagnosticText = `[${severityText}] ${highlightedMessage} (${diagnosticId})`;
                        const dimmedDiagnosticText = TextFormatter.applyDimToStyledText(diagnosticText);
                        output += `${dimmedDiagnosticText}\n`;
                    }
                }
                output += "\n";
            }
            previousLineHadDiagnostics = hasDiagnostics;
        }
        return output.trimEnd();
    }
}

class FileReader {
    highlighter;
    constructor(highlighter) {
        this.highlighter = highlighter;
    }
    highlightFromPath(filePath, options = {}) {
        this.highlighter.requireInitialized();
        try {
            const content = fs.readFileSync(filePath, "utf8");
            return this.highlighter.highlight(filePath, content, options);
        }
        catch (error) {
            throw new Error(`Failed to read file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    highlightDiagnosticFromPath(filePath, diagnostic, options = {}) {
        this.highlighter.requireInitialized();
        try {
            const content = fs.readFileSync(filePath, "utf8");
            return this.highlighter.highlightDiagnostic(filePath, diagnostic, content, options);
        }
        catch (error) {
            throw new Error(`Failed to read file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}

var TOKEN_WHITESPACE$4 = null;
var TOKEN_NBSP$4 = "#5C6370";
var TOKEN_NEWLINE$4 = null;
var TOKEN_IDENTIFIER$4 = "#ABB2BF";
var RUBY_KEYWORD$4 = "#C678DD";
var TOKEN_HTML_DOCTYPE$4 = "#61AFEF";
var TOKEN_HTML_TAG_START$4 = "#E06C75";
var TOKEN_HTML_TAG_START_CLOSE$4 = "#E06C75";
var TOKEN_HTML_TAG_END$4 = "#E06C75";
var TOKEN_HTML_TAG_SELF_CLOSE$4 = "#E06C75";
var TOKEN_HTML_COMMENT_START$4 = "#5C6370";
var TOKEN_HTML_COMMENT_END$4 = "#5C6370";
var TOKEN_ERB_START$4 = "#BE5046";
var TOKEN_ERB_CONTENT$4 = "#E5C07B";
var TOKEN_ERB_END$4 = "#BE5046";
var TOKEN_LT$4 = "#E06C75";
var TOKEN_SLASH$4 = "#E06C75";
var TOKEN_EQUALS$4 = "#56B6C2";
var TOKEN_QUOTE$4 = "#98C379";
var TOKEN_DASH$4 = "#ABB2BF";
var TOKEN_UNDERSCORE$4 = "#ABB2BF";
var TOKEN_EXCLAMATION$4 = "#C678DD";
var TOKEN_SEMICOLON$4 = "#ABB2BF";
var TOKEN_COLON$4 = "#ABB2BF";
var TOKEN_PERCENT$4 = "#BE5046";
var TOKEN_AMPERSAND$4 = "#D19A66";
var TOKEN_CHARACTER$4 = "#ABB2BF";
var TOKEN_ERROR$4 = "#E05252";
var TOKEN_EOF$4 = null;
var onedarkTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE$4,
	TOKEN_NBSP: TOKEN_NBSP$4,
	TOKEN_NEWLINE: TOKEN_NEWLINE$4,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER$4,
	RUBY_KEYWORD: RUBY_KEYWORD$4,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE$4,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START$4,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE$4,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END$4,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE$4,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START$4,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END$4,
	TOKEN_ERB_START: TOKEN_ERB_START$4,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT$4,
	TOKEN_ERB_END: TOKEN_ERB_END$4,
	TOKEN_LT: TOKEN_LT$4,
	TOKEN_SLASH: TOKEN_SLASH$4,
	TOKEN_EQUALS: TOKEN_EQUALS$4,
	TOKEN_QUOTE: TOKEN_QUOTE$4,
	TOKEN_DASH: TOKEN_DASH$4,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE$4,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION$4,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON$4,
	TOKEN_COLON: TOKEN_COLON$4,
	TOKEN_PERCENT: TOKEN_PERCENT$4,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND$4,
	TOKEN_CHARACTER: TOKEN_CHARACTER$4,
	TOKEN_ERROR: TOKEN_ERROR$4,
	TOKEN_EOF: TOKEN_EOF$4
};

var TOKEN_WHITESPACE$3 = null;
var TOKEN_NBSP$3 = "#6a737d";
var TOKEN_NEWLINE$3 = null;
var TOKEN_IDENTIFIER$3 = "#24292e";
var RUBY_KEYWORD$3 = "#d73a49";
var TOKEN_HTML_DOCTYPE$3 = "#005cc5";
var TOKEN_HTML_TAG_START$3 = "#22863a";
var TOKEN_HTML_TAG_START_CLOSE$3 = "#22863a";
var TOKEN_HTML_TAG_END$3 = "#22863a";
var TOKEN_HTML_TAG_SELF_CLOSE$3 = "#22863a";
var TOKEN_HTML_COMMENT_START$3 = "#6a737d";
var TOKEN_HTML_COMMENT_END$3 = "#6a737d";
var TOKEN_ERB_START$3 = "#e36209";
var TOKEN_ERB_CONTENT$3 = "#6f42c1";
var TOKEN_ERB_END$3 = "#e36209";
var TOKEN_LT$3 = "#22863a";
var TOKEN_SLASH$3 = "#22863a";
var TOKEN_EQUALS$3 = "#d73a49";
var TOKEN_QUOTE$3 = "#032f62";
var TOKEN_DASH$3 = "#24292e";
var TOKEN_UNDERSCORE$3 = "#24292e";
var TOKEN_EXCLAMATION$3 = "#d73a49";
var TOKEN_SEMICOLON$3 = "#24292e";
var TOKEN_COLON$3 = "#24292e";
var TOKEN_PERCENT$3 = "#e36209";
var TOKEN_AMPERSAND$3 = "#005cc5";
var TOKEN_CHARACTER$3 = "#24292e";
var TOKEN_ERROR$3 = "#cb2431";
var TOKEN_EOF$3 = null;
var githubLightTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE$3,
	TOKEN_NBSP: TOKEN_NBSP$3,
	TOKEN_NEWLINE: TOKEN_NEWLINE$3,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER$3,
	RUBY_KEYWORD: RUBY_KEYWORD$3,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE$3,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START$3,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE$3,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END$3,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE$3,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START$3,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END$3,
	TOKEN_ERB_START: TOKEN_ERB_START$3,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT$3,
	TOKEN_ERB_END: TOKEN_ERB_END$3,
	TOKEN_LT: TOKEN_LT$3,
	TOKEN_SLASH: TOKEN_SLASH$3,
	TOKEN_EQUALS: TOKEN_EQUALS$3,
	TOKEN_QUOTE: TOKEN_QUOTE$3,
	TOKEN_DASH: TOKEN_DASH$3,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE$3,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION$3,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON$3,
	TOKEN_COLON: TOKEN_COLON$3,
	TOKEN_PERCENT: TOKEN_PERCENT$3,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND$3,
	TOKEN_CHARACTER: TOKEN_CHARACTER$3,
	TOKEN_ERROR: TOKEN_ERROR$3,
	TOKEN_EOF: TOKEN_EOF$3
};

var TOKEN_WHITESPACE$2 = null;
var TOKEN_NBSP$2 = "#6272a4";
var TOKEN_NEWLINE$2 = null;
var TOKEN_IDENTIFIER$2 = "#f8f8f2";
var RUBY_KEYWORD$2 = "#ff79c6";
var TOKEN_HTML_DOCTYPE$2 = "#8be9fd";
var TOKEN_HTML_TAG_START$2 = "#50fa7b";
var TOKEN_HTML_TAG_START_CLOSE$2 = "#50fa7b";
var TOKEN_HTML_TAG_END$2 = "#50fa7b";
var TOKEN_HTML_TAG_SELF_CLOSE$2 = "#50fa7b";
var TOKEN_HTML_COMMENT_START$2 = "#6272a4";
var TOKEN_HTML_COMMENT_END$2 = "#6272a4";
var TOKEN_ERB_START$2 = "#ffb86c";
var TOKEN_ERB_CONTENT$2 = "#bd93f9";
var TOKEN_ERB_END$2 = "#ffb86c";
var TOKEN_LT$2 = "#50fa7b";
var TOKEN_SLASH$2 = "#50fa7b";
var TOKEN_EQUALS$2 = "#ff79c6";
var TOKEN_QUOTE$2 = "#f1fa8c";
var TOKEN_DASH$2 = "#f8f8f2";
var TOKEN_UNDERSCORE$2 = "#f8f8f2";
var TOKEN_EXCLAMATION$2 = "#ff79c6";
var TOKEN_SEMICOLON$2 = "#f8f8f2";
var TOKEN_COLON$2 = "#f8f8f2";
var TOKEN_PERCENT$2 = "#ffb86c";
var TOKEN_AMPERSAND$2 = "#8be9fd";
var TOKEN_CHARACTER$2 = "#f8f8f2";
var TOKEN_ERROR$2 = "#ff5555";
var TOKEN_EOF$2 = null;
var draculaTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE$2,
	TOKEN_NBSP: TOKEN_NBSP$2,
	TOKEN_NEWLINE: TOKEN_NEWLINE$2,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER$2,
	RUBY_KEYWORD: RUBY_KEYWORD$2,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE$2,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START$2,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE$2,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END$2,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE$2,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START$2,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END$2,
	TOKEN_ERB_START: TOKEN_ERB_START$2,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT$2,
	TOKEN_ERB_END: TOKEN_ERB_END$2,
	TOKEN_LT: TOKEN_LT$2,
	TOKEN_SLASH: TOKEN_SLASH$2,
	TOKEN_EQUALS: TOKEN_EQUALS$2,
	TOKEN_QUOTE: TOKEN_QUOTE$2,
	TOKEN_DASH: TOKEN_DASH$2,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE$2,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION$2,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON$2,
	TOKEN_COLON: TOKEN_COLON$2,
	TOKEN_PERCENT: TOKEN_PERCENT$2,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND$2,
	TOKEN_CHARACTER: TOKEN_CHARACTER$2,
	TOKEN_ERROR: TOKEN_ERROR$2,
	TOKEN_EOF: TOKEN_EOF$2
};

var TOKEN_WHITESPACE$1 = null;
var TOKEN_NBSP$1 = "#646e9c";
var TOKEN_NEWLINE$1 = null;
var TOKEN_IDENTIFIER$1 = "#c0caf5";
var RUBY_KEYWORD$1 = "#bb9af7";
var TOKEN_HTML_DOCTYPE$1 = "#7aa2f7";
var TOKEN_HTML_TAG_START$1 = "#f7768e";
var TOKEN_HTML_TAG_START_CLOSE$1 = "#f7768e";
var TOKEN_HTML_TAG_END$1 = "#f7768e";
var TOKEN_HTML_TAG_SELF_CLOSE$1 = "#f7768e";
var TOKEN_HTML_COMMENT_START$1 = "#51597d";
var TOKEN_HTML_COMMENT_END$1 = "#51597d";
var TOKEN_ERB_START$1 = "#7dcfff";
var TOKEN_ERB_CONTENT$1 = "#bb9af7";
var TOKEN_ERB_END$1 = "#7dcfff";
var TOKEN_LT$1 = "#f7768e";
var TOKEN_SLASH$1 = "#f7768e";
var TOKEN_EQUALS$1 = "#89ddff";
var TOKEN_QUOTE$1 = "#9ece6a";
var TOKEN_DASH$1 = "#c0caf5";
var TOKEN_UNDERSCORE$1 = "#c0caf5";
var TOKEN_EXCLAMATION$1 = "#bb9af7";
var TOKEN_SEMICOLON$1 = "#c0caf5";
var TOKEN_COLON$1 = "#c0caf5";
var TOKEN_PERCENT$1 = "#7dcfff";
var TOKEN_AMPERSAND$1 = "#e0af68";
var TOKEN_CHARACTER$1 = "#c0caf5";
var TOKEN_ERROR$1 = "#f7768e";
var TOKEN_EOF$1 = null;
var tokyoNightTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE$1,
	TOKEN_NBSP: TOKEN_NBSP$1,
	TOKEN_NEWLINE: TOKEN_NEWLINE$1,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER$1,
	RUBY_KEYWORD: RUBY_KEYWORD$1,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE$1,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START$1,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE$1,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END$1,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE$1,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START$1,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END$1,
	TOKEN_ERB_START: TOKEN_ERB_START$1,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT$1,
	TOKEN_ERB_END: TOKEN_ERB_END$1,
	TOKEN_LT: TOKEN_LT$1,
	TOKEN_SLASH: TOKEN_SLASH$1,
	TOKEN_EQUALS: TOKEN_EQUALS$1,
	TOKEN_QUOTE: TOKEN_QUOTE$1,
	TOKEN_DASH: TOKEN_DASH$1,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE$1,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION$1,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON$1,
	TOKEN_COLON: TOKEN_COLON$1,
	TOKEN_PERCENT: TOKEN_PERCENT$1,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND$1,
	TOKEN_CHARACTER: TOKEN_CHARACTER$1,
	TOKEN_ERROR: TOKEN_ERROR$1,
	TOKEN_EOF: TOKEN_EOF$1
};

var TOKEN_WHITESPACE = null;
var TOKEN_NBSP = "gray";
var TOKEN_NEWLINE = null;
var TOKEN_IDENTIFIER = "white";
var RUBY_KEYWORD = "magenta";
var TOKEN_HTML_DOCTYPE = "blue";
var TOKEN_HTML_TAG_START = "red";
var TOKEN_HTML_TAG_START_CLOSE = "red";
var TOKEN_HTML_TAG_END = "red";
var TOKEN_HTML_TAG_SELF_CLOSE = "red";
var TOKEN_HTML_COMMENT_START = "gray";
var TOKEN_HTML_COMMENT_END = "gray";
var TOKEN_ERB_START = "yellow";
var TOKEN_ERB_CONTENT = "magenta";
var TOKEN_ERB_END = "yellow";
var TOKEN_LT = "red";
var TOKEN_SLASH = "red";
var TOKEN_EQUALS = "blue";
var TOKEN_QUOTE = "green";
var TOKEN_DASH = "white";
var TOKEN_UNDERSCORE = "white";
var TOKEN_EXCLAMATION = "magenta";
var TOKEN_SEMICOLON = "white";
var TOKEN_COLON = "white";
var TOKEN_PERCENT = "yellow";
var TOKEN_AMPERSAND = "yellow";
var TOKEN_CHARACTER = "white";
var TOKEN_ERROR = "red";
var TOKEN_EOF = null;
var simpleTheme = {
	TOKEN_WHITESPACE: TOKEN_WHITESPACE,
	TOKEN_NBSP: TOKEN_NBSP,
	TOKEN_NEWLINE: TOKEN_NEWLINE,
	TOKEN_IDENTIFIER: TOKEN_IDENTIFIER,
	RUBY_KEYWORD: RUBY_KEYWORD,
	TOKEN_HTML_DOCTYPE: TOKEN_HTML_DOCTYPE,
	TOKEN_HTML_TAG_START: TOKEN_HTML_TAG_START,
	TOKEN_HTML_TAG_START_CLOSE: TOKEN_HTML_TAG_START_CLOSE,
	TOKEN_HTML_TAG_END: TOKEN_HTML_TAG_END,
	TOKEN_HTML_TAG_SELF_CLOSE: TOKEN_HTML_TAG_SELF_CLOSE,
	TOKEN_HTML_COMMENT_START: TOKEN_HTML_COMMENT_START,
	TOKEN_HTML_COMMENT_END: TOKEN_HTML_COMMENT_END,
	TOKEN_ERB_START: TOKEN_ERB_START,
	TOKEN_ERB_CONTENT: TOKEN_ERB_CONTENT,
	TOKEN_ERB_END: TOKEN_ERB_END,
	TOKEN_LT: TOKEN_LT,
	TOKEN_SLASH: TOKEN_SLASH,
	TOKEN_EQUALS: TOKEN_EQUALS,
	TOKEN_QUOTE: TOKEN_QUOTE,
	TOKEN_DASH: TOKEN_DASH,
	TOKEN_UNDERSCORE: TOKEN_UNDERSCORE,
	TOKEN_EXCLAMATION: TOKEN_EXCLAMATION,
	TOKEN_SEMICOLON: TOKEN_SEMICOLON,
	TOKEN_COLON: TOKEN_COLON,
	TOKEN_PERCENT: TOKEN_PERCENT,
	TOKEN_AMPERSAND: TOKEN_AMPERSAND,
	TOKEN_CHARACTER: TOKEN_CHARACTER,
	TOKEN_ERROR: TOKEN_ERROR,
	TOKEN_EOF: TOKEN_EOF
};

const THEME_NAMES = ["onedark", "github-light", "dracula", "tokyo-night", "simple"];
const DEFAULT_THEME = "onedark";
// Built-in themes are now bundled directly
const themes = {
    onedark: onedarkTheme,
    "github-light": githubLightTheme,
    dracula: draculaTheme,
    "tokyo-night": tokyoNightTheme,
    simple: simpleTheme
};
function isValidTheme(theme) {
    return THEME_NAMES.includes(theme);
}
function getTheme(theme) {
    return themes[theme];
}
function loadCustomTheme(themePath) {
    try {
        const absolutePath = path$1.resolve(themePath);
        const themeContent = fs.readFileSync(absolutePath, 'utf-8');
        const customTheme = JSON.parse(themeContent);
        const requiredKeys = Object.keys(themes.onedark);
        const customKeys = Object.keys(customTheme);
        const missingKeys = requiredKeys.filter(key => !customKeys.includes(key));
        if (missingKeys.length > 0) {
            throw new Error(`Custom theme is missing required properties: ${missingKeys.join(', ')}`);
        }
        return customTheme;
    }
    catch (error) {
        if (error instanceof Error) {
            throw new Error(`Failed to load custom theme from ${themePath}: ${error.message}`);
        }
        throw new Error(`Failed to load custom theme from ${themePath}`);
    }
}
function resolveTheme(themeInput) {
    if (isValidTheme(themeInput)) {
        return getTheme(themeInput);
    }
    return loadCustomTheme(themeInput);
}

class Highlighter {
    syntaxRenderer;
    diagnosticRenderer;
    fileRenderer;
    initManager;
    inlineDiagnosticRenderer;
    fileReader;
    constructor(theme = "onedark", herb) {
        const colors = resolveTheme(theme);
        this.syntaxRenderer = new SyntaxRenderer(colors, herb);
        this.diagnosticRenderer = new DiagnosticRenderer(this.syntaxRenderer);
        this.fileRenderer = new FileRenderer(this.syntaxRenderer);
        this.initManager = new InitializationManager(herb);
        this.inlineDiagnosticRenderer = new InlineDiagnosticRenderer(this.syntaxRenderer);
        this.fileReader = new FileReader(this);
    }
    /**
     * Initialize the highlighter with the Herb backend
     * This must be called before using highlight() or highlightDiagnostic()
     */
    async initialize() {
        await this.initManager.initialize();
        await this.syntaxRenderer.initialize();
    }
    /**
     * Check if the highlighter has been initialized
     */
    get initialized() {
        return this.initManager.initialized;
    }
    requireInitialized() {
        this.initManager.requireInitialized();
    }
    /**
     * Main highlighting method with flexible rendering options
     * @param path - File path for annotation (display only, not used for reading)
     * @param content - The content to highlight
     * @param options - Configuration options
     *   - diagnostics: Array of diagnostics to display inline or split
     *   - splitDiagnostics: When true with diagnostics, render each diagnostic individually
     *   - contextLines: Number of context lines around focus/diagnostics
     *   - focusLine: Line number to focus on (shows only that line with dimmed context)
     *   - showLineNumbers: Whether to show line numbers (default: true)
     * @returns The highlighted content with optional diagnostics or focused view
     */
    highlight(path, content, options = {}) {
        this.requireInitialized();
        const { diagnostics = [], splitDiagnostics = false, contextLines = 0, focusLine, showLineNumbers = true, wrapLines = true, maxWidth = LineWrapper.getTerminalWidth(), truncateLines = false, } = options;
        // Case 1: Split diagnostics - render each diagnostic individually
        if (diagnostics.length > 0 && splitDiagnostics) {
            const results = [];
            for (let i = 0; i < diagnostics.length; i++) {
                const diagnostic = diagnostics[i];
                const result = this.highlightDiagnostic(path, diagnostic, content, {
                    contextLines,
                    showLineNumbers,
                    wrapLines,
                    maxWidth,
                    truncateLines,
                });
                results.push(result);
                if (i < diagnostics.length - 1) {
                    const width = LineWrapper.getTerminalWidth();
                    const progressText = `[${i + 1}/${diagnostics.length}]`;
                    const rightPadding = 16;
                    const separatorLength = Math.max(0, width - progressText.length - 1 - rightPadding);
                    const separator = '';
                    const leftSeparator = separator.repeat(separatorLength);
                    const rightSeparator = separator.repeat(4);
                    const progress = progressText;
                    results.push(`${leftSeparator}  ${progress} ${rightSeparator}`);
                }
            }
            return results.join("\n\n");
        }
        // Case 2: Inline diagnostics - show whole file with diagnostics inline
        if (diagnostics.length > 0) {
            return this.inlineDiagnosticRenderer.render(path, content, diagnostics, contextLines, showLineNumbers, wrapLines, maxWidth, truncateLines);
        }
        // Case 3: Focus line - show only specific line with context
        if (focusLine) {
            return this.fileRenderer.renderWithFocusLine(path, content, focusLine, contextLines, showLineNumbers, maxWidth, wrapLines, truncateLines);
        }
        // Case 4: Default - just highlight the whole file
        if (showLineNumbers) {
            return this.fileRenderer.renderWithLineNumbers(path, content, wrapLines, maxWidth, truncateLines);
        }
        else {
            return this.fileRenderer.renderPlain(content, maxWidth, wrapLines, truncateLines);
        }
    }
    /**
     * Render a single diagnostic with context lines and syntax highlighting
     * @param path - The file path to display in the diagnostic (display only)
     * @param diagnostic - The diagnostic message to render
     * @param content - The content to highlight and render
     * @param options - Optional configuration
     * @returns The rendered diagnostic output with syntax highlighting
     */
    highlightDiagnostic(path, diagnostic, content, options = {}) {
        this.requireInitialized();
        return this.diagnosticRenderer.renderSingle(path, diagnostic, content, options);
    }
    // File reading wrapper functions
    /**
     * Convenience method that reads a file and highlights it
     * @param filePath - Path to the file to read and highlight
     * @param options - Configuration options
     * @returns The highlighted file content with optional diagnostics
     */
    highlightFileFromPath(filePath, options = {}) {
        return this.fileReader.highlightFromPath(filePath, options);
    }
    /**
     * Convenience method that reads a file and renders a diagnostic
     * @param filePath - Path to the file to read
     * @param diagnostic - The diagnostic message to render
     * @param options - Optional configuration
     * @returns The highlighted diagnostic output
     */
    highlightDiagnosticFromPath(filePath, diagnostic, options = {}) {
        return this.fileReader.highlightDiagnosticFromPath(filePath, diagnostic, options);
    }
}

var name = "@herb-tools/linter";
var version = "0.7.5";
var dependencies = {
	"@herb-tools/printer": "0.7.5"};

class ArgumentParser {
    usage = dedent `
    Usage: herb-lint [file|glob-pattern|directory] [options]

    Arguments:
      file             Single file to lint
      glob-pattern     Files to lint (defaults to **/*.html.erb)
      directory        Directory to lint (automatically appends **/*.html.erb)

    Options:
      -h, --help       show help
      -v, --version    show version
      --format         output format (simple|detailed|json) [default: detailed]
      --simple         use simple output format (shortcut for --format simple)
      --json           use JSON output format (shortcut for --format json)
      --github         enable GitHub Actions annotations (combines with --format)
      --no-github      disable GitHub Actions annotations (even in GitHub Actions environment)
      --theme          syntax highlighting theme (${THEME_NAMES.join("|")}) or path to custom theme file [default: ${DEFAULT_THEME}]
      --no-color       disable colored output
      --no-timing      hide timing information
      --no-wrap-lines  disable line wrapping
      --truncate-lines enable line truncation (mutually exclusive with line wrapping)
  `;
    parse(argv) {
        const { values, positionals } = util.parseArgs({
            args: argv.slice(2),
            options: {
                help: { type: "boolean", short: "h" },
                version: { type: "boolean", short: "v" },
                format: { type: "string" },
                simple: { type: "boolean" },
                json: { type: "boolean" },
                github: { type: "boolean" },
                "no-github": { type: "boolean" },
                theme: { type: "string" },
                "no-color": { type: "boolean" },
                "no-timing": { type: "boolean" },
                "no-wrap-lines": { type: "boolean" },
                "truncate-lines": { type: "boolean" }
            },
            allowPositionals: true
        });
        if (values.help) {
            console.log(this.usage);
            process.exit(0);
        }
        if (values.version) {
            console.log("Versions:");
            console.log(`  ${name}@${version}`);
            console.log(`  @herb-tools/printer@${dependencies["@herb-tools/printer"]}`);
            console.log(`  ${Herb.version}`.split(", ").join("\n  "));
            process.exit(0);
        }
        const isGitHubActions = process.env.GITHUB_ACTIONS === "true";
        let formatOption = "detailed";
        if (values.format && (values.format === "detailed" || values.format === "simple" || values.format === "json")) {
            formatOption = values.format;
        }
        if (values.simple) {
            formatOption = "simple";
        }
        if (values.json) {
            formatOption = "json";
        }
        const useGitHubActions = (values.github || isGitHubActions) && !values["no-github"];
        if (useGitHubActions && formatOption === "json") {
            console.error("Error: --github cannot be used with --json format. JSON format is already structured for programmatic consumption.");
            process.exit(1);
        }
        if (values["no-color"]) {
            process.env.NO_COLOR = "1";
        }
        const showTiming = !values["no-timing"];
        let wrapLines = !values["no-wrap-lines"];
        let truncateLines = false;
        if (values["truncate-lines"]) {
            truncateLines = true;
            wrapLines = false;
        }
        if (!values["no-wrap-lines"] && values["truncate-lines"]) {
            console.error("Error: Line wrapping and --truncate-lines cannot be used together. Use --no-wrap-lines with --truncate-lines.");
            process.exit(1);
        }
        const theme = values.theme || DEFAULT_THEME;
        const pattern = this.getFilePattern(positionals);
        return { pattern, formatOption, showTiming, theme, wrapLines, truncateLines, useGitHubActions };
    }
    getFilePattern(positionals) {
        let pattern = positionals.length > 0 ? positionals[0] : "**/*.html.erb";
        try {
            const stat = fs.statSync(pattern);
            if (stat.isDirectory()) {
                pattern = path$1.join(pattern, "**/*.html.erb");
            }
        }
        catch {
            // Not a file/directory, treat as glob pattern
        }
        return pattern;
    }
}

class Position {
    line;
    column;
    static from(position) {
        return new Position(position.line, position.column);
    }
    constructor(line, column) {
        this.line = line;
        this.column = column;
    }
    toHash() {
        return { line: this.line, column: this.column };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `(${this.line}:${this.column})`;
    }
    inspect() {
        return `#<Herb::Position ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Location {
    start;
    end;
    static from(location) {
        const start = Position.from(location.start);
        const end = Position.from(location.end);
        return new Location(start, end);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toHash() {
        return {
            start: this.start.toHash(),
            end: this.end.toHash(),
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `${this.start.treeInspect()}-${this.end.treeInspect()}`;
    }
    treeInspectWithLabel() {
        return `(location: ${this.treeInspect()})`;
    }
    inspect() {
        return `#<Herb::Location ${this.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Range {
    start;
    end;
    static from(range) {
        return new Range(range[0], range[1]);
    }
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    toArray() {
        return [this.start, this.end];
    }
    toJSON() {
        return this.toArray();
    }
    treeInspect() {
        return `[${this.start}, ${this.end}]`;
    }
    inspect() {
        return `#<Herb::Range ${this.toArray()}>`;
    }
    toString() {
        return this.inspect();
    }
}

class Token {
    value;
    range;
    location;
    type;
    static from(token) {
        return new Token(token.value, Range.from(token.range), Location.from(token.location), token.type);
    }
    constructor(value, range, location, type) {
        this.value = value;
        this.range = range;
        this.location = location;
        this.type = type;
    }
    toHash() {
        return {
            value: this.value,
            range: this.range?.toArray(),
            location: this.location?.toHash(),
            type: this.type,
        };
    }
    toJSON() {
        return this.toHash();
    }
    treeInspect() {
        return `"${this.value}" ${this.location.treeInspectWithLabel()}`;
    }
    valueInspect() {
        return this.type === "TOKEN_EOF"
            ? JSON.stringify("<EOF>")
            : JSON.stringify(this.value);
    }
    inspect() {
        return `#<Herb::Token type="${this.type}" value=${this.valueInspect()} range=${this.range.treeInspect()} start=${this.location.start.treeInspect()} end=${this.location.end.treeInspect()}>`;
    }
    toString() {
        return this.inspect();
    }
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.7.5/templates/javascript/packages/core/src/errors.ts.erb
class HerbError {
    type;
    message;
    location;
    severity = "error";
    source = "parser";
    get code() {
        return this.type;
    }
    static from(error) {
        return fromSerializedError(error);
    }
    constructor(type, message, location) {
        this.type = type;
        this.message = message;
        this.location = location;
    }
    toJSON() {
        return {
            type: this.type,
            message: this.message,
            location: this.location.toJSON(),
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
}
class UnexpectedError extends HerbError {
    description;
    expected;
    found;
    static from(data) {
        return new UnexpectedError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            description: data.description,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.description = props.description;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_ERROR",
            description: this.description,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` description: ${JSON.stringify(this.description)}\n`;
        output += ` expected: ${JSON.stringify(this.expected)}\n`;
        output += ` found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
}
class UnexpectedTokenError extends HerbError {
    expected_type;
    found;
    static from(data) {
        return new UnexpectedTokenError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            expected_type: data.expected_type,
            found: data.found ? Token.from(data.found) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.expected_type = props.expected_type;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNEXPECTED_TOKEN_ERROR",
            expected_type: this.expected_type,
            found: this.found ? this.found.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnexpectedTokenError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` expected_type: ${JSON.stringify(this.expected_type)}\n`;
        output += ` found: ${this.found ? this.found.treeInspect() : ""}\n`;
        return output;
    }
}
class MissingOpeningTagError extends HerbError {
    closing_tag;
    static from(data) {
        return new MissingOpeningTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_OPENING_TAG_ERROR",
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingOpeningTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : ""}\n`;
        return output;
    }
}
class MissingClosingTagError extends HerbError {
    opening_tag;
    static from(data) {
        return new MissingClosingTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "MISSING_CLOSING_TAG_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ MissingClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : ""}\n`;
        return output;
    }
}
class TagNamesMismatchError extends HerbError {
    opening_tag;
    closing_tag;
    static from(data) {
        return new TagNamesMismatchError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
            closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
        this.closing_tag = props.closing_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "TAG_NAMES_MISMATCH_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
            closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ TagNamesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : ""}\n`;
        output += ` closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : ""}\n`;
        return output;
    }
}
class QuotesMismatchError extends HerbError {
    opening_quote;
    closing_quote;
    static from(data) {
        return new QuotesMismatchError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_quote: data.opening_quote ? Token.from(data.opening_quote) : null,
            closing_quote: data.closing_quote ? Token.from(data.closing_quote) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_quote = props.opening_quote;
        this.closing_quote = props.closing_quote;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "QUOTES_MISMATCH_ERROR",
            opening_quote: this.opening_quote ? this.opening_quote.toJSON() : null,
            closing_quote: this.closing_quote ? this.closing_quote.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ QuotesMismatchError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_quote: ${this.opening_quote ? this.opening_quote.treeInspect() : ""}\n`;
        output += ` closing_quote: ${this.closing_quote ? this.closing_quote.treeInspect() : ""}\n`;
        return output;
    }
}
class VoidElementClosingTagError extends HerbError {
    tag_name;
    expected;
    found;
    static from(data) {
        return new VoidElementClosingTagError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            expected: data.expected,
            found: data.found,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.tag_name = props.tag_name;
        this.expected = props.expected;
        this.found = props.found;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "VOID_ELEMENT_CLOSING_TAG_ERROR",
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            expected: this.expected,
            found: this.found,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ VoidElementClosingTagError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` expected: ${JSON.stringify(this.expected)}\n`;
        output += ` found: ${JSON.stringify(this.found)}\n`;
        return output;
    }
}
class UnclosedElementError extends HerbError {
    opening_tag;
    static from(data) {
        return new UnclosedElementError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.opening_tag = props.opening_tag;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "UNCLOSED_ELEMENT_ERROR",
            opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ UnclosedElementError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : ""}\n`;
        return output;
    }
}
class RubyParseError extends HerbError {
    error_message;
    diagnostic_id;
    level;
    static from(data) {
        return new RubyParseError({
            type: data.type,
            message: data.message,
            location: Location.from(data.location),
            error_message: data.error_message,
            diagnostic_id: data.diagnostic_id,
            level: data.level,
        });
    }
    constructor(props) {
        super(props.type, props.message, props.location);
        this.error_message = props.error_message;
        this.diagnostic_id = props.diagnostic_id;
        this.level = props.level;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "RUBY_PARSE_ERROR",
            error_message: this.error_message,
            diagnostic_id: this.diagnostic_id,
            level: this.level,
        };
    }
    toMonacoDiagnostic() {
        return {
            line: this.location.start.line,
            column: this.location.start.column,
            endLine: this.location.end.line,
            endColumn: this.location.end.column,
            message: this.message,
            severity: 'error'
        };
    }
    treeInspect() {
        let output = "";
        output += `@ RubyParseError ${this.location.treeInspectWithLabel()}\n`;
        output += ` message: "${this.message}"\n`;
        output += ` error_message: ${JSON.stringify(this.error_message)}\n`;
        output += ` diagnostic_id: ${JSON.stringify(this.diagnostic_id)}\n`;
        output += ` level: ${JSON.stringify(this.level)}\n`;
        return output;
    }
}
function fromSerializedError(error) {
    switch (error.type) {
        case "UNEXPECTED_ERROR": return UnexpectedError.from(error);
        case "UNEXPECTED_TOKEN_ERROR": return UnexpectedTokenError.from(error);
        case "MISSING_OPENING_TAG_ERROR": return MissingOpeningTagError.from(error);
        case "MISSING_CLOSING_TAG_ERROR": return MissingClosingTagError.from(error);
        case "TAG_NAMES_MISMATCH_ERROR": return TagNamesMismatchError.from(error);
        case "QUOTES_MISMATCH_ERROR": return QuotesMismatchError.from(error);
        case "VOID_ELEMENT_CLOSING_TAG_ERROR": return VoidElementClosingTagError.from(error);
        case "UNCLOSED_ELEMENT_ERROR": return UnclosedElementError.from(error);
        case "RUBY_PARSE_ERROR": return RubyParseError.from(error);
        default:
            throw new Error(`Unknown node type: ${error.type}`);
    }
}
function convertToUTF8(string) {
    const bytes = [];
    for (let i = 0; i < string.length; i++) {
        bytes.push(string.charCodeAt(i));
    }
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(new Uint8Array(bytes));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.7.5/templates/javascript/packages/core/src/nodes.ts.erb
class Node {
    type;
    location;
    errors;
    static from(node) {
        return fromSerializedNode(node);
    }
    static get type() {
        throw new Error("AST_NODE");
    }
    constructor(type, location, errors) {
        this.type = type;
        this.location = location;
        this.errors = errors;
    }
    toJSON() {
        return {
            type: this.type,
            location: this.location.toJSON(),
            errors: this.errors,
        };
    }
    inspect() {
        return this.treeInspect(0);
    }
    is(nodeClass) {
        return this.type === nodeClass.type;
    }
    isOfType(type) {
        return this.type === type;
    }
    get isSingleLine() {
        return this.location.start.line === this.location.end.line;
    }
    inspectArray(array, prefix) {
        if (!array)
            return "\n";
        if (array.length === 0)
            return "[]\n";
        let output = `(${array.length} item${array.length === 1 ? "" : "s"})\n`;
        array.forEach((item, index) => {
            const isLast = index === array.length - 1;
            if (item instanceof Node || item instanceof HerbError) {
                output += this.inspectNode(item, prefix, isLast ? "    " : "   ", isLast, false);
            }
            else {
                const symbol = isLast ? " " : " ";
                output += `${prefix}${symbol} ${item}\n`;
            }
        });
        output += `${prefix}\n`;
        return output;
    }
    inspectNode(node, prefix, prefix2 = "    ", last = true, trailingNewline = true) {
        if (!node)
            return "\n";
        let output = trailingNewline ? "\n" : "";
        output += `${prefix}`;
        output += last ? " " : " ";
        output += node
            .treeInspect()
            .trimStart()
            .split("\n")
            .map((line, index) => index === 0 ? line.trimStart() : `${prefix}${prefix2}${line}`)
            .join("\n")
            .trimStart();
        output += `\n`;
        return output;
    }
}
class DocumentNode extends Node {
    children;
    static get type() {
        return "AST_DOCUMENT_NODE";
    }
    static from(data) {
        return new DocumentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            children: (data.children || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitDocumentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_DOCUMENT_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ DocumentNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
}
class LiteralNode extends Node {
    content;
    static get type() {
        return "AST_LITERAL_NODE";
    }
    static from(data) {
        return new LiteralNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8(props.content);
    }
    accept(visitor) {
        visitor.visitLiteralNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_LITERAL_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ LiteralNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` content: ${this.content ? JSON.stringify(this.content) : ""}\n`;
        return output;
    }
}
class HTMLOpenTagNode extends Node {
    tag_opening;
    tag_name;
    tag_closing;
    children;
    is_void;
    static get type() {
        return "AST_HTML_OPEN_TAG_NODE";
    }
    static from(data) {
        return new HTMLOpenTagNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            is_void: data.is_void,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.is_void = props.is_void;
    }
    accept(visitor) {
        visitor.visitHTMLOpenTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_OPEN_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            is_void: this.is_void,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLOpenTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : ""}\n`;
        return output;
    }
}
class HTMLCloseTagNode extends Node {
    tag_opening;
    tag_name;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_CLOSE_TAG_NODE";
    }
    static from(data) {
        return new HTMLCloseTagNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.tag_name = props.tag_name;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLCloseTagNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_CLOSE_TAG_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCloseTagNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
}
class HTMLElementNode extends Node {
    open_tag;
    tag_name;
    body;
    close_tag;
    is_void;
    source;
    static get type() {
        return "AST_HTML_ELEMENT_NODE";
    }
    static from(data) {
        return new HTMLElementNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            open_tag: data.open_tag ? fromSerializedNode((data.open_tag)) : null,
            tag_name: data.tag_name ? Token.from(data.tag_name) : null,
            body: (data.body || []).map(node => fromSerializedNode(node)),
            close_tag: data.close_tag ? fromSerializedNode((data.close_tag)) : null,
            is_void: data.is_void,
            source: data.source,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_tag = props.open_tag;
        this.tag_name = props.tag_name;
        this.body = props.body;
        this.close_tag = props.close_tag;
        this.is_void = props.is_void;
        this.source = props.source;
    }
    accept(visitor) {
        visitor.visitHTMLElementNode(this);
    }
    childNodes() {
        return [
            this.open_tag,
            ...this.body,
            this.close_tag,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.open_tag ? this.open_tag.recursiveErrors() : [],
            ...this.body.map(node => node.recursiveErrors()),
            this.close_tag ? this.close_tag.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ELEMENT_NODE",
            open_tag: this.open_tag ? this.open_tag.toJSON() : null,
            tag_name: this.tag_name ? this.tag_name.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            close_tag: this.close_tag ? this.close_tag.toJSON() : null,
            is_void: this.is_void,
            source: this.source,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLElementNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` open_tag: ${this.inspectNode(this.open_tag, "   ")}`;
        output += ` tag_name: ${this.tag_name ? this.tag_name.treeInspect() : ""}\n`;
        output += ` body: ${this.inspectArray(this.body, "   ")}`;
        output += ` close_tag: ${this.inspectNode(this.close_tag, "   ")}`;
        output += ` is_void: ${typeof this.is_void === 'boolean' ? String(this.is_void) : ""}\n`;
        output += ` source: ${this.source ? JSON.stringify(this.source) : ""}\n`;
        return output;
    }
}
class HTMLAttributeValueNode extends Node {
    open_quote;
    children;
    close_quote;
    quoted;
    static get type() {
        return "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    static from(data) {
        return new HTMLAttributeValueNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            open_quote: data.open_quote ? Token.from(data.open_quote) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            close_quote: data.close_quote ? Token.from(data.close_quote) : null,
            quoted: data.quoted,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.open_quote = props.open_quote;
        this.children = props.children;
        this.close_quote = props.close_quote;
        this.quoted = props.quoted;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeValueNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_VALUE_NODE",
            open_quote: this.open_quote ? this.open_quote.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            close_quote: this.close_quote ? this.close_quote.toJSON() : null,
            quoted: this.quoted,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeValueNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` open_quote: ${this.open_quote ? this.open_quote.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` close_quote: ${this.close_quote ? this.close_quote.treeInspect() : ""}\n`;
        output += ` quoted: ${typeof this.quoted === 'boolean' ? String(this.quoted) : ""}\n`;
        return output;
    }
}
class HTMLAttributeNameNode extends Node {
    children;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NAME_NODE";
    }
    static from(data) {
        return new HTMLAttributeNameNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            children: (data.children || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.children = props.children;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNameNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NAME_NODE",
            children: this.children.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNameNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` children: ${this.inspectArray(this.children, "    ")}`;
        return output;
    }
}
class HTMLAttributeNode extends Node {
    name;
    equals;
    value;
    static get type() {
        return "AST_HTML_ATTRIBUTE_NODE";
    }
    static from(data) {
        return new HTMLAttributeNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            name: data.name ? fromSerializedNode((data.name)) : null,
            equals: data.equals ? Token.from(data.equals) : null,
            value: data.value ? fromSerializedNode((data.value)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.name = props.name;
        this.equals = props.equals;
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitHTMLAttributeNode(this);
    }
    childNodes() {
        return [
            this.name,
            this.value,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            this.name ? this.name.recursiveErrors() : [],
            this.value ? this.value.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_ATTRIBUTE_NODE",
            name: this.name ? this.name.toJSON() : null,
            equals: this.equals ? this.equals.toJSON() : null,
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLAttributeNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` name: ${this.inspectNode(this.name, "   ")}`;
        output += ` equals: ${this.equals ? this.equals.treeInspect() : ""}\n`;
        output += ` value: ${this.inspectNode(this.value, "    ")}`;
        return output;
    }
}
class HTMLTextNode extends Node {
    content;
    static get type() {
        return "AST_HTML_TEXT_NODE";
    }
    static from(data) {
        return new HTMLTextNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            content: data.content,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.content = convertToUTF8(props.content);
    }
    accept(visitor) {
        visitor.visitHTMLTextNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_TEXT_NODE",
            content: this.content,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLTextNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` content: ${this.content ? JSON.stringify(this.content) : ""}\n`;
        return output;
    }
}
class HTMLCommentNode extends Node {
    comment_start;
    children;
    comment_end;
    static get type() {
        return "AST_HTML_COMMENT_NODE";
    }
    static from(data) {
        return new HTMLCommentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            comment_start: data.comment_start ? Token.from(data.comment_start) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            comment_end: data.comment_end ? Token.from(data.comment_end) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.comment_start = props.comment_start;
        this.children = props.children;
        this.comment_end = props.comment_end;
    }
    accept(visitor) {
        visitor.visitHTMLCommentNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_COMMENT_NODE",
            comment_start: this.comment_start ? this.comment_start.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            comment_end: this.comment_end ? this.comment_end.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLCommentNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` comment_start: ${this.comment_start ? this.comment_start.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` comment_end: ${this.comment_end ? this.comment_end.treeInspect() : ""}\n`;
        return output;
    }
}
class HTMLDoctypeNode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_HTML_DOCTYPE_NODE";
    }
    static from(data) {
        return new HTMLDoctypeNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitHTMLDoctypeNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_HTML_DOCTYPE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ HTMLDoctypeNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
}
class XMLDeclarationNode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_XML_DECLARATION_NODE";
    }
    static from(data) {
        return new XMLDeclarationNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitXMLDeclarationNode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_XML_DECLARATION_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ XMLDeclarationNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
}
class CDATANode extends Node {
    tag_opening;
    children;
    tag_closing;
    static get type() {
        return "AST_CDATA_NODE";
    }
    static from(data) {
        return new CDATANode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.children = props.children;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitCDATANode(this);
    }
    childNodes() {
        return [
            ...this.children,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_CDATA_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ CDATANode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
}
class WhitespaceNode extends Node {
    value;
    static get type() {
        return "AST_WHITESPACE_NODE";
    }
    static from(data) {
        return new WhitespaceNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            value: data.value ? Token.from(data.value) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.value = props.value;
    }
    accept(visitor) {
        visitor.visitWhitespaceNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_WHITESPACE_NODE",
            value: this.value ? this.value.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ WhitespaceNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` value: ${this.value ? this.value.treeInspect() : ""}\n`;
        return output;
    }
}
class ERBContentNode extends Node {
    tag_opening;
    content;
    tag_closing;
    // no-op for analyzed_ruby
    parsed;
    valid;
    static get type() {
        return "AST_ERB_CONTENT_NODE";
    }
    static from(data) {
        return new ERBContentNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            // no-op for analyzed_ruby
            parsed: data.parsed,
            valid: data.valid,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        // no-op for analyzed_ruby
        this.parsed = props.parsed;
        this.valid = props.valid;
    }
    accept(visitor) {
        visitor.visitERBContentNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CONTENT_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            // no-op for analyzed_ruby
            parsed: this.parsed,
            valid: this.valid,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBContentNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        // no-op for analyzed_ruby
        output += ` parsed: ${typeof this.parsed === 'boolean' ? String(this.parsed) : ""}\n`;
        output += ` valid: ${typeof this.valid === 'boolean' ? String(this.valid) : ""}\n`;
        return output;
    }
}
class ERBEndNode extends Node {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_END_NODE";
    }
    static from(data) {
        return new ERBEndNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBEndNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_END_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEndNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
}
class ERBElseNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ELSE_NODE";
    }
    static from(data) {
        return new ERBElseNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBElseNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ELSE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBElseNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBIfNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    end_node;
    static get type() {
        return "AST_ERB_IF_NODE";
    }
    static from(data) {
        return new ERBIfNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBIfNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IF_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBIfNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` subsequent: ${this.inspectNode(this.subsequent, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBBlockNode extends Node {
    tag_opening;
    content;
    tag_closing;
    body;
    end_node;
    static get type() {
        return "AST_ERB_BLOCK_NODE";
    }
    static from(data) {
        return new ERBBlockNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            body: (data.body || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.body = props.body;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBlockNode(this);
    }
    childNodes() {
        return [
            ...this.body,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.body.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BLOCK_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            body: this.body.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBlockNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` body: ${this.inspectArray(this.body, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBWhenNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_WHEN_NODE";
    }
    static from(data) {
        return new ERBWhenNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBWhenNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHEN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhenNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBCaseNode extends Node {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_NODE";
    }
    static from(data) {
        return new ERBCaseNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` conditions: ${this.inspectArray(this.conditions, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBCaseMatchNode extends Node {
    tag_opening;
    content;
    tag_closing;
    children;
    conditions;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_CASE_MATCH_NODE";
    }
    static from(data) {
        return new ERBCaseMatchNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            children: (data.children || []).map(node => fromSerializedNode(node)),
            conditions: (data.conditions || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.children = props.children;
        this.conditions = props.conditions;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBCaseMatchNode(this);
    }
    childNodes() {
        return [
            ...this.children,
            ...this.conditions,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.children.map(node => node.recursiveErrors()),
            ...this.conditions.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_CASE_MATCH_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            children: this.children.map(node => node.toJSON()),
            conditions: this.conditions.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBCaseMatchNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` children: ${this.inspectArray(this.children, "   ")}`;
        output += ` conditions: ${this.inspectArray(this.conditions, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBWhileNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_WHILE_NODE";
    }
    static from(data) {
        return new ERBWhileNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBWhileNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_WHILE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBWhileNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBUntilNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_UNTIL_NODE";
    }
    static from(data) {
        return new ERBUntilNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUntilNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNTIL_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUntilNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBForNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    end_node;
    static get type() {
        return "AST_ERB_FOR_NODE";
    }
    static from(data) {
        return new ERBForNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBForNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_FOR_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBForNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBRescueNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    subsequent;
    static get type() {
        return "AST_ERB_RESCUE_NODE";
    }
    static from(data) {
        return new ERBRescueNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            subsequent: data.subsequent ? fromSerializedNode((data.subsequent)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.subsequent = props.subsequent;
    }
    accept(visitor) {
        visitor.visitERBRescueNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.subsequent,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.subsequent ? this.subsequent.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_RESCUE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            subsequent: this.subsequent ? this.subsequent.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBRescueNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` subsequent: ${this.inspectNode(this.subsequent, "    ")}`;
        return output;
    }
}
class ERBEnsureNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_ENSURE_NODE";
    }
    static from(data) {
        return new ERBEnsureNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBEnsureNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_ENSURE_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBEnsureNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
class ERBBeginNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    rescue_clause;
    else_clause;
    ensure_clause;
    end_node;
    static get type() {
        return "AST_ERB_BEGIN_NODE";
    }
    static from(data) {
        return new ERBBeginNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            rescue_clause: data.rescue_clause ? fromSerializedNode((data.rescue_clause)) : null,
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            ensure_clause: data.ensure_clause ? fromSerializedNode((data.ensure_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.rescue_clause = props.rescue_clause;
        this.else_clause = props.else_clause;
        this.ensure_clause = props.ensure_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBBeginNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.rescue_clause,
            this.else_clause,
            this.ensure_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.rescue_clause ? this.rescue_clause.recursiveErrors() : [],
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.ensure_clause ? this.ensure_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_BEGIN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            rescue_clause: this.rescue_clause ? this.rescue_clause.toJSON() : null,
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            ensure_clause: this.ensure_clause ? this.ensure_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBBeginNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` rescue_clause: ${this.inspectNode(this.rescue_clause, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` ensure_clause: ${this.inspectNode(this.ensure_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBUnlessNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    else_clause;
    end_node;
    static get type() {
        return "AST_ERB_UNLESS_NODE";
    }
    static from(data) {
        return new ERBUnlessNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
            else_clause: data.else_clause ? fromSerializedNode((data.else_clause)) : null,
            end_node: data.end_node ? fromSerializedNode((data.end_node)) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
        this.else_clause = props.else_clause;
        this.end_node = props.end_node;
    }
    accept(visitor) {
        visitor.visitERBUnlessNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
            this.else_clause,
            this.end_node,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
            this.else_clause ? this.else_clause.recursiveErrors() : [],
            this.end_node ? this.end_node.recursiveErrors() : [],
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_UNLESS_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
            else_clause: this.else_clause ? this.else_clause.toJSON() : null,
            end_node: this.end_node ? this.end_node.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBUnlessNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "   ")}`;
        output += ` else_clause: ${this.inspectNode(this.else_clause, "   ")}`;
        output += ` end_node: ${this.inspectNode(this.end_node, "    ")}`;
        return output;
    }
}
class ERBYieldNode extends Node {
    tag_opening;
    content;
    tag_closing;
    static get type() {
        return "AST_ERB_YIELD_NODE";
    }
    static from(data) {
        return new ERBYieldNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
    }
    accept(visitor) {
        visitor.visitERBYieldNode(this);
    }
    childNodes() {
        return [];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_YIELD_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBYieldNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        return output;
    }
}
class ERBInNode extends Node {
    tag_opening;
    content;
    tag_closing;
    statements;
    static get type() {
        return "AST_ERB_IN_NODE";
    }
    static from(data) {
        return new ERBInNode({
            type: data.type,
            location: Location.from(data.location),
            errors: (data.errors || []).map(error => HerbError.from(error)),
            tag_opening: data.tag_opening ? Token.from(data.tag_opening) : null,
            content: data.content ? Token.from(data.content) : null,
            tag_closing: data.tag_closing ? Token.from(data.tag_closing) : null,
            statements: (data.statements || []).map(node => fromSerializedNode(node)),
        });
    }
    constructor(props) {
        super(props.type, props.location, props.errors);
        this.tag_opening = props.tag_opening;
        this.content = props.content;
        this.tag_closing = props.tag_closing;
        this.statements = props.statements;
    }
    accept(visitor) {
        visitor.visitERBInNode(this);
    }
    childNodes() {
        return [
            ...this.statements,
        ];
    }
    compactChildNodes() {
        return this.childNodes().filter(node => node !== null && node !== undefined);
    }
    recursiveErrors() {
        return [
            ...this.errors,
            ...this.statements.map(node => node.recursiveErrors()),
        ].flat();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: "AST_ERB_IN_NODE",
            tag_opening: this.tag_opening ? this.tag_opening.toJSON() : null,
            content: this.content ? this.content.toJSON() : null,
            tag_closing: this.tag_closing ? this.tag_closing.toJSON() : null,
            statements: this.statements.map(node => node.toJSON()),
        };
    }
    treeInspect() {
        let output = "";
        output += `@ ERBInNode ${this.location.treeInspectWithLabel()}\n`;
        output += ` errors: ${this.inspectArray(this.errors, "   ")}`;
        output += ` tag_opening: ${this.tag_opening ? this.tag_opening.treeInspect() : ""}\n`;
        output += ` content: ${this.content ? this.content.treeInspect() : ""}\n`;
        output += ` tag_closing: ${this.tag_closing ? this.tag_closing.treeInspect() : ""}\n`;
        output += ` statements: ${this.inspectArray(this.statements, "    ")}`;
        return output;
    }
}
function fromSerializedNode(node) {
    switch (node.type) {
        case "AST_DOCUMENT_NODE": return DocumentNode.from(node);
        case "AST_LITERAL_NODE": return LiteralNode.from(node);
        case "AST_HTML_OPEN_TAG_NODE": return HTMLOpenTagNode.from(node);
        case "AST_HTML_CLOSE_TAG_NODE": return HTMLCloseTagNode.from(node);
        case "AST_HTML_ELEMENT_NODE": return HTMLElementNode.from(node);
        case "AST_HTML_ATTRIBUTE_VALUE_NODE": return HTMLAttributeValueNode.from(node);
        case "AST_HTML_ATTRIBUTE_NAME_NODE": return HTMLAttributeNameNode.from(node);
        case "AST_HTML_ATTRIBUTE_NODE": return HTMLAttributeNode.from(node);
        case "AST_HTML_TEXT_NODE": return HTMLTextNode.from(node);
        case "AST_HTML_COMMENT_NODE": return HTMLCommentNode.from(node);
        case "AST_HTML_DOCTYPE_NODE": return HTMLDoctypeNode.from(node);
        case "AST_XML_DECLARATION_NODE": return XMLDeclarationNode.from(node);
        case "AST_CDATA_NODE": return CDATANode.from(node);
        case "AST_WHITESPACE_NODE": return WhitespaceNode.from(node);
        case "AST_ERB_CONTENT_NODE": return ERBContentNode.from(node);
        case "AST_ERB_END_NODE": return ERBEndNode.from(node);
        case "AST_ERB_ELSE_NODE": return ERBElseNode.from(node);
        case "AST_ERB_IF_NODE": return ERBIfNode.from(node);
        case "AST_ERB_BLOCK_NODE": return ERBBlockNode.from(node);
        case "AST_ERB_WHEN_NODE": return ERBWhenNode.from(node);
        case "AST_ERB_CASE_NODE": return ERBCaseNode.from(node);
        case "AST_ERB_CASE_MATCH_NODE": return ERBCaseMatchNode.from(node);
        case "AST_ERB_WHILE_NODE": return ERBWhileNode.from(node);
        case "AST_ERB_UNTIL_NODE": return ERBUntilNode.from(node);
        case "AST_ERB_FOR_NODE": return ERBForNode.from(node);
        case "AST_ERB_RESCUE_NODE": return ERBRescueNode.from(node);
        case "AST_ERB_ENSURE_NODE": return ERBEnsureNode.from(node);
        case "AST_ERB_BEGIN_NODE": return ERBBeginNode.from(node);
        case "AST_ERB_UNLESS_NODE": return ERBUnlessNode.from(node);
        case "AST_ERB_YIELD_NODE": return ERBYieldNode.from(node);
        case "AST_ERB_IN_NODE": return ERBInNode.from(node);
        default:
            throw new Error(`Unknown node type: ${node.type}`);
    }
}

class Result {
    source;
    warnings;
    errors;
    constructor(source, warnings = [], errors = []) {
        this.source = source;
        this.warnings = warnings || [];
        this.errors = errors || [];
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return this.errors.length === 0;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        return this.errors.length > 0;
    }
}

class HerbWarning {
    message;
    location;
    static from(warning) {
        return new HerbWarning(warning.message, Location.from(warning.location));
    }
    constructor(message, location) {
        this.message = message;
        this.location = location;
    }
}

/**
 * Represents the result of a parsing operation, extending the base `Result` class.
 * It contains the parsed document node, source code, warnings, and errors.
 */
class ParseResult extends Result {
    /** The document node generated from the source code. */
    value;
    /**
     * Creates a `ParseResult` instance from a serialized result.
     * @param result - The serialized parse result containing the value and source.
     * @returns A new `ParseResult` instance.
     */
    static from(result) {
        return new ParseResult(DocumentNode.from(result.value), result.source, result.warnings.map((warning) => HerbWarning.from(warning)), result.errors.map((error) => HerbError.from(error)));
    }
    /**
     * Constructs a new `ParseResult`.
     * @param value - The document node.
     * @param source - The source code that was parsed.
     * @param warnings - An array of warnings encountered during parsing.
     * @param errors - An array of errors encountered during parsing.
     */
    constructor(value, source, warnings = [], errors = []) {
        super(source, warnings, errors);
        this.value = value;
    }
    /**
     * Determines if the parsing failed.
     * @returns `true` if there are errors, otherwise `false`.
     */
    get failed() {
        // Consider errors on this result and recursively in the document tree
        return this.recursiveErrors().length > 0;
    }
    /**
     * Determines if the parsing was successful.
     * @returns `true` if there are no errors, otherwise `false`.
     */
    get successful() {
        return !this.failed;
    }
    /**
     * Returns a pretty-printed JSON string of the errors.
     * @returns A string representation of the errors.
     */
    prettyErrors() {
        return JSON.stringify([...this.errors, ...this.value.errors], null, 2);
    }
    recursiveErrors() {
        return [...this.errors, ...this.value.recursiveErrors()];
    }
    /**
     * Returns a pretty-printed string of the parse result.
     * @returns A string representation of the parse result.
     */
    inspect() {
        return this.value.inspect();
    }
    /**
     * Accepts a visitor to traverse the document node.
     * @param visitor - The visitor instance.
     */
    visit(visitor) {
        visitor.visit(this.value);
    }
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.7.5/templates/javascript/packages/core/src/node-type-guards.ts.erb
/**
 * Type guard functions for AST nodes.
 * These functions provide type checking by combining both instanceof
 * checks and type string comparisons for maximum reliability across different
 * runtime scenarios (e.g., serialized/deserialized nodes).
 */
/**
 * Checks if a node is a DocumentNode
 */
function isDocumentNode(node) {
    return node instanceof DocumentNode || node.type === "AST_DOCUMENT_NODE" || node.constructor.type === "AST_DOCUMENT_NODE";
}
/**
 * Checks if a node is a LiteralNode
 */
function isLiteralNode(node) {
    return node instanceof LiteralNode || node.type === "AST_LITERAL_NODE" || node.constructor.type === "AST_LITERAL_NODE";
}
/**
 * Checks if a node is a HTMLOpenTagNode
 */
function isHTMLOpenTagNode(node) {
    return node instanceof HTMLOpenTagNode || node.type === "AST_HTML_OPEN_TAG_NODE" || node.constructor.type === "AST_HTML_OPEN_TAG_NODE";
}
/**
 * Checks if a node is a HTMLCloseTagNode
 */
function isHTMLCloseTagNode(node) {
    return node instanceof HTMLCloseTagNode || node.type === "AST_HTML_CLOSE_TAG_NODE" || node.constructor.type === "AST_HTML_CLOSE_TAG_NODE";
}
/**
 * Checks if a node is a HTMLElementNode
 */
function isHTMLElementNode(node) {
    return node instanceof HTMLElementNode || node.type === "AST_HTML_ELEMENT_NODE" || node.constructor.type === "AST_HTML_ELEMENT_NODE";
}
/**
 * Checks if a node is a HTMLAttributeValueNode
 */
function isHTMLAttributeValueNode(node) {
    return node instanceof HTMLAttributeValueNode || node.type === "AST_HTML_ATTRIBUTE_VALUE_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_VALUE_NODE";
}
/**
 * Checks if a node is a HTMLAttributeNameNode
 */
function isHTMLAttributeNameNode(node) {
    return node instanceof HTMLAttributeNameNode || node.type === "AST_HTML_ATTRIBUTE_NAME_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_NAME_NODE";
}
/**
 * Checks if a node is a HTMLAttributeNode
 */
function isHTMLAttributeNode(node) {
    return node instanceof HTMLAttributeNode || node.type === "AST_HTML_ATTRIBUTE_NODE" || node.constructor.type === "AST_HTML_ATTRIBUTE_NODE";
}
/**
 * Checks if a node is a HTMLTextNode
 */
function isHTMLTextNode(node) {
    return node instanceof HTMLTextNode || node.type === "AST_HTML_TEXT_NODE" || node.constructor.type === "AST_HTML_TEXT_NODE";
}
/**
 * Checks if a node is a HTMLCommentNode
 */
function isHTMLCommentNode(node) {
    return node instanceof HTMLCommentNode || node.type === "AST_HTML_COMMENT_NODE" || node.constructor.type === "AST_HTML_COMMENT_NODE";
}
/**
 * Checks if a node is a HTMLDoctypeNode
 */
function isHTMLDoctypeNode(node) {
    return node instanceof HTMLDoctypeNode || node.type === "AST_HTML_DOCTYPE_NODE" || node.constructor.type === "AST_HTML_DOCTYPE_NODE";
}
/**
 * Checks if a node is a XMLDeclarationNode
 */
function isXMLDeclarationNode(node) {
    return node instanceof XMLDeclarationNode || node.type === "AST_XML_DECLARATION_NODE" || node.constructor.type === "AST_XML_DECLARATION_NODE";
}
/**
 * Checks if a node is a CDATANode
 */
function isCDATANode(node) {
    return node instanceof CDATANode || node.type === "AST_CDATA_NODE" || node.constructor.type === "AST_CDATA_NODE";
}
/**
 * Checks if a node is a WhitespaceNode
 */
function isWhitespaceNode(node) {
    return node instanceof WhitespaceNode || node.type === "AST_WHITESPACE_NODE" || node.constructor.type === "AST_WHITESPACE_NODE";
}
/**
 * Checks if a node is a ERBContentNode
 */
function isERBContentNode(node) {
    return node instanceof ERBContentNode || node.type === "AST_ERB_CONTENT_NODE" || node.constructor.type === "AST_ERB_CONTENT_NODE";
}
/**
 * Checks if a node is a ERBEndNode
 */
function isERBEndNode(node) {
    return node instanceof ERBEndNode || node.type === "AST_ERB_END_NODE" || node.constructor.type === "AST_ERB_END_NODE";
}
/**
 * Checks if a node is a ERBElseNode
 */
function isERBElseNode(node) {
    return node instanceof ERBElseNode || node.type === "AST_ERB_ELSE_NODE" || node.constructor.type === "AST_ERB_ELSE_NODE";
}
/**
 * Checks if a node is a ERBIfNode
 */
function isERBIfNode(node) {
    return node instanceof ERBIfNode || node.type === "AST_ERB_IF_NODE" || node.constructor.type === "AST_ERB_IF_NODE";
}
/**
 * Checks if a node is a ERBBlockNode
 */
function isERBBlockNode(node) {
    return node instanceof ERBBlockNode || node.type === "AST_ERB_BLOCK_NODE" || node.constructor.type === "AST_ERB_BLOCK_NODE";
}
/**
 * Checks if a node is a ERBWhenNode
 */
function isERBWhenNode(node) {
    return node instanceof ERBWhenNode || node.type === "AST_ERB_WHEN_NODE" || node.constructor.type === "AST_ERB_WHEN_NODE";
}
/**
 * Checks if a node is a ERBCaseNode
 */
function isERBCaseNode(node) {
    return node instanceof ERBCaseNode || node.type === "AST_ERB_CASE_NODE" || node.constructor.type === "AST_ERB_CASE_NODE";
}
/**
 * Checks if a node is a ERBCaseMatchNode
 */
function isERBCaseMatchNode(node) {
    return node instanceof ERBCaseMatchNode || node.type === "AST_ERB_CASE_MATCH_NODE" || node.constructor.type === "AST_ERB_CASE_MATCH_NODE";
}
/**
 * Checks if a node is a ERBWhileNode
 */
function isERBWhileNode(node) {
    return node instanceof ERBWhileNode || node.type === "AST_ERB_WHILE_NODE" || node.constructor.type === "AST_ERB_WHILE_NODE";
}
/**
 * Checks if a node is a ERBUntilNode
 */
function isERBUntilNode(node) {
    return node instanceof ERBUntilNode || node.type === "AST_ERB_UNTIL_NODE" || node.constructor.type === "AST_ERB_UNTIL_NODE";
}
/**
 * Checks if a node is a ERBForNode
 */
function isERBForNode(node) {
    return node instanceof ERBForNode || node.type === "AST_ERB_FOR_NODE" || node.constructor.type === "AST_ERB_FOR_NODE";
}
/**
 * Checks if a node is a ERBRescueNode
 */
function isERBRescueNode(node) {
    return node instanceof ERBRescueNode || node.type === "AST_ERB_RESCUE_NODE" || node.constructor.type === "AST_ERB_RESCUE_NODE";
}
/**
 * Checks if a node is a ERBEnsureNode
 */
function isERBEnsureNode(node) {
    return node instanceof ERBEnsureNode || node.type === "AST_ERB_ENSURE_NODE" || node.constructor.type === "AST_ERB_ENSURE_NODE";
}
/**
 * Checks if a node is a ERBBeginNode
 */
function isERBBeginNode(node) {
    return node instanceof ERBBeginNode || node.type === "AST_ERB_BEGIN_NODE" || node.constructor.type === "AST_ERB_BEGIN_NODE";
}
/**
 * Checks if a node is a ERBUnlessNode
 */
function isERBUnlessNode(node) {
    return node instanceof ERBUnlessNode || node.type === "AST_ERB_UNLESS_NODE" || node.constructor.type === "AST_ERB_UNLESS_NODE";
}
/**
 * Checks if a node is a ERBYieldNode
 */
function isERBYieldNode(node) {
    return node instanceof ERBYieldNode || node.type === "AST_ERB_YIELD_NODE" || node.constructor.type === "AST_ERB_YIELD_NODE";
}
/**
 * Checks if a node is a ERBInNode
 */
function isERBInNode(node) {
    return node instanceof ERBInNode || node.type === "AST_ERB_IN_NODE" || node.constructor.type === "AST_ERB_IN_NODE";
}
/**
 * Map of node classes to their corresponding type guard functions
 *
 * @example
 * const guard = NODE_TYPE_GUARDS[HTMLTextNode]
 *
 * if (guard(node)) {
 *   // node is HTMLTextNode
 * }
 */
const NODE_TYPE_GUARDS = new Map([
    [DocumentNode, isDocumentNode],
    [LiteralNode, isLiteralNode],
    [HTMLOpenTagNode, isHTMLOpenTagNode],
    [HTMLCloseTagNode, isHTMLCloseTagNode],
    [HTMLElementNode, isHTMLElementNode],
    [HTMLAttributeValueNode, isHTMLAttributeValueNode],
    [HTMLAttributeNameNode, isHTMLAttributeNameNode],
    [HTMLAttributeNode, isHTMLAttributeNode],
    [HTMLTextNode, isHTMLTextNode],
    [HTMLCommentNode, isHTMLCommentNode],
    [HTMLDoctypeNode, isHTMLDoctypeNode],
    [XMLDeclarationNode, isXMLDeclarationNode],
    [CDATANode, isCDATANode],
    [WhitespaceNode, isWhitespaceNode],
    [ERBContentNode, isERBContentNode],
    [ERBEndNode, isERBEndNode],
    [ERBElseNode, isERBElseNode],
    [ERBIfNode, isERBIfNode],
    [ERBBlockNode, isERBBlockNode],
    [ERBWhenNode, isERBWhenNode],
    [ERBCaseNode, isERBCaseNode],
    [ERBCaseMatchNode, isERBCaseMatchNode],
    [ERBWhileNode, isERBWhileNode],
    [ERBUntilNode, isERBUntilNode],
    [ERBForNode, isERBForNode],
    [ERBRescueNode, isERBRescueNode],
    [ERBEnsureNode, isERBEnsureNode],
    [ERBBeginNode, isERBBeginNode],
    [ERBUnlessNode, isERBUnlessNode],
    [ERBYieldNode, isERBYieldNode],
    [ERBInNode, isERBInNode],
]);
/**
 * Map of AST node type strings to their corresponding type guard functions
 *
 * @example
 * const guard = AST_TYPE_GUARDS["AST_HTML_TEXT_NODE"]
 *
 * if (guard(node)) {
 *   // node is HTMLTextNode
 * }
 */
const AST_TYPE_GUARDS = new Map([
    ["AST_DOCUMENT_NODE", isDocumentNode],
    ["AST_LITERAL_NODE", isLiteralNode],
    ["AST_HTML_OPEN_TAG_NODE", isHTMLOpenTagNode],
    ["AST_HTML_CLOSE_TAG_NODE", isHTMLCloseTagNode],
    ["AST_HTML_ELEMENT_NODE", isHTMLElementNode],
    ["AST_HTML_ATTRIBUTE_VALUE_NODE", isHTMLAttributeValueNode],
    ["AST_HTML_ATTRIBUTE_NAME_NODE", isHTMLAttributeNameNode],
    ["AST_HTML_ATTRIBUTE_NODE", isHTMLAttributeNode],
    ["AST_HTML_TEXT_NODE", isHTMLTextNode],
    ["AST_HTML_COMMENT_NODE", isHTMLCommentNode],
    ["AST_HTML_DOCTYPE_NODE", isHTMLDoctypeNode],
    ["AST_XML_DECLARATION_NODE", isXMLDeclarationNode],
    ["AST_CDATA_NODE", isCDATANode],
    ["AST_WHITESPACE_NODE", isWhitespaceNode],
    ["AST_ERB_CONTENT_NODE", isERBContentNode],
    ["AST_ERB_END_NODE", isERBEndNode],
    ["AST_ERB_ELSE_NODE", isERBElseNode],
    ["AST_ERB_IF_NODE", isERBIfNode],
    ["AST_ERB_BLOCK_NODE", isERBBlockNode],
    ["AST_ERB_WHEN_NODE", isERBWhenNode],
    ["AST_ERB_CASE_NODE", isERBCaseNode],
    ["AST_ERB_CASE_MATCH_NODE", isERBCaseMatchNode],
    ["AST_ERB_WHILE_NODE", isERBWhileNode],
    ["AST_ERB_UNTIL_NODE", isERBUntilNode],
    ["AST_ERB_FOR_NODE", isERBForNode],
    ["AST_ERB_RESCUE_NODE", isERBRescueNode],
    ["AST_ERB_ENSURE_NODE", isERBEnsureNode],
    ["AST_ERB_BEGIN_NODE", isERBBeginNode],
    ["AST_ERB_UNLESS_NODE", isERBUnlessNode],
    ["AST_ERB_YIELD_NODE", isERBYieldNode],
    ["AST_ERB_IN_NODE", isERBInNode],
]);
/**
 * Checks if a node matches any of the provided type identifiers with proper type narrowing
 * Supports AST type strings, node classes, or type guard functions
 *
 * @example
 * if (isAnyOf(node, "AST_HTML_TEXT_NODE", "AST_LITERAL_NODE")) {
 *   // node is narrowed to HTMLTextNode | LiteralNode
 * }
 *
 * @example
 * if (isAnyOf(node, HTMLTextNode, LiteralNode)) {
 *   // node is narrowed to HTMLTextNode | LiteralNode
 * }
 */
function isAnyOf(node, ...types) {
    return types.some(type => {
        if (typeof type === 'string') {
            return isNode(node, type);
        }
        else if (typeof type === 'function' && type.prototype && type.prototype.constructor === type && NODE_TYPE_GUARDS.has(type)) {
            return isNode(node, type);
        }
        else if (typeof type === 'function') {
            return type(node);
        }
        else {
            return false;
        }
    });
}
function areAllOfType(nodes, ...types) {
    return nodes.every(node => isAnyOf(node, ...types));
}
function filterNodes(nodes, ...types) {
    if (!nodes)
        return [];
    return nodes.filter(node => isAnyOf(node, ...types));
}
function isNode(node, type) {
    if (!node)
        return false;
    if (typeof type === 'string') {
        const guard = AST_TYPE_GUARDS.get(type);
        return guard ? guard(node) : false;
    }
    else if (typeof type === 'function') {
        const guard = NODE_TYPE_GUARDS.get(type);
        return guard ? guard(node) : false;
    }
    else {
        return false;
    }
}
function isToken(object) {
    return (object instanceof Token) || (object?.constructor?.name === "Token" && "value" in object) || object.type?.startsWith('TOKEN_');
}
function isParseResult(object) {
    return (object instanceof ParseResult) || (object?.constructor?.name === "ParseResult" && "value" in object);
}
/**
 * Filters an array of nodes to only include LiteralNode nodes
 */
function filterLiteralNodes(nodes) {
    return nodes.filter(isLiteralNode);
}
/**
 * Filters an array of nodes to only include ERBContentNode nodes
 */
function filterERBContentNodes(nodes) {
    return nodes.filter(isERBContentNode);
}

/**
 * Checks if a node is an ERB output node (generates content: <%= %> or <%== %>)
 */
function isERBOutputNode(node) {
    if (!isNode(node, ERBContentNode))
        return false;
    if (!node.tag_opening?.value)
        return false;
    return ["<%=", "<%=="].includes(node.tag_opening?.value);
}
/**
 * Checks if an array of nodes contains any ERB content nodes
 */
function hasERBContent(nodes) {
    return nodes.some(isERBContentNode);
}
/**
 * Checks if an array of nodes contains any ERB output nodes (dynamic content)
 */
function hasERBOutput(nodes) {
    return nodes.some(isERBOutputNode);
}
/**
 * Extracts a static string from an array of literal nodes
 * Returns null if any node is not a literal node
 */
function getStaticStringFromNodes(nodes) {
    if (!areAllOfType(nodes, LiteralNode)) {
        return null;
    }
    return nodes.map(node => node.content).join("");
}
/**
 * Extracts static content from nodes, including mixed literal/ERB content
 * Returns the concatenated literal content, or null if no literal nodes exist
 */
function getStaticContentFromNodes(nodes) {
    const literalNodes = filterLiteralNodes(nodes);
    if (literalNodes.length === 0) {
        return null;
    }
    return literalNodes.map(node => node.content).join("");
}
/**
 * Checks if nodes are effectively static (only literals and non-output ERB)
 * Non-output ERB like <% if %> doesn't affect static validation
 */
function isEffectivelyStatic(nodes) {
    return !hasERBOutput(nodes);
}
/**
 * Gets static-validatable content from nodes (ignores control ERB, includes literals)
 * Returns concatenated literal content for validation, or null if contains output ERB
 */
function getValidatableStaticContent(nodes) {
    if (hasERBOutput(nodes)) {
        return null;
    }
    return filterLiteralNodes(nodes).map(node => node.content).join("");
}
/**
 * Extracts a combined string from nodes, including ERB content
 * For ERB nodes, includes the full tag syntax (e.g., "<%= foo %>")
 * This is useful for debugging or displaying the full attribute name
 */
function getCombinedStringFromNodes(nodes) {
    return nodes.map(node => {
        if (isLiteralNode(node)) {
            return node.content;
        }
        else if (isERBContentNode(node)) {
            const opening = node.tag_opening?.value || "";
            const content = node.content?.value || "";
            const closing = node.tag_closing?.value || "";
            return `${opening}${content}${closing}`;
        }
        else {
            // For other node types, return a placeholder or empty string
            return `[${node.type}]`;
        }
    }).join("");
}
/**
 * Checks if an HTML attribute name node has dynamic content (contains ERB)
 */
function hasDynamicAttributeName$1(attributeNameNode) {
    if (!attributeNameNode.children) {
        return false;
    }
    return hasERBContent(attributeNameNode.children);
}
/**
 * Gets the static string value of an HTML attribute name node
 * Returns null if the attribute name contains dynamic content (ERB)
 */
function getStaticAttributeName(attributeNameNode) {
    if (!attributeNameNode.children) {
        return null;
    }
    return getStaticStringFromNodes(attributeNameNode.children);
}
/**
 * Gets the combined string representation of an HTML attribute name node
 * This includes both static and dynamic content, useful for debugging
 */
function getCombinedAttributeName(attributeNameNode) {
    if (!attributeNameNode.children) {
        return "";
    }
    return getCombinedStringFromNodes(attributeNameNode.children);
}
/**
 * Gets the tag name of an HTML element node
 */
function getTagName$1(node) {
    return node.tag_name?.value ?? "";
}
/**
 * Compares two positions to determine if the first comes before the second
 * Returns true if pos1 comes before pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
function isPositionBefore(position1, position2, inclusive = false) {
    if (position1.line < position2.line)
        return true;
    if (position1.line > position2.line)
        return false;
    return inclusive ? position1.column <= position2.column : position1.column < position2.column;
}
/**
 * Compares two positions to determine if the first comes after the second
 * Returns true if pos1 comes after pos2 in source order
 * @param inclusive - If true, returns true when positions are equal
 */
function isPositionAfter(position1, position2, inclusive = false) {
    if (position1.line > position2.line)
        return true;
    if (position1.line < position2.line)
        return false;
    return inclusive ? position1.column >= position2.column : position1.column > position2.column;
}
/**
 * Gets nodes that end before the specified position
 * @param inclusive - If true, includes nodes that end exactly at the position (default: false, matching half-open interval semantics)
 */
function getNodesBeforePosition(nodes, position, inclusive = false) {
    return nodes.filter(node => node.location && isPositionBefore(node.location.end, position, inclusive));
}
/**
 * Gets nodes that start after the specified position
 * @param inclusive - If true, includes nodes that start exactly at the position (default: true, matching typical boundary behavior)
 */
function getNodesAfterPosition(nodes, position, inclusive = true) {
    return nodes.filter(node => node.location && isPositionAfter(node.location.start, position, inclusive));
}

// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.7.5/templates/javascript/packages/core/src/visitor.ts.erb
class Visitor {
    visit(node) {
        if (!node)
            return;
        node.accept(this);
    }
    visitAll(nodes) {
        nodes.forEach(node => node?.accept(this));
    }
    visitChildNodes(node) {
        node.compactChildNodes().forEach(node => node.accept(this));
    }
    visitNode(_node) {
        // Default implementation does nothing
    }
    visitERBNode(_node) {
        // Default implementation does nothing
    }
    visitDocumentNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitLiteralNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLOpenTagNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLCloseTagNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLElementNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNameNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLAttributeNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLTextNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLCommentNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitHTMLDoctypeNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitXMLDeclarationNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitCDATANode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitWhitespaceNode(node) {
        this.visitNode(node);
        this.visitChildNodes(node);
    }
    visitERBContentNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBEndNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBElseNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBIfNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBBlockNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBWhenNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBCaseNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBCaseMatchNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBWhileNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBUntilNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBForNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBRescueNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBEnsureNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBBeginNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBUnlessNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBYieldNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
    visitERBInNode(node) {
        this.visitNode(node);
        this.visitERBNode(node);
        this.visitChildNodes(node);
    }
}

class ParserRule {
    static type = "parser";
}
/**
 * Default context object with all keys defined but set to undefined
 */
const DEFAULT_LINT_CONTEXT = {
    fileName: undefined
};
class SourceRule {
    static type = "source";
}

var ControlFlowType;
(function (ControlFlowType) {
    ControlFlowType[ControlFlowType["CONDITIONAL"] = 0] = "CONDITIONAL";
    ControlFlowType[ControlFlowType["LOOP"] = 1] = "LOOP";
})(ControlFlowType || (ControlFlowType = {}));
/**
 * Base visitor class that provides common functionality for rule visitors
 */
class BaseRuleVisitor extends Visitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        super();
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create a lint offense
     */
    createOffense(message, location, severity = "error") {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            severity,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, severity = "error") {
        this.offenses.push(this.createOffense(message, location, severity));
    }
}
/**
 * Mixin that adds control flow tracking capabilities to rule visitors
 * This allows rules to track state across different control flow structures
 * like if/else branches, loops, etc.
 *
 * @template TControlFlowState - Type for state passed between onEnterControlFlow and onExitControlFlow
 * @template TBranchState - Type for state passed between onEnterBranch and onExitBranch
 */
class ControlFlowTrackingVisitor extends BaseRuleVisitor {
    isInControlFlow = false;
    currentControlFlowType = null;
    /**
     * Handle visiting a control flow node with proper scope management
     */
    handleControlFlowNode(node, controlFlowType, visitChildren) {
        const wasInControlFlow = this.isInControlFlow;
        const previousControlFlowType = this.currentControlFlowType;
        this.isInControlFlow = true;
        this.currentControlFlowType = controlFlowType;
        const stateToRestore = this.onEnterControlFlow(controlFlowType, wasInControlFlow);
        visitChildren();
        this.onExitControlFlow(controlFlowType, wasInControlFlow, stateToRestore);
        this.isInControlFlow = wasInControlFlow;
        this.currentControlFlowType = previousControlFlowType;
    }
    /**
     * Handle visiting a branch node (like else, when) with proper scope management
     */
    startNewBranch(visitChildren) {
        const stateToRestore = this.onEnterBranch();
        visitChildren();
        this.onExitBranch(stateToRestore);
    }
    visitERBIfNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBIfNode(node));
    }
    visitERBUnlessNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBUnlessNode(node));
    }
    visitERBCaseNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBCaseNode(node));
    }
    visitERBCaseMatchNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBCaseMatchNode(node));
    }
    visitERBWhileNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBWhileNode(node));
    }
    visitERBForNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBForNode(node));
    }
    visitERBUntilNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.LOOP, () => super.visitERBUntilNode(node));
    }
    visitERBBlockNode(node) {
        this.handleControlFlowNode(node, ControlFlowType.CONDITIONAL, () => super.visitERBBlockNode(node));
    }
    visitERBElseNode(node) {
        this.startNewBranch(() => super.visitERBElseNode(node));
    }
    visitERBWhenNode(node) {
        this.startNewBranch(() => super.visitERBWhenNode(node));
    }
}
/**
 * Gets attributes from an HTMLOpenTagNode
 */
function getAttributes(node) {
    return node.children.filter(node => node.type === "AST_HTML_ATTRIBUTE_NODE");
}
/**
 * Gets the tag name from an HTML tag node (lowercased)
 */
function getTagName(node) {
    return node.tag_name?.value.toLowerCase() || null;
}
/**
 * Gets the attribute name from an HTMLAttributeNode (lowercased)
 * Returns null if the attribute name contains dynamic content (ERB)
 */
function getAttributeName(attributeNode, lowercase = true) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        const staticName = getStaticAttributeName(nameNode);
        if (!lowercase)
            return staticName;
        return staticName ? staticName.toLowerCase() : null;
    }
    return null;
}
/**
 * Checks if an attribute has a dynamic (ERB-containing) name
 */
function hasDynamicAttributeName(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        return hasDynamicAttributeName$1(nameNode);
    }
    return false;
}
/**
 * Gets the combined string representation of an attribute name (for debugging)
 * This includes both static content and ERB syntax
 */
function getCombinedAttributeNameString(attributeNode) {
    if (attributeNode.name?.type === "AST_HTML_ATTRIBUTE_NAME_NODE") {
        const nameNode = attributeNode.name;
        return getCombinedAttributeName(nameNode);
    }
    return "";
}
/**
 * Checks if an attribute value contains only static content (no ERB)
 */
function hasStaticAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (!valueNode?.children)
        return false;
    return valueNode.children.every(child => child.type === "AST_LITERAL_NODE");
}
/**
 * Gets the static string value of an attribute (returns null if it contains ERB)
 */
function getStaticAttributeValue(attributeNode) {
    if (!hasStaticAttributeValue(attributeNode))
        return null;
    const valueNode = attributeNode.value;
    const result = valueNode.children
        ?.filter(child => child.type === "AST_LITERAL_NODE")
        .map(child => child.content)
        .join("") || "";
    return result;
}
/**
 * Gets the value nodes array for dynamic inspection
 */
function getAttributeValueNodes(attributeNode) {
    const valueNode = attributeNode.value;
    return valueNode?.children || [];
}
/**
 * Gets the attribute value content from an HTMLAttributeValueNode
 */
function getAttributeValue(attributeNode) {
    const valueNode = attributeNode.value;
    if (valueNode === null)
        return null;
    if (valueNode.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE" || !valueNode.children?.length) {
        return null;
    }
    let result = "";
    for (const child of valueNode.children) {
        switch (child.type) {
            case "AST_ERB_CONTENT_NODE": {
                const erbNode = child;
                if (erbNode.content) {
                    result += `${erbNode.tag_opening?.value}${erbNode.content.value}${erbNode.tag_closing?.value}`;
                }
                break;
            }
            case "AST_LITERAL_NODE": {
                result += child.content;
                break;
            }
        }
    }
    return result;
}
/**
 * Checks if an attribute has a value
 */
function hasAttributeValue(attributeNode) {
    return attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE";
}
/**
 * Gets the quote type used for an attribute value
 */
function getAttributeValueQuoteType(nodeOrAttribute) {
    let valueNode;
    if (nodeOrAttribute.type === "AST_HTML_ATTRIBUTE_NODE") {
        const attributeNode = nodeOrAttribute;
        if (attributeNode.value?.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
            valueNode = attributeNode.value;
        }
    }
    else if (nodeOrAttribute.type === "AST_HTML_ATTRIBUTE_VALUE_NODE") {
        valueNode = nodeOrAttribute;
    }
    if (valueNode) {
        if (valueNode.quoted && valueNode.open_quote) {
            return valueNode.open_quote.value === '"' ? "double" : "single";
        }
        return "none";
    }
    return null;
}
/**
 * Finds an attribute by name in a list of attributes
 */
function findAttributeByName(attributes, attributeName) {
    for (const child of attributes) {
        if (child.type === "AST_HTML_ATTRIBUTE_NODE") {
            const attributeNode = child;
            const name = getAttributeName(attributeNode);
            if (name === attributeName.toLowerCase()) {
                return attributeNode;
            }
        }
    }
    return null;
}
/**
 * Checks if a tag has a specific attribute
 */
function hasAttribute(node, attributeName) {
    return getAttribute(node, attributeName) !== null;
}
/**
 * Checks if a tag has a specific attribute
 */
function getAttribute(node, attributeName) {
    const attributes = getAttributes(node);
    return findAttributeByName(attributes, attributeName);
}
const HTML_VOID_ELEMENTS = new Set([
    "area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta",
    "param", "source", "track", "wbr",
]);
const HTML_BOOLEAN_ATTRIBUTES = new Set([
    "autofocus", "autoplay", "checked", "controls", "defer", "disabled", "hidden",
    "loop", "multiple", "muted", "readonly", "required", "reversed", "selected",
    "open", "default", "formnovalidate", "novalidate", "itemscope", "scoped",
    "seamless", "allowfullscreen", "async", "compact", "declare", "nohref",
    "noresize", "noshade", "nowrap", "sortable", "truespeed", "typemustmatch"
]);
const HEADING_TAGS = new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
/**
 * SVG elements that use camelCase naming
 */
const SVG_CAMEL_CASE_ELEMENTS = new Set([
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
]);
/**
 * Mapping from lowercase SVG element names to their correct camelCase versions
 * Generated dynamically from SVG_CAMEL_CASE_ELEMENTS
 */
const SVG_LOWERCASE_TO_CAMELCASE = new Map(Array.from(SVG_CAMEL_CASE_ELEMENTS).map(element => [element.toLowerCase(), element]));
const VALID_ARIA_ROLES = new Set([
    "banner", "complementary", "contentinfo", "form", "main", "navigation", "region", "search",
    "article", "cell", "columnheader", "definition", "directory", "document", "feed", "figure",
    "group", "heading", "img", "list", "listitem", "math", "none", "note", "presentation",
    "row", "rowgroup", "rowheader", "separator", "table", "term", "tooltip",
    "alert", "alertdialog", "button", "checkbox", "combobox", "dialog", "grid", "gridcell", "link",
    "listbox", "menu", "menubar", "menuitem", "menuitemcheckbox", "menuitemradio", "option",
    "progressbar", "radio", "radiogroup", "scrollbar", "searchbox", "slider", "spinbutton",
    "status", "switch", "tab", "tablist", "tabpanel", "textbox", "timer", "toolbar", "tree",
    "treegrid", "treeitem",
    "log", "marquee"
]);
const ARIA_ATTRIBUTES = new Set([
    'aria-activedescendant',
    'aria-atomic',
    'aria-autocomplete',
    'aria-busy',
    'aria-checked',
    'aria-colcount',
    'aria-colindex',
    'aria-colspan',
    'aria-controls',
    'aria-current',
    'aria-describedby',
    'aria-details',
    'aria-disabled',
    'aria-dropeffect',
    'aria-errormessage',
    'aria-expanded',
    'aria-flowto',
    'aria-grabbed',
    'aria-haspopup',
    'aria-hidden',
    'aria-invalid',
    'aria-keyshortcuts',
    'aria-label',
    'aria-labelledby',
    'aria-level',
    'aria-live',
    'aria-modal',
    'aria-multiline',
    'aria-multiselectable',
    'aria-orientation',
    'aria-owns',
    'aria-placeholder',
    'aria-posinset',
    'aria-pressed',
    'aria-readonly',
    'aria-relevant',
    'aria-required',
    'aria-roledescription',
    'aria-rowcount',
    'aria-rowindex',
    'aria-rowspan',
    'aria-selected',
    'aria-setsize',
    'aria-sort',
    'aria-valuemax',
    'aria-valuemin',
    'aria-valuenow',
    'aria-valuetext',
]);
/**
 * Helper function to create a location at the end of the source with a 1-character range
 */
function createEndOfFileLocation(source) {
    const lines = source.split('\n');
    const lastLineNumber = lines.length;
    const lastLine = lines[lines.length - 1];
    const lastColumnNumber = lastLine.length;
    const startColumn = lastColumnNumber > 0 ? lastColumnNumber - 1 : 0;
    const start = new Position(lastLineNumber, startColumn);
    const end = new Position(lastLineNumber, lastColumnNumber);
    return new Location(start, end);
}
/**
 * Checks if an element is a void element
 */
function isVoidElement(tagName) {
    return HTML_VOID_ELEMENTS.has(tagName.toLowerCase());
}
/**
 * Checks if an attribute is a boolean attribute
 */
function isBooleanAttribute(attributeName) {
    return HTML_BOOLEAN_ATTRIBUTES.has(attributeName.toLowerCase());
}
/**
 * Attribute visitor that provides granular processing based on both
 * attribute name type (static/dynamic) and value type (static/dynamic)
 *
 * This gives you 4 distinct methods to override:
 * - checkStaticAttributeStaticValue()   - name="class" value="foo"
 * - checkStaticAttributeDynamicValue()  - name="class" value="<%= css_class %>"
 * - checkDynamicAttributeStaticValue()  - name="data-<%= key %>" value="foo"
 * - checkDynamicAttributeDynamicValue() - name="data-<%= key %>" value="<%= value %>"
 */
class AttributeVisitorMixin extends BaseRuleVisitor {
    constructor(ruleName, context) {
        super(ruleName, context);
    }
    visitHTMLOpenTagNode(node) {
        this.checkAttributesOnNode(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkAttributesOnNode(node) {
        forEachAttribute(node, (attributeNode) => {
            const staticAttributeName = getAttributeName(attributeNode);
            const originalAttributeName = getAttributeName(attributeNode, false) || "";
            const isDynamicName = hasDynamicAttributeName(attributeNode);
            const staticAttributeValue = getStaticAttributeValue(attributeNode);
            const valueNodes = getAttributeValueNodes(attributeNode);
            const hasOutputERB = hasERBOutput(valueNodes);
            const isEffectivelyStaticValue = isEffectivelyStatic(valueNodes);
            if (staticAttributeName && staticAttributeValue !== null) {
                this.checkStaticAttributeStaticValue({
                    attributeName: staticAttributeName,
                    attributeValue: staticAttributeValue,
                    attributeNode,
                    originalAttributeName,
                    parentNode: node
                });
            }
            else if (staticAttributeName && isEffectivelyStaticValue && !hasOutputERB) {
                const validatableContent = getValidatableStaticContent(valueNodes) || "";
                this.checkStaticAttributeStaticValue({ attributeName: staticAttributeName, attributeValue: validatableContent, attributeNode, originalAttributeName, parentNode: node });
            }
            else if (staticAttributeName && hasOutputERB) {
                const combinedValue = getAttributeValue(attributeNode);
                this.checkStaticAttributeDynamicValue({ attributeName: staticAttributeName, valueNodes, attributeNode, parentNode: node, originalAttributeName, combinedValue });
            }
            else if (isDynamicName && staticAttributeValue !== null) {
                const nameNode = attributeNode.name;
                const nameNodes = nameNode.children || [];
                const combinedName = getCombinedAttributeNameString(attributeNode);
                this.checkDynamicAttributeStaticValue({ nameNodes, attributeValue: staticAttributeValue, attributeNode, parentNode: node, combinedName });
            }
            else if (isDynamicName) {
                const nameNode = attributeNode.name;
                const nameNodes = nameNode.children || [];
                const combinedName = getCombinedAttributeNameString(attributeNode);
                const combinedValue = getAttributeValue(attributeNode);
                this.checkDynamicAttributeDynamicValue({ nameNodes, valueNodes, attributeNode, parentNode: node, combinedName, combinedValue });
            }
        });
    }
    /**
     * Static attribute name with static value: class="container"
     */
    checkStaticAttributeStaticValue(_params) {
        // Default implementation does nothing
    }
    /**
     * Static attribute name with dynamic value: class="<%= css_class %>"
     */
    checkStaticAttributeDynamicValue(_params) {
        // Default implementation does nothing
    }
    /**
     * Dynamic attribute name with static value: data-<%= key %>="foo"
     */
    checkDynamicAttributeStaticValue(_params) {
        // Default implementation does nothing
    }
    /**
     * Dynamic attribute name with dynamic value: data-<%= key %>="<%= value %>"
     */
    checkDynamicAttributeDynamicValue(_params) {
        // Default implementation does nothing
    }
}
/**
 * Iterates over all attributes of a tag node, calling the callback for each attribute
 */
function forEachAttribute(node, callback) {
    const attributes = getAttributes(node);
    for (const child of attributes) {
        if (child.type === "AST_HTML_ATTRIBUTE_NODE") {
            callback(child);
        }
    }
}
/**
 * Base source visitor class that provides common functionality for source-based rule visitors
 */
class BaseSourceRuleVisitor {
    offenses = [];
    ruleName;
    context;
    constructor(ruleName, context) {
        this.ruleName = ruleName;
        this.context = { ...DEFAULT_LINT_CONTEXT, ...context };
    }
    /**
     * Helper method to create a lint offense for source rules
     */
    createOffense(message, location, severity = "error") {
        return {
            rule: this.ruleName,
            code: this.ruleName,
            source: "Herb Linter",
            message,
            location,
            severity,
        };
    }
    /**
     * Helper method to add an offense to the offenses array
     */
    addOffense(message, location, severity = "error") {
        this.offenses.push(this.createOffense(message, location, severity));
    }
    /**
     * Main entry point for source rule visitors
     * @param source - The raw source code
     */
    visit(source) {
        this.visitSource(source);
    }
    /**
     * Helper method to create a location for a specific position in the source
     */
    createLocationAt(source, position) {
        const beforePosition = source.substring(0, position);
        const lines = beforePosition.split('\n');
        const line = lines.length;
        const column = lines[lines.length - 1].length + 1;
        const start = new Position(line, column);
        const end = new Position(line, column);
        return new Location(start, end);
    }
}

class ERBCommentSyntaxVisitor extends BaseRuleVisitor {
    visitERBContentNode(node) {
        if (node.content?.value.startsWith(" #")) {
            const openingTag = node.tag_opening?.value;
            this.addOffense(`Use \`<%#\` instead of \`${openingTag} #\`. Ruby comments immediately after ERB tags can cause parsing issues.`, node.location);
        }
    }
}
class ERBCommentSyntax extends ParserRule {
    name = "erb-comment-syntax";
    check(result, context) {
        const visitor = new ERBCommentSyntaxVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBNoEmptyTagsVisitor extends BaseRuleVisitor {
    visitERBContentNode(node) {
        this.visitChildNodes(node);
        const { content, tag_closing } = node;
        if (!content)
            return;
        if (tag_closing?.value === "")
            return;
        if (content.value.trim().length > 0)
            return;
        this.addOffense("ERB tag should not be empty. Remove empty ERB tags or add content.", node.location, "error");
    }
}
class ERBNoEmptyTagsRule extends ParserRule {
    name = "erb-no-empty-tags";
    check(result, context) {
        const visitor = new ERBNoEmptyTagsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBNoOutputControlFlowRuleVisitor extends BaseRuleVisitor {
    visitERBIfNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBUnlessNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBElseNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    visitERBEndNode(node) {
        this.checkOutputControlFlow(node);
        this.visitChildNodes(node);
    }
    checkOutputControlFlow(controlBlock) {
        const openTag = controlBlock.tag_opening;
        if (!openTag) {
            return;
        }
        if (openTag.value === "<%=") {
            let controlBlockType = controlBlock.type;
            if (controlBlock.type === "AST_ERB_IF_NODE")
                controlBlockType = "if";
            if (controlBlock.type === "AST_ERB_ELSE_NODE")
                controlBlockType = "else";
            if (controlBlock.type === "AST_ERB_END_NODE")
                controlBlockType = "end";
            if (controlBlock.type === "AST_ERB_UNLESS_NODE")
                controlBlockType = "unless";
            this.addOffense(`Control flow statements like \`${controlBlockType}\` should not be used with output tags. Use \`<% ${controlBlockType} ... %>\` instead.`, openTag.location, "error");
        }
        return;
    }
}
class ERBNoOutputControlFlowRule extends ParserRule {
    name = "erb-no-output-control-flow";
    check(result, context) {
        const visitor = new ERBNoOutputControlFlowRuleVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBNoSilentTagInAttributeNameVisitor extends BaseRuleVisitor {
    visitHTMLAttributeNameNode(node) {
        const erbNodes = filterERBContentNodes(node.children);
        const silentNodes = erbNodes.filter(this.isSilentERBTag);
        for (const node of silentNodes) {
            this.addOffense(`Remove silent ERB tag from HTML attribute name. Silent ERB tags (\`${node.tag_opening?.value}\`) do not output content and should not be used in attribute names.`, node.location, "error");
        }
    }
    // TODO: might be worth to extract
    isSilentERBTag(node) {
        const silentTags = ["<%", "<%-", "<%#"];
        return silentTags.includes(node.tag_opening?.value || "");
    }
}
class ERBNoSilentTagInAttributeNameRule extends ParserRule {
    name = "erb-no-silent-tag-in-attribute-name";
    check(result, context) {
        const visitor = new ERBNoSilentTagInAttributeNameVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class PrintContext {
    output = "";
    indentLevel = 0;
    currentColumn = 0;
    preserveStack = [];
    /**
     * Write text to the output
     */
    write(text) {
        this.output += text;
        this.currentColumn += text.length;
    }
    /**
     * Write text and update column tracking for newlines
     */
    writeWithColumnTracking(text) {
        this.output += text;
        const lines = text.split('\n');
        if (lines.length > 1) {
            this.currentColumn = lines[lines.length - 1].length;
        }
        else {
            this.currentColumn += text.length;
        }
    }
    /**
     * Increase indentation level
     */
    indent() {
        this.indentLevel++;
    }
    /**
     * Decrease indentation level
     */
    dedent() {
        if (this.indentLevel > 0) {
            this.indentLevel--;
        }
    }
    /**
     * Enter a tag that may preserve whitespace
     */
    enterTag(tagName) {
        this.preserveStack.push(tagName.toLowerCase());
    }
    /**
     * Exit the current tag
     */
    exitTag() {
        this.preserveStack.pop();
    }
    /**
     * Check if we're at the start of a line
     */
    isAtStartOfLine() {
        return this.currentColumn === 0;
    }
    /**
     * Get current indentation level
     */
    getCurrentIndentLevel() {
        return this.indentLevel;
    }
    /**
     * Get current column position
     */
    getCurrentColumn() {
        return this.currentColumn;
    }
    /**
     * Get the current tag stack (for debugging)
     */
    getTagStack() {
        return [...this.preserveStack];
    }
    /**
     * Get the complete output string
     */
    getOutput() {
        return this.output;
    }
    /**
     * Reset the context for reuse
     */
    reset() {
        this.output = "";
        this.indentLevel = 0;
        this.currentColumn = 0;
        this.preserveStack = [];
    }
}

/**
 * Default print options used when none are provided
 */
const DEFAULT_PRINT_OPTIONS = {
    ignoreErrors: false
};
class Printer extends Visitor {
    context = new PrintContext();
    /**
     * Static method to print a node without creating an instance
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    static print(input, options = DEFAULT_PRINT_OPTIONS) {
        const printer = new this();
        return printer.print(input, options);
    }
    /**
     * Print a node, token, or parse result to a string
     *
     * @param input - The AST Node, Token, or ParseResult to print
     * @param options - Print options to control behavior
     * @returns The printed string representation of the input
     * @throws {Error} When node has parse errors and ignoreErrors is false
     */
    print(input, options = DEFAULT_PRINT_OPTIONS) {
        if (!input)
            return "";
        if (isToken(input)) {
            return input.value;
        }
        if (Array.isArray(input)) {
            this.context.reset();
            input.forEach(node => this.visit(node));
            return this.context.getOutput();
        }
        const node = isParseResult(input) ? input.value : input;
        if (options.ignoreErrors === false && node.recursiveErrors().length > 0) {
            throw new Error(`Cannot print the node (${node.type}) since it or any of its children has parse errors. Either pass in a valid Node or call \`print()\` using \`print(node, { ignoreErrors: true })\``);
        }
        this.context.reset();
        this.visit(node);
        return this.context.getOutput();
    }
    write(content) {
        this.context.write(content);
    }
}

/**
 * IdentityPrinter - Provides lossless reconstruction of the original source
 *
 * This printer aims to reconstruct the original input as faithfully as possible,
 * preserving all whitespace, formatting, and structure. It's useful for:
 * - Testing parser accuracy (input should equal output)
 * - Baseline printing before applying transformations
 * - Verifying AST round-trip fidelity
 */
class IdentityPrinter extends Printer {
    visitLiteralNode(node) {
        this.write(node.content);
    }
    visitHTMLTextNode(node) {
        this.write(node.content);
    }
    visitWhitespaceNode(node) {
        if (node.value) {
            this.write(node.value.value);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            this.write(node.tag_name.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLCloseTagNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.tag_name) {
            const before = getNodesBeforePosition(node.children, node.tag_name.location.start, true);
            const after = getNodesAfterPosition(node.children, node.tag_name.location.end);
            this.visitAll(before);
            this.write(node.tag_name.value);
            this.visitAll(after);
        }
        else {
            this.visitAll(node.children);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName) {
            this.context.enterTag(tagName);
        }
        if (node.open_tag) {
            this.visit(node.open_tag);
        }
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.close_tag) {
            this.visit(node.close_tag);
        }
        if (tagName) {
            this.context.exitTag();
        }
    }
    visitHTMLAttributeNode(node) {
        if (node.name) {
            this.visit(node.name);
        }
        if (node.equals) {
            this.write(node.equals.value);
        }
        if (node.equals && node.value) {
            this.visit(node.value);
        }
    }
    visitHTMLAttributeNameNode(node) {
        this.visitChildNodes(node);
    }
    visitHTMLAttributeValueNode(node) {
        if (node.quoted && node.open_quote) {
            this.write(node.open_quote.value);
        }
        this.visitChildNodes(node);
        if (node.quoted && node.close_quote) {
            this.write(node.close_quote.value);
        }
    }
    visitHTMLCommentNode(node) {
        if (node.comment_start) {
            this.write(node.comment_start.value);
        }
        this.visitChildNodes(node);
        if (node.comment_end) {
            this.write(node.comment_end.value);
        }
    }
    visitHTMLDoctypeNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitXMLDeclarationNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitCDATANode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        this.visitChildNodes(node);
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
    visitERBContentNode(node) {
        this.printERBNode(node);
    }
    visitERBIfNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBElseNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBEndNode(node) {
        this.printERBNode(node);
    }
    visitERBBlockNode(node) {
        this.printERBNode(node);
        if (node.body) {
            node.body.forEach(child => this.visit(child));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBCaseNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBWhenNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBWhileNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBUntilNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBForNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBBeginNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.rescue_clause) {
            this.visit(node.rescue_clause);
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.ensure_clause) {
            this.visit(node.ensure_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBRescueNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.subsequent) {
            this.visit(node.subsequent);
        }
    }
    visitERBEnsureNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBUnlessNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    visitERBYieldNode(node) {
        this.printERBNode(node);
    }
    visitERBInNode(node) {
        this.printERBNode(node);
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
    }
    visitERBCaseMatchNode(node) {
        this.printERBNode(node);
        if (node.children) {
            node.children.forEach(child => this.visit(child));
        }
        if (node.conditions) {
            node.conditions.forEach(condition => this.visit(condition));
        }
        if (node.else_clause) {
            this.visit(node.else_clause);
        }
        if (node.end_node) {
            this.visit(node.end_node);
        }
    }
    /**
     * Print ERB node tags and content
     */
    printERBNode(node) {
        if (node.tag_opening) {
            this.write(node.tag_opening.value);
        }
        if (node.content) {
            this.write(node.content.value);
        }
        if (node.tag_closing) {
            this.write(node.tag_closing.value);
        }
    }
}

const DEFAULT_ERB_TO_RUBY_STRING_OPTIONS = {
    ...DEFAULT_PRINT_OPTIONS,
    forceQuotes: false
};
/**
 * ERBToRubyStringPrinter - Converts ERB snippets to Ruby strings with interpolation
 *
 * This printer transforms ERB templates into Ruby strings by:
 * - Converting literal text to string content
 * - Converting <%= %> tags to #{} interpolation
 * - Converting simple if/else blocks to ternary operators
 * - Ignoring <% %> tags (they don't produce output)
 *
 * Examples:
 * - `hello world <%= hello %>` => `"hello world #{hello}"`
 * - `hello world <% hello %>` => `"hello world "`
 * - `Welcome <%= user.name %>!` => `"Welcome #{user.name}!"`
 * - `<% if logged_in? %>Welcome<% else %>Login<% end %>` => `"logged_in? ? "Welcome" : "Login"`
 * - `<% if logged_in? %>Welcome<% else %>Login<% end %>!` => `"#{logged_in? ? "Welcome" : "Login"}!"`
 */
class ERBToRubyStringPrinter extends IdentityPrinter {
    // TODO: cleanup `.type === "AST_*" checks`
    static print(node, options = DEFAULT_ERB_TO_RUBY_STRING_OPTIONS) {
        const erbNodes = filterNodes([node], ERBContentNode);
        if (erbNodes.length === 1 && isERBOutputNode(erbNodes[0]) && !options.forceQuotes) {
            return (erbNodes[0].content?.value || "").trim();
        }
        if ('children' in node && Array.isArray(node.children)) {
            const childErbNodes = filterNodes(node.children, ERBContentNode);
            const hasOnlyERBContent = node.children.length > 0 && node.children.length === childErbNodes.length;
            if (hasOnlyERBContent && childErbNodes.length === 1 && isERBOutputNode(childErbNodes[0]) && !options.forceQuotes) {
                return (childErbNodes[0].content?.value || "").trim();
            }
            if (node.children.length === 1 && node.children[0].type === "AST_ERB_IF_NODE" && !options.forceQuotes) {
                const ifNode = node.children[0];
                const printer = new ERBToRubyStringPrinter();
                if (printer.canConvertToTernary(ifNode)) {
                    printer.convertToTernaryWithoutWrapper(ifNode);
                    return printer.context.getOutput();
                }
            }
            if (node.children.length === 1 && node.children[0].type === "AST_ERB_UNLESS_NODE" && !options.forceQuotes) {
                const unlessNode = node.children[0];
                const printer = new ERBToRubyStringPrinter();
                if (printer.canConvertUnlessToTernary(unlessNode)) {
                    printer.convertUnlessToTernaryWithoutWrapper(unlessNode);
                    return printer.context.getOutput();
                }
            }
        }
        const printer = new ERBToRubyStringPrinter();
        printer.context.write('"');
        printer.visit(node);
        printer.context.write('"');
        return printer.context.getOutput();
    }
    visitHTMLTextNode(node) {
        if (node.content) {
            const escapedContent = node.content.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
            this.context.write(escapedContent);
        }
    }
    visitERBContentNode(node) {
        if (isERBOutputNode(node)) {
            this.context.write("#{");
            if (node.content?.value) {
                this.context.write(node.content.value.trim());
            }
            this.context.write("}");
        }
    }
    visitERBIfNode(node) {
        if (this.canConvertToTernary(node)) {
            this.convertToTernary(node);
        }
    }
    visitERBUnlessNode(node) {
        if (this.canConvertUnlessToTernary(node)) {
            this.convertUnlessToTernary(node);
        }
    }
    visitHTMLAttributeValueNode(node) {
        this.visitChildNodes(node);
    }
    canConvertToTernary(node) {
        if (node.subsequent && node.subsequent.type !== "AST_ERB_ELSE_NODE") {
            return false;
        }
        const ifOnlyText = node.statements ? node.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE") : true;
        if (!ifOnlyText)
            return false;
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE") {
            return node.subsequent.statements
                ? node.subsequent.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE")
                : true;
        }
        return true;
    }
    convertToTernary(node) {
        this.context.write("#{");
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^if\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE" && node.subsequent.statements) {
            node.subsequent.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write("}");
    }
    convertToTernaryWithoutWrapper(node) {
        if (node.subsequent && node.subsequent.type !== "AST_ERB_ELSE_NODE") {
            return false;
        }
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^if\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.subsequent && node.subsequent.type === "AST_ERB_ELSE_NODE" && node.subsequent.statements) {
            node.subsequent.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
    }
    canConvertUnlessToTernary(node) {
        const unlessOnlyText = node.statements ? node.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE") : true;
        if (!unlessOnlyText)
            return false;
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            return node.else_clause.statements
                ? node.else_clause.statements.every(statement => statement.type === "AST_HTML_TEXT_NODE")
                : true;
        }
        return true;
    }
    convertUnlessToTernary(node) {
        this.context.write("#{");
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^unless\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            this.context.write("!(");
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
            this.context.write(")");
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            node.else_clause.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write("}");
    }
    convertUnlessToTernaryWithoutWrapper(node) {
        if (node.content?.value) {
            const condition = node.content.value.trim();
            const cleanCondition = condition.replace(/^unless\s+/, '');
            const needsParentheses = cleanCondition.includes(' ');
            this.context.write("!(");
            if (needsParentheses) {
                this.context.write("(");
            }
            this.context.write(cleanCondition);
            if (needsParentheses) {
                this.context.write(")");
            }
            this.context.write(")");
        }
        this.context.write(" ? ");
        this.context.write('"');
        if (node.statements) {
            node.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
        this.context.write(" : ");
        this.context.write('"');
        if (node.else_clause && node.else_clause.type === "AST_ERB_ELSE_NODE") {
            node.else_clause.statements.forEach(statement => this.visit(statement));
        }
        this.context.write('"');
    }
}

class ERBPreferImageTagHelperVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkImgTag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkImgTag(openTag) {
        const tagName = getTagName(openTag);
        if (tagName !== "img")
            return;
        const attributes = getAttributes(openTag);
        const srcAttribute = findAttributeByName(attributes, "src");
        if (!srcAttribute)
            return;
        if (!srcAttribute.value)
            return;
        const node = srcAttribute.value;
        const hasERBContent = this.containsERBContent(node);
        if (hasERBContent) {
            if (this.isDataUri(node))
                return;
            if (this.shouldFlagAsImageTagCandidate(node)) {
                const suggestedExpression = this.buildSuggestedExpression(node);
                this.addOffense(`Prefer \`image_tag\` helper over manual \`<img>\` with dynamic ERB expressions. Use \`<%= image_tag ${suggestedExpression}, alt: "..." %>\` instead.`, srcAttribute.location, "warning");
            }
        }
    }
    containsERBContent(node) {
        return filterNodes(node.children, ERBContentNode).length > 0;
    }
    isOnlyERBContent(node) {
        return node.children.length > 0 && node.children.length === filterNodes(node.children, ERBContentNode).length;
    }
    getContentofFirstChild(node) {
        if (!node.children || node.children.length === 0)
            return "";
        const firstChild = node.children[0];
        if (isNode(firstChild, LiteralNode)) {
            return (firstChild.content || "").trim();
        }
        return "";
    }
    isDataUri(node) {
        return this.getContentofFirstChild(node).startsWith("data:");
    }
    isFullUrl(node) {
        const content = this.getContentofFirstChild(node);
        return content.startsWith("http://") || content.startsWith("https://");
    }
    shouldFlagAsImageTagCandidate(node) {
        if (this.isOnlyERBContent(node))
            return true;
        if (this.isFullUrl(node))
            return false;
        return true;
    }
    buildSuggestedExpression(node) {
        if (!node.children)
            return "expression";
        try {
            return ERBToRubyStringPrinter.print(node, { ignoreErrors: false });
        }
        catch {
            return "expression";
        }
    }
}
class ERBPreferImageTagHelperRule extends ParserRule {
    name = "erb-prefer-image-tag-helper";
    check(result, context) {
        const visitor = new ERBPreferImageTagHelperVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBRequiresTrailingNewlineVisitor extends BaseSourceRuleVisitor {
    visitSource(source) {
        if (source.length === 0)
            return;
        if (source.endsWith('\n'))
            return;
        if (!this.context.fileName)
            return;
        this.addOffense("File must end with trailing newline", createEndOfFileLocation(source), "error");
    }
}
class ERBRequiresTrailingNewlineRule extends SourceRule {
    name = "erb-requires-trailing-newline";
    check(source, context) {
        const visitor = new ERBRequiresTrailingNewlineVisitor(this.name, context);
        visitor.visit(source);
        return visitor.offenses;
    }
}

class RequireWhitespaceInsideTags extends BaseRuleVisitor {
    visitERBNode(node) {
        const openTag = node.tag_opening;
        const closeTag = node.tag_closing;
        const content = node.content;
        if (!openTag || !closeTag || !content) {
            return;
        }
        const value = content.value;
        if (openTag.value === "<%#") {
            this.checkCommentTagWhitespace(openTag, closeTag, value);
        }
        else {
            this.checkOpenTagWhitespace(openTag, value);
            this.checkCloseTagWhitespace(closeTag, value);
        }
    }
    checkCommentTagWhitespace(openTag, closeTag, content) {
        if (!content.startsWith(" ") && !content.startsWith("\n") && !content.startsWith("=")) {
            this.addOffense(`Add whitespace after \`${openTag.value}\`.`, openTag.location, "error");
        }
        else if (content.startsWith("=") && content.length > 1 && !content[1].match(/\s/)) {
            this.addOffense(`Add whitespace after \`<%#=\`.`, openTag.location, "error");
        }
        if (!content.endsWith(" ") && !content.endsWith("\n")) {
            this.addOffense(`Add whitespace before \`${closeTag.value}\`.`, closeTag.location, "error");
        }
    }
    checkOpenTagWhitespace(openTag, content) {
        if (content.startsWith(" ") || content.startsWith("\n")) {
            return;
        }
        this.addOffense(`Add whitespace after \`${openTag.value}\`.`, openTag.location, "error");
    }
    checkCloseTagWhitespace(closeTag, content) {
        if (content.endsWith(" ") || content.endsWith("\n")) {
            return;
        }
        this.addOffense(`Add whitespace before \`${closeTag.value}\`.`, closeTag.location, "error");
    }
}
class ERBRequireWhitespaceRule extends ParserRule {
    name = "erb-require-whitespace-inside-tags";
    check(result, context) {
        const visitor = new RequireWhitespaceInsideTags(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AnchorRechireHrefVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkATag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkATag(node) {
        const tagName = getTagName(node);
        if (tagName !== "a") {
            return;
        }
        if (!hasAttribute(node, "href")) {
            this.addOffense("Add an `href` attribute to `<a>` to ensure it is focusable and accessible.", node.tag_name.location, "error");
        }
    }
}
class HTMLAnchorRequireHrefRule extends ParserRule {
    name = "html-anchor-require-href";
    check(result, context) {
        const visitor = new AnchorRechireHrefVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaAttributeMustBeValid extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    check(attributeName, attributeNode) {
        if (!attributeName.startsWith("aria-"))
            return;
        if (ARIA_ATTRIBUTES.has(attributeName))
            return;
        this.addOffense(`The attribute \`${attributeName}\` is not a valid ARIA attribute. ARIA attributes must match the WAI-ARIA specification.`, attributeNode.location, "error");
    }
}
class HTMLAriaAttributeMustBeValid extends ParserRule {
    name = "html-aria-attribute-must-be-valid";
    check(result, context) {
        const visitor = new AriaAttributeMustBeValid(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaLabelIsWellFormattedVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "aria-label")
            return;
        if (attributeValue.match(/[\r\n]+/) || attributeValue.match(/&#10;|&#13;|&#x0A;|&#x0D;/i)) {
            this.addOffense("The `aria-label` attribute value text should not contain line breaks. Use concise, single-line descriptions.", attributeNode.location, "error");
            return;
        }
        if (this.looksLikeId(attributeValue)) {
            this.addOffense("The `aria-label` attribute value should not be formatted like an ID. Use natural, sentence-case text instead.", attributeNode.location, "error");
            return;
        }
        if (attributeValue.match(/^[a-z]/)) {
            this.addOffense("The `aria-label` attribute value text should be formatted like visual text. Use sentence case (capitalize the first letter).", attributeNode.location, "error");
        }
    }
    looksLikeId(text) {
        return (text.includes('_') ||
            text.includes('-') ||
            /^[a-z]+([A-Z][a-z]*)*$/.test(text)) && !text.includes(' ');
    }
}
class HTMLAriaLabelIsWellFormattedRule extends ParserRule {
    name = "html-aria-label-is-well-formatted";
    check(result, context) {
        const visitor = new AriaLabelIsWellFormattedVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLAriaLevelMustBeValidVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "aria-level")
            return;
        this.validateAriaLevel(attributeValue, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, valueNodes, attributeNode }) {
        if (attributeName !== "aria-level")
            return;
        const validatableContent = getValidatableStaticContent(valueNodes);
        if (validatableContent !== null) {
            this.validateAriaLevel(validatableContent, attributeNode);
            return;
        }
        if (!hasERBOutput(valueNodes))
            return;
        const literalNodes = filterLiteralNodes(valueNodes);
        const erbOutputNodes = filterERBContentNodes(valueNodes).filter(isERBOutputNode);
        if (literalNodes.length > 0 && erbOutputNodes.length > 0) {
            const staticPart = literalNodes.map(node => node.content).join("");
            // TODO: this can be cleaned up using @herb-tools/printer
            const erbPart = erbOutputNodes[0];
            const erbText = `${erbPart.tag_opening?.value || ""}${erbPart.content?.value || ""}${erbPart.tag_closing?.value || ""}`;
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got \`${staticPart}\` and the ERB expression \`${erbText}\`.`, attributeNode.location);
        }
    }
    validateAriaLevel(attributeValue, attributeNode) {
        if (!attributeValue || attributeValue === "") {
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got an empty value.`, attributeNode.location);
            return;
        }
        const number = parseInt(attributeValue);
        if (isNaN(number) || number < 1 || number > 6 || attributeValue !== number.toString()) {
            this.addOffense(`The \`aria-level\` attribute must be an integer between 1 and 6, got \`${attributeValue}\`.`, attributeNode.location);
        }
    }
}
class HTMLAriaLevelMustBeValidRule extends ParserRule {
    name = "html-aria-level-must-be-valid";
    check(result, context) {
        const visitor = new HTMLAriaLevelMustBeValidVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaRoleHeadingRequiresLevel extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode, parentNode }) {
        if (!(attributeName === "role" && attributeValue === "heading"))
            return;
        const ariaLevelAttributes = getAttributes(parentNode).find(attribute => getAttributeName(attribute) === "aria-level");
        if (ariaLevelAttributes)
            return;
        this.addOffense(`Element with \`role="heading"\` must have an \`aria-level\` attribute.`, attributeNode.location, "error");
    }
}
class HTMLAriaRoleHeadingRequiresLevelRule extends ParserRule {
    name = "html-aria-role-heading-requires-level";
    check(result, context) {
        const visitor = new AriaRoleHeadingRequiresLevel(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AriaRoleMustBeValid extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "role")
            return;
        if (!attributeValue)
            return;
        if (VALID_ARIA_ROLES.has(attributeValue))
            return;
        this.addOffense(`The \`role\` attribute must be a valid ARIA role. Role \`${attributeValue}\` is not recognized.`, attributeNode.location, "error");
    }
}
class HTMLAriaRoleMustBeValidRule extends ParserRule {
    name = "html-aria-role-must-be-valid";
    check(result, context) {
        const visitor = new AriaRoleMustBeValid(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AttributeDoubleQuotesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (!hasAttributeValue(attributeNode))
            return;
        if (getAttributeValueQuoteType(attributeNode) !== "single")
            return;
        if (attributeValue?.includes('"'))
            return;
        this.addOffense(`Attribute \`${attributeName}\` uses single quotes. Prefer double quotes for HTML attribute values: \`${attributeName}="${attributeValue}"\`.`, attributeNode.value.location, "warning");
    }
    checkStaticAttributeDynamicValue({ attributeName, valueNodes, attributeNode, combinedValue }) {
        if (!hasAttributeValue(attributeNode))
            return;
        if (getAttributeValueQuoteType(attributeNode) !== "single")
            return;
        if (filterLiteralNodes(valueNodes).some(node => node.content?.includes('"')))
            return;
        this.addOffense(`Attribute \`${attributeName}\` uses single quotes. Prefer double quotes for HTML attribute values: \`${attributeName}="${combinedValue}"\`.`, attributeNode.value.location, "warning");
    }
}
class HTMLAttributeDoubleQuotesRule extends ParserRule {
    name = "html-attribute-double-quotes";
    check(result, context) {
        const visitor = new AttributeDoubleQuotesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLAttributeEqualsSpacingVisitor extends BaseRuleVisitor {
    visitHTMLAttributeNode(attribute) {
        if (!attribute.equals || !attribute.name || !attribute.value) {
            return;
        }
        if (attribute.equals.value.startsWith(" ")) {
            this.addOffense("Remove whitespace before `=` in HTML attribute", attribute.equals.location, "error");
        }
        if (attribute.equals.value.endsWith(" ")) {
            this.addOffense("Remove whitespace after `=` in HTML attribute", attribute.equals.location, "error");
        }
    }
}
class HTMLAttributeEqualsSpacingRule extends ParserRule {
    name = "html-attribute-equals-spacing";
    check(result, context) {
        const visitor = new HTMLAttributeEqualsSpacingVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class AttributeValuesRequireQuotesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (this.hasAttributeValue(attributeNode))
            return;
        if (this.isQuoted(attributeNode))
            return;
        this.addOffense(`Attribute value should be quoted: \`${attributeName}="${attributeValue}"\`. Always wrap attribute values in quotes.`, attributeNode.value.location, "error");
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode, combinedValue }) {
        if (this.hasAttributeValue(attributeNode))
            return;
        if (this.isQuoted(attributeNode))
            return;
        this.addOffense(`Attribute value should be quoted: \`${attributeName}="${combinedValue}"\`. Always wrap attribute values in quotes.`, attributeNode.value.location, "error");
    }
    hasAttributeValue(attributeNode) {
        return attributeNode.value?.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE";
    }
    isQuoted(attributeNode) {
        const valueNode = attributeNode.value;
        return valueNode.quoted;
    }
}
class HTMLAttributeValuesRequireQuotesRule extends ParserRule {
    name = "html-attribute-values-require-quotes";
    check(result, context) {
        const visitor = new AttributeValuesRequireQuotesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const ELEMENTS_WITH_NATIVE_DISABLED_ATTRIBUTE_SUPPORT = new Set([
    "button", "fieldset", "input", "optgroup", "option", "select", "textarea"
]);
class AvoidBothDisabledAndAriaDisabledVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkElement(node) {
        const tagName = getTagName(node);
        if (!tagName || !ELEMENTS_WITH_NATIVE_DISABLED_ATTRIBUTE_SUPPORT.has(tagName)) {
            return;
        }
        const hasDisabled = hasAttribute(node, "disabled");
        const hasAriaDisabled = hasAttribute(node, "aria-disabled");
        if ((hasDisabled && this.hasERBContent(node, "disabled")) || (hasAriaDisabled && this.hasERBContent(node, "aria-disabled"))) {
            return;
        }
        if (hasDisabled && hasAriaDisabled) {
            this.addOffense("aria-disabled may be used in place of native HTML disabled to allow tab-focus on an otherwise ignored element. Setting both attributes is contradictory and confusing. Choose either disabled or aria-disabled, not both.", node.tag_name.location, "error");
        }
    }
    hasERBContent(node, attributeName) {
        const attributes = getAttributes(node);
        const attribute = findAttributeByName(attributes, attributeName);
        if (!attribute)
            return false;
        const valueNode = attribute.value;
        if (!valueNode || valueNode.type !== "AST_HTML_ATTRIBUTE_VALUE_NODE")
            return false;
        const htmlValueNode = valueNode;
        if (!htmlValueNode.children)
            return false;
        return htmlValueNode.children.some((child) => child.type === "AST_ERB_CONTENT_NODE");
    }
}
class HTMLAvoidBothDisabledAndAriaDisabledRule extends ParserRule {
    name = "html-avoid-both-disabled-and-aria-disabled";
    check(result, context) {
        const visitor = new AvoidBothDisabledAndAriaDisabledVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class BooleanAttributesNoValueVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ originalAttributeName, attributeNode }) {
        this.checkAttribute(originalAttributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ originalAttributeName, attributeNode }) {
        this.checkAttribute(originalAttributeName, attributeNode);
    }
    checkAttribute(attributeName, attributeNode) {
        if (!isBooleanAttribute(attributeName))
            return;
        if (!hasAttributeValue(attributeNode))
            return;
        this.addOffense(`Boolean attribute \`${IdentityPrinter.print(attributeNode.name)}\` should not have a value. Use \`${attributeName.toLowerCase()}\` instead of \`${IdentityPrinter.print(attributeNode)}\`.`, attributeNode.value.location, "error");
    }
}
class HTMLBooleanAttributesNoValueRule extends ParserRule {
    name = "html-boolean-attributes-no-value";
    check(result, context) {
        const visitor = new BooleanAttributesNoValueVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class IframeHasTitleVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkIframeElement(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkIframeElement(node) {
        const tagName = getTagName(node);
        if (tagName !== "iframe") {
            return;
        }
        const ariaHiddenAttribute = getAttribute(node, "aria-hidden");
        if (ariaHiddenAttribute) {
            const ariaHiddenValue = getAttributeValue(ariaHiddenAttribute);
            if (ariaHiddenValue === "true") {
                return;
            }
        }
        const attribute = getAttribute(node, "title");
        if (!attribute) {
            this.addOffense("`<iframe>` elements must have a `title` attribute that describes the content of the frame for screen reader users.", node.location, "error");
            return;
        }
        const value = getAttributeValue(attribute);
        if (!value || value.trim() === "") {
            this.addOffense("`<iframe>` elements must have a `title` attribute that describes the content of the frame for screen reader users.", node.location, "error");
        }
    }
}
class HTMLIframeHasTitleRule extends ParserRule {
    name = "html-iframe-has-title";
    check(result, context) {
        const visitor = new IframeHasTitleVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ImgRequireAltVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkImgTag(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkImgTag(node) {
        const tagName = getTagName(node);
        if (tagName !== "img") {
            return;
        }
        if (!hasAttribute(node, "alt")) {
            this.addOffense('Missing required `alt` attribute on `<img>` tag. Add `alt=""` for decorative images or `alt="description"` for informative images.', node.tag_name.location, "error");
        }
    }
}
class HTMLImgRequireAltRule extends ParserRule {
    name = "html-img-require-alt";
    check(result, context) {
        const visitor = new ImgRequireAltVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const INTERACTIVE_ELEMENTS = new Set([
    "button", "summary", "input", "select", "textarea", "a"
]);
class NoAriaHiddenOnFocusableVisitor extends BaseRuleVisitor {
    visitHTMLOpenTagNode(node) {
        this.checkAriaHiddenOnFocusable(node);
        super.visitHTMLOpenTagNode(node);
    }
    checkAriaHiddenOnFocusable(node) {
        if (!this.hasAriaHiddenTrue(node))
            return;
        if (this.isFocusable(node)) {
            this.addOffense(`Elements that are focusable should not have \`aria-hidden="true"\` because it will cause confusion for assistive technology users.`, node.tag_name.location, "error");
        }
    }
    hasAriaHiddenTrue(node) {
        const attributes = getAttributes(node);
        const ariaHiddenAttr = findAttributeByName(attributes, "aria-hidden");
        if (!ariaHiddenAttr)
            return false;
        const value = getAttributeValue(ariaHiddenAttr);
        return value === "true";
    }
    isFocusable(node) {
        const tagName = getTagName(node);
        if (!tagName)
            return false;
        const tabIndexValue = this.getTabIndexValue(node);
        if (tagName === "a") {
            const hasHref = hasAttribute(node, "href");
            if (!hasHref) {
                return tabIndexValue !== null && tabIndexValue >= 0;
            }
            return tabIndexValue === null || tabIndexValue >= 0;
        }
        if (INTERACTIVE_ELEMENTS.has(tagName)) {
            // Interactive elements are focusable unless tabindex is negative
            return tabIndexValue === null || tabIndexValue >= 0;
        }
        else {
            // Non-interactive elements are focusable only if tabindex >= 0
            return tabIndexValue !== null && tabIndexValue >= 0;
        }
    }
    getTabIndexValue(node) {
        const attributes = getAttributes(node);
        const tabIndexAttribute = findAttributeByName(attributes, "tabindex");
        if (!tabIndexAttribute)
            return null;
        const value = getAttributeValue(tabIndexAttribute);
        if (!value)
            return null;
        const parsed = parseInt(value, 10);
        return isNaN(parsed) ? null : parsed;
    }
}
class HTMLNoAriaHiddenOnFocusableRule extends ParserRule {
    name = "html-no-aria-hidden-on-focusable";
    check(result, context) {
        const visitor = new NoAriaHiddenOnFocusableVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoDuplicateAttributesVisitor extends AttributeVisitorMixin {
    attributeNames = new Map();
    visitHTMLOpenTagNode(node) {
        this.attributeNames.clear();
        super.visitHTMLOpenTagNode(node);
        this.reportDuplicates();
    }
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.trackAttributeName(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.trackAttributeName(attributeName, attributeNode);
    }
    trackAttributeName(attributeName, attributeNode) {
        if (!this.attributeNames.has(attributeName)) {
            this.attributeNames.set(attributeName, []);
        }
        this.attributeNames.get(attributeName).push(attributeNode);
    }
    reportDuplicates() {
        for (const [attributeName, attributeNodes] of this.attributeNames) {
            if (attributeNodes.length > 1) {
                for (let i = 1; i < attributeNodes.length; i++) {
                    const attributeNode = attributeNodes[i];
                    this.addOffense(`Duplicate attribute \`${attributeName}\` found on tag. Remove the duplicate occurrence.`, attributeNode.name.location, "error");
                }
            }
        }
    }
}
class HTMLNoDuplicateAttributesRule extends ParserRule {
    name = "html-no-duplicate-attributes";
    check(result, context) {
        const visitor = new NoDuplicateAttributesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class OutputPrinter extends Printer {
    visitLiteralNode(node) {
        this.write(IdentityPrinter.print(node));
    }
    visitERBContentNode(node) {
        if (isERBOutputNode(node)) {
            this.write(IdentityPrinter.print(node));
        }
    }
}
class NoDuplicateIdsVisitor extends ControlFlowTrackingVisitor {
    documentIds = new Set();
    currentBranchIds = new Set();
    controlFlowIds = new Set();
    visitHTMLAttributeNode(node) {
        this.checkAttribute(node);
    }
    onEnterControlFlow(_controlFlowType, wasAlreadyInControlFlow) {
        const stateToRestore = {
            previousBranchIds: this.currentBranchIds,
            previousControlFlowIds: this.controlFlowIds
        };
        this.currentBranchIds = new Set();
        if (!wasAlreadyInControlFlow) {
            this.controlFlowIds = new Set();
        }
        return stateToRestore;
    }
    onExitControlFlow(controlFlowType, wasAlreadyInControlFlow, stateToRestore) {
        if (controlFlowType === ControlFlowType.CONDITIONAL && !wasAlreadyInControlFlow) {
            this.controlFlowIds.forEach(id => this.documentIds.add(id));
        }
        this.currentBranchIds = stateToRestore.previousBranchIds;
        this.controlFlowIds = stateToRestore.previousControlFlowIds;
    }
    onEnterBranch() {
        const stateToRestore = {
            previousBranchIds: this.currentBranchIds
        };
        if (this.isInControlFlow) {
            this.currentBranchIds = new Set();
        }
        return stateToRestore;
    }
    onExitBranch(_stateToRestore) { }
    checkAttribute(attributeNode) {
        if (!this.isIdAttribute(attributeNode))
            return;
        const idValue = this.extractIdValue(attributeNode);
        if (!idValue)
            return;
        if (this.isWhitespaceOnlyId(idValue.identifier))
            return;
        this.processIdDuplicate(idValue, attributeNode);
    }
    isIdAttribute(attributeNode) {
        if (!attributeNode.name?.children || !attributeNode.value)
            return false;
        return getStaticAttributeName(attributeNode.name) === "id";
    }
    extractIdValue(attributeNode) {
        const valueNodes = attributeNode.value?.children || [];
        if (hasERBOutput(valueNodes) && this.isInControlFlow && this.currentControlFlowType === ControlFlowType.LOOP) {
            return null;
        }
        const identifier = isEffectivelyStatic(valueNodes) ? getValidatableStaticContent(valueNodes) : OutputPrinter.print(valueNodes);
        if (!identifier)
            return null;
        return { identifier, shouldTrackDuplicates: true };
    }
    isWhitespaceOnlyId(identifier) {
        return identifier !== '' && identifier.trim() === '';
    }
    processIdDuplicate(idValue, attributeNode) {
        const { identifier, shouldTrackDuplicates } = idValue;
        if (!shouldTrackDuplicates)
            return;
        if (this.isInControlFlow) {
            this.handleControlFlowId(identifier, attributeNode);
        }
        else {
            this.handleGlobalId(identifier, attributeNode);
        }
    }
    handleControlFlowId(identifier, attributeNode) {
        if (this.currentControlFlowType === ControlFlowType.LOOP) {
            this.handleLoopId(identifier, attributeNode);
        }
        else {
            this.handleConditionalId(identifier, attributeNode);
        }
        this.currentBranchIds.add(identifier);
    }
    handleLoopId(identifier, attributeNode) {
        const isStaticId = this.isStaticId(attributeNode);
        if (isStaticId) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        if (this.currentBranchIds.has(identifier)) {
            this.addSameLoopIterationOffense(identifier, attributeNode.location);
        }
    }
    handleConditionalId(identifier, attributeNode) {
        if (this.currentBranchIds.has(identifier)) {
            this.addSameBranchOffense(identifier, attributeNode.location);
            return;
        }
        if (this.documentIds.has(identifier)) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        this.controlFlowIds.add(identifier);
    }
    handleGlobalId(identifier, attributeNode) {
        if (this.documentIds.has(identifier)) {
            this.addDuplicateIdOffense(identifier, attributeNode.location);
            return;
        }
        this.documentIds.add(identifier);
    }
    isStaticId(attributeNode) {
        const valueNodes = attributeNode.value.children;
        const isCompletelyStatic = valueNodes.every(child => isNode(child, LiteralNode));
        const isEffectivelyStaticValue = isEffectivelyStatic(valueNodes);
        return isCompletelyStatic || isEffectivelyStaticValue;
    }
    addDuplicateIdOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found. IDs must be unique within a document.`, location, "error");
    }
    addSameLoopIterationOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found within the same loop iteration. IDs must be unique within the same loop iteration.`, location, "error");
    }
    addSameBranchOffense(identifier, location) {
        this.addOffense(`Duplicate ID \`${identifier}\` found within the same control flow branch. IDs must be unique within the same control flow branch.`, location, "error");
    }
}
class HTMLNoDuplicateIdsRule extends ParserRule {
    name = "html-no-duplicate-ids";
    check(result, context) {
        const visitor = new NoDuplicateIdsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

// Attributes that must not have empty values
const RESTRICTED_ATTRIBUTES = new Set([
    'id',
    'class',
    'name',
    'for',
    'src',
    'href',
    'title',
    'data',
    'role'
]);
// Check if attribute name matches any restricted patterns
function isRestrictedAttribute(attributeName) {
    // Check direct matches
    if (RESTRICTED_ATTRIBUTES.has(attributeName)) {
        return true;
    }
    // Check for data-* attributes
    if (attributeName.startsWith('data-')) {
        return true;
    }
    // Check for aria-* attributes
    if (attributeName.startsWith('aria-')) {
        return true;
    }
    return false;
}
function isDataAttribute(attributeName) {
    return attributeName.startsWith('data-');
}
class NoEmptyAttributesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        this.checkEmptyAttribute(attributeName, attributeValue, attributeNode);
    }
    checkDynamicAttributeStaticValue({ combinedName, attributeValue, attributeNode }) {
        const name = (combinedName || "").toLowerCase();
        this.checkEmptyAttribute(name, attributeValue, attributeNode);
    }
    checkEmptyAttribute(attributeName, attributeValue, attributeNode) {
        if (!isRestrictedAttribute(attributeName))
            return;
        if (attributeValue.trim() !== "")
            return;
        const hasExplicitValue = attributeNode.value !== null;
        if (isDataAttribute(attributeName)) {
            if (hasExplicitValue) {
                this.addOffense(`Data attribute \`${attributeName}\` should not have an empty value. Either provide a meaningful value or use \`${attributeName}\` instead of \`${IdentityPrinter.print(attributeNode)}\`.`, attributeNode.location, "warning");
            }
            return;
        }
        this.addOffense(`Attribute \`${attributeName}\` must not be empty. Either provide a meaningful value or remove the attribute entirely.`, attributeNode.location, "warning");
    }
}
class HTMLNoEmptyAttributesRule extends ParserRule {
    name = "html-no-empty-attributes";
    check(result, context) {
        const visitor = new NoEmptyAttributesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoEmptyHeadingsVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        this.checkHeadingElement(node);
        super.visitHTMLElementNode(node);
    }
    checkHeadingElement(node) {
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            return;
        }
        const openTag = node.open_tag;
        const tagName = getTagName(openTag);
        if (!tagName) {
            return;
        }
        const isStandardHeading = HEADING_TAGS.has(tagName);
        const isAriaHeading = this.hasHeadingRole(openTag);
        if (!isStandardHeading && !isAriaHeading) {
            return;
        }
        if (this.isEmptyHeading(node)) {
            const elementDescription = isStandardHeading
                ? `\`<${tagName}>\``
                : `\`<${tagName} role="heading">\``;
            this.addOffense(`Heading element ${elementDescription} must not be empty. Provide accessible text content for screen readers and SEO.`, node.location, "error");
        }
    }
    isEmptyHeading(node) {
        if (!node.body || node.body.length === 0) {
            return true;
        }
        // Check if all content is just whitespace or inaccessible
        let hasAccessibleContent = false;
        for (const child of node.body) {
            if (child.type === "AST_LITERAL_NODE") {
                const literalNode = child;
                if (literalNode.content.trim().length > 0) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else if (child.type === "AST_HTML_TEXT_NODE") {
                const textNode = child;
                if (textNode.content.trim().length > 0) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else if (child.type === "AST_HTML_ELEMENT_NODE") {
                const elementNode = child;
                // Check if this element is accessible (not aria-hidden="true")
                if (this.isElementAccessible(elementNode)) {
                    hasAccessibleContent = true;
                    break;
                }
            }
            else {
                // If there's any non-literal/non-text/non-element content (like ERB), consider it accessible
                hasAccessibleContent = true;
                break;
            }
        }
        return !hasAccessibleContent;
    }
    hasHeadingRole(node) {
        const attributes = getAttributes(node);
        const roleAttribute = findAttributeByName(attributes, "role");
        if (!roleAttribute) {
            return false;
        }
        const roleValue = getAttributeValue(roleAttribute);
        return roleValue === "heading";
    }
    isElementAccessible(node) {
        // Check if the element has aria-hidden="true"
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            return true;
        }
        const openTag = node.open_tag;
        const attributes = getAttributes(openTag);
        const ariaHiddenAttribute = findAttributeByName(attributes, "aria-hidden");
        if (ariaHiddenAttribute) {
            const ariaHiddenValue = getAttributeValue(ariaHiddenAttribute);
            if (ariaHiddenValue === "true") {
                return false;
            }
        }
        // Recursively check if the element has any accessible content
        if (!node.body || node.body.length === 0) {
            return false;
        }
        for (const child of node.body) {
            if (child.type === "AST_LITERAL_NODE") {
                const literalNode = child;
                if (literalNode.content.trim().length > 0) {
                    return true;
                }
            }
            else if (child.type === "AST_HTML_TEXT_NODE") {
                const textNode = child;
                if (textNode.content.trim().length > 0) {
                    return true;
                }
            }
            else if (child.type === "AST_HTML_ELEMENT_NODE") {
                const elementNode = child;
                if (this.isElementAccessible(elementNode)) {
                    return true;
                }
            }
            else {
                // If there's any non-literal/non-text/non-element content (like ERB), consider it accessible
                return true;
            }
        }
        return false;
    }
}
class HTMLNoEmptyHeadingsRule extends ParserRule {
    name = "html-no-empty-headings";
    check(result, context) {
        const visitor = new NoEmptyHeadingsVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NestedLinkVisitor extends BaseRuleVisitor {
    linkStack = [];
    checkNestedLink(openTag) {
        if (this.linkStack.length > 0) {
            this.addOffense("Nested `<a>` elements are not allowed. Links cannot contain other links.", openTag.tag_name.location, "error");
            return true;
        }
        return false;
    }
    visitHTMLElementNode(node) {
        if (!node.open_tag || node.open_tag.type !== "AST_HTML_OPEN_TAG_NODE") {
            super.visitHTMLElementNode(node);
            return;
        }
        const openTag = node.open_tag;
        const tagName = getTagName(openTag);
        if (tagName !== "a") {
            super.visitHTMLElementNode(node);
            return;
        }
        // If we're already inside a link, this is a nested link
        this.checkNestedLink(openTag);
        this.linkStack.push(openTag);
        super.visitHTMLElementNode(node);
        this.linkStack.pop();
    }
    // Handle self-closing <a> tags (though they're not valid HTML, they might exist)
    visitHTMLOpenTagNode(node) {
        const tagName = getTagName(node);
        if (tagName === "a" && node.is_void) {
            this.checkNestedLink(node);
        }
        super.visitHTMLOpenTagNode(node);
    }
}
class HTMLNoNestedLinksRule extends ParserRule {
    name = "html-no-nested-links";
    check(result, context) {
        const visitor = new NestedLinkVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoPositiveTabIndexVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeValue, attributeNode }) {
        if (attributeName !== "tabindex")
            return;
        const tabIndexValue = parseInt(attributeValue, 10);
        if (!isNaN(tabIndexValue) && tabIndexValue > 0) {
            this.addOffense(`Do not use positive \`tabindex\` values as they are error prone and can severely disrupt navigation experience for keyboard users. Use \`tabindex="0"\` to make an element focusable or \`tabindex="-1"\` to remove it from the tab sequence.`, attributeNode.location, "error");
        }
    }
}
class HTMLNoPositiveTabIndexRule extends ParserRule {
    name = "html-no-positive-tab-index";
    check(result, context) {
        const visitor = new NoPositiveTabIndexVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class NoSelfClosingVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        if (getTagName$1(node) === "svg") {
            this.visit(node.open_tag);
        }
        else {
            this.visitChildNodes(node);
        }
    }
    visitHTMLOpenTagNode(node) {
        if (node.tag_closing?.value === "/>") {
            const tagName = getTagName$1(node);
            const instead = isVoidElement(tagName) ? `<${tagName}>` : `<${tagName}></${tagName}>`;
            this.addOffense(`Use \`${instead}\` instead of self-closing \`<${tagName} />\` for HTML compatibility.`, node.location, "error");
        }
    }
}
class HTMLNoSelfClosingRule extends ParserRule {
    name = "html-no-self-closing";
    check(result, context) {
        const visitor = new NoSelfClosingVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class XMLDeclarationChecker extends BaseRuleVisitor {
    hasXMLDeclaration = false;
    visitXMLDeclarationNode(_node) {
        this.hasXMLDeclaration = true;
    }
    visitChildNodes(node) {
        if (this.hasXMLDeclaration)
            return;
        super.visitChildNodes(node);
    }
}
class TagNameLowercaseVisitor extends BaseRuleVisitor {
    visitHTMLElementNode(node) {
        if (getTagName$1(node).toLowerCase() === "svg") {
            this.checkTagName(node.open_tag);
            this.checkTagName(node.close_tag);
        }
        else {
            super.visitHTMLElementNode(node);
        }
    }
    visitHTMLOpenTagNode(node) {
        this.checkTagName(node);
    }
    visitHTMLCloseTagNode(node) {
        this.checkTagName(node);
    }
    checkTagName(node) {
        if (!node)
            return;
        const tagName = getTagName$1(node);
        if (!tagName)
            return;
        const lowercaseTagName = tagName.toLowerCase();
        const type = isNode(node, HTMLOpenTagNode) ? "Opening" : "Closing";
        const open = isNode(node, HTMLOpenTagNode) ? "<" : "</";
        if (tagName !== lowercaseTagName) {
            this.addOffense(`${type} tag name \`${open}${tagName}>\` should be lowercase. Use \`${open}${lowercaseTagName}>\` instead.`, node.tag_name.location, "error");
        }
    }
}
class HTMLTagNameLowercaseRule extends ParserRule {
    name = "html-tag-name-lowercase";
    isEnabled(result, context) {
        if (context?.fileName?.endsWith(".xml") || context?.fileName?.endsWith(".xml.erb")) {
            return false;
        }
        const checker = new XMLDeclarationChecker(this.name);
        checker.visit(result.value);
        return !checker.hasXMLDeclaration;
    }
    check(result, context) {
        const visitor = new TagNameLowercaseVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ParserNoErrorsRule extends ParserRule {
    name = "parser-no-errors";
    check(result) {
        return result.recursiveErrors().map(error => this.herbErrorToLintOffense(error));
    }
    herbErrorToLintOffense(error) {
        return {
            message: `${error.message} (\`${error.type}\`)`,
            location: error.location,
            severity: error.severity,
            rule: this.name,
            code: this.name,
            source: "linter"
        };
    }
}

class SVGTagNameCapitalizationVisitor extends BaseRuleVisitor {
    insideSVG = false;
    visitHTMLElementNode(node) {
        const tagName = node.tag_name?.value;
        if (tagName && ["svg"].includes(tagName.toLowerCase())) {
            const wasInsideSVG = this.insideSVG;
            this.insideSVG = true;
            this.visitChildNodes(node);
            this.insideSVG = wasInsideSVG;
            return;
        }
        if (this.insideSVG) {
            if (node.open_tag) {
                this.checkTagName(node.open_tag);
            }
            if (node.close_tag) {
                this.checkTagName(node.close_tag);
            }
        }
        this.visitChildNodes(node);
    }
    checkTagName(node) {
        const tagName = node.tag_name?.value;
        if (!tagName)
            return;
        if (SVG_CAMEL_CASE_ELEMENTS.has(tagName))
            return;
        const lowercaseTagName = tagName.toLowerCase();
        const correctCamelCase = SVG_LOWERCASE_TO_CAMELCASE.get(lowercaseTagName);
        if (correctCamelCase && tagName !== correctCamelCase) {
            let type = node.type;
            if (node.type === "AST_HTML_OPEN_TAG_NODE")
                type = "Opening";
            if (node.type === "AST_HTML_CLOSE_TAG_NODE")
                type = "Closing";
            this.addOffense(`${type} SVG tag name \`${tagName}\` should use proper capitalization. Use \`${correctCamelCase}\` instead.`, node.tag_name.location, "error");
        }
    }
}
class SVGTagNameCapitalizationRule extends ParserRule {
    name = "svg-tag-name-capitalization";
    check(result, context) {
        const visitor = new SVGTagNameCapitalizationVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class HTMLNoUnderscoresInAttributeNamesVisitor extends AttributeVisitorMixin {
    checkStaticAttributeStaticValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    checkStaticAttributeDynamicValue({ attributeName, attributeNode }) {
        this.check(attributeName, attributeNode);
    }
    checkDynamicAttributeStaticValue({ nameNodes, attributeNode }) {
        const attributeName = getStaticContentFromNodes(nameNodes);
        this.check(attributeName, attributeNode);
    }
    checkDynamicAttributeDynamicValue({ nameNodes, attributeNode }) {
        const attributeName = getStaticContentFromNodes(nameNodes);
        this.check(attributeName, attributeNode);
    }
    check(attributeName, attributeNode) {
        if (!attributeName)
            return;
        if (attributeName.includes("_")) {
            this.addOffense(`Attribute \`${IdentityPrinter.print(attributeNode.name)}\` should not contain underscores. Use hyphens (-) instead.`, attributeNode.value.location, "warning");
        }
    }
}
class HTMLNoUnderscoresInAttributeNamesRule extends ParserRule {
    name = "html-no-underscores-in-attribute-names";
    check(result, context) {
        const visitor = new HTMLNoUnderscoresInAttributeNamesVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

class ERBRightTrimVisitor extends BaseRuleVisitor {
    visitERBNode(node) {
        if (!node.tag_closing)
            return;
        const trimClosing = node.tag_closing.value;
        if (trimClosing !== "=%>" && trimClosing !== "-%>")
            return;
        if (!isERBOutputNode(node)) {
            this.addOffense(`Right-trimming with \`${trimClosing}\` has no effect on non-output ERB tags. Use \`%>\` instead`, node.tag_closing.location);
            return;
        }
        if (trimClosing === "=%>") {
            this.addOffense("Use `-%>` instead of `=%>` for right-trimming. The `=%>` syntax is obscure and not well-supported in most ERB engines", node.tag_closing.location);
        }
    }
}
class ERBRightTrimRule extends ParserRule {
    name = "erb-right-trim";
    check(result, context) {
        const visitor = new ERBRightTrimVisitor(this.name, context);
        visitor.visit(result.value);
        return visitor.offenses;
    }
}

const defaultRules = [
    ERBCommentSyntax,
    ERBNoEmptyTagsRule,
    ERBNoOutputControlFlowRule,
    ERBNoSilentTagInAttributeNameRule,
    ERBPreferImageTagHelperRule,
    ERBRequiresTrailingNewlineRule,
    ERBRequireWhitespaceRule,
    HTMLAnchorRequireHrefRule,
    HTMLAriaAttributeMustBeValid,
    HTMLAriaLabelIsWellFormattedRule,
    HTMLAriaLevelMustBeValidRule,
    HTMLAriaRoleHeadingRequiresLevelRule,
    HTMLAriaRoleMustBeValidRule,
    HTMLAttributeDoubleQuotesRule,
    HTMLAttributeEqualsSpacingRule,
    HTMLAttributeValuesRequireQuotesRule,
    HTMLAvoidBothDisabledAndAriaDisabledRule,
    HTMLBooleanAttributesNoValueRule,
    HTMLIframeHasTitleRule,
    HTMLImgRequireAltRule,
    // HTMLNavigationHasLabelRule,
    HTMLNoAriaHiddenOnFocusableRule,
    // HTMLNoBlockInsideInlineRule,
    HTMLNoDuplicateAttributesRule,
    HTMLNoDuplicateIdsRule,
    HTMLNoEmptyAttributesRule,
    HTMLNoEmptyHeadingsRule,
    HTMLNoNestedLinksRule,
    HTMLNoPositiveTabIndexRule,
    HTMLNoSelfClosingRule,
    // HTMLNoTitleAttributeRule,
    HTMLTagNameLowercaseRule,
    ParserNoErrorsRule,
    SVGTagNameCapitalizationRule,
    HTMLNoUnderscoresInAttributeNamesRule,
    ERBRightTrimRule,
];

class Linter {
    rules;
    herb;
    offenses;
    /**
     * Creates a new Linter instance.
     * @param herb - The Herb backend instance for parsing and lexing
     * @param rules - Array of rule classes (Parser/AST or Lexer) to use. If not provided, uses default rules.
     */
    constructor(herb, rules) {
        this.herb = herb;
        this.rules = rules !== undefined ? rules : this.getDefaultRules();
        this.offenses = [];
    }
    /**
     * Returns the default set of rule classes used by the linter.
     * @returns Array of rule classes
     */
    getDefaultRules() {
        return defaultRules;
    }
    getRuleCount() {
        return this.rules.length;
    }
    /**
     * Type guard to check if a rule is a LexerRule
     */
    isLexerRule(rule) {
        return rule.constructor.type === "lexer";
    }
    /**
     * Type guard to check if a rule is a SourceRule
     */
    isSourceRule(rule) {
        return rule.constructor.type === "source";
    }
    /**
     * Lint source code using Parser/AST, Lexer, and Source rules.
     * @param source - The source code to lint
     * @param context - Optional context for linting (e.g., fileName for distinguishing files vs snippets)
     */
    lint(source, context) {
        this.offenses = [];
        const parseResult = this.herb.parse(source, { track_whitespace: true });
        const lexResult = this.herb.lex(source);
        for (const RuleClass of this.rules) {
            const rule = new RuleClass();
            let isEnabled = true;
            let ruleOffenses;
            if (this.isLexerRule(rule)) {
                if (rule.isEnabled) {
                    isEnabled = rule.isEnabled(lexResult, context);
                }
                if (isEnabled) {
                    ruleOffenses = rule.check(lexResult, context);
                }
                else {
                    ruleOffenses = [];
                }
            }
            else if (this.isSourceRule(rule)) {
                if (rule.isEnabled) {
                    isEnabled = rule.isEnabled(source, context);
                }
                if (isEnabled) {
                    ruleOffenses = rule.check(source, context);
                }
                else {
                    ruleOffenses = [];
                }
            }
            else {
                if (rule.isEnabled) {
                    isEnabled = rule.isEnabled(parseResult, context);
                }
                if (isEnabled) {
                    ruleOffenses = rule.check(parseResult, context);
                }
                else {
                    ruleOffenses = [];
                }
            }
            this.offenses.push(...ruleOffenses);
        }
        const errors = this.offenses.filter(offense => offense.severity === "error").length;
        const warnings = this.offenses.filter(offense => offense.severity === "warning").length;
        return {
            offenses: this.offenses,
            errors,
            warnings
        };
    }
}

class FileProcessor {
    linter = null;
    async processFiles(files, formatOption = 'detailed', context) {
        let totalErrors = 0;
        let totalWarnings = 0;
        let filesWithOffenses = 0;
        let ruleCount = 0;
        const allOffenses = [];
        const ruleOffenses = new Map();
        for (const filename of files) {
            const filePath = context?.projectPath ? path$1.resolve(context.projectPath, filename) : path$1.resolve(filename);
            const content = fs.readFileSync(filePath, "utf-8");
            const parseResult = Herb.parse(content);
            if (parseResult.errors.length > 0) {
                if (formatOption !== 'json') {
                    console.error(`${colorize(filename, "cyan")} - ${colorize("Parse errors:", "brightRed")}`);
                    for (const error of parseResult.errors) {
                        console.error(`  ${colorize("", "brightRed")} ${error.message}`);
                    }
                }
                for (const error of parseResult.errors) {
                    allOffenses.push({ filename, offense: error, content });
                }
                totalErrors++;
                filesWithOffenses++;
                continue;
            }
            if (!this.linter) {
                this.linter = new Linter(Herb);
            }
            const lintResult = this.linter.lint(content, { fileName: filename });
            if (ruleCount === 0) {
                ruleCount = this.linter.getRuleCount();
            }
            if (lintResult.offenses.length === 0) {
                if (files.length === 1 && formatOption !== 'json') {
                    console.log(`${colorize("", "brightGreen")} ${colorize(filename, "cyan")} - ${colorize("No issues found", "green")}`);
                }
            }
            else {
                for (const offense of lintResult.offenses) {
                    allOffenses.push({ filename, offense: offense, content });
                    const ruleData = ruleOffenses.get(offense.rule) || { count: 0, files: new Set() };
                    ruleData.count++;
                    ruleData.files.add(filename);
                    ruleOffenses.set(offense.rule, ruleData);
                }
                totalErrors += lintResult.errors;
                totalWarnings += lintResult.warnings;
                filesWithOffenses++;
            }
        }
        return { totalErrors, totalWarnings, filesWithOffenses, ruleCount, allOffenses, ruleOffenses, context };
    }
}

class SummaryReporter {
    pluralize(count, singular, plural) {
        return count === 1 ? singular : (plural || `${singular}s`);
    }
    displaySummary(data) {
        const { files, totalErrors, totalWarnings, filesWithOffenses, ruleCount, startTime, startDate, showTiming } = data;
        console.log("\n");
        console.log(` ${colorize("Summary:", "bold")}`);
        const labelWidth = 12;
        const pad = (label) => label.padEnd(labelWidth);
        console.log(`  ${colorize(pad("Checked"), "gray")} ${colorize(`${files.length} ${this.pluralize(files.length, "file")}`, "cyan")}`);
        if (files.length > 1) {
            const filesChecked = files.length;
            const filesClean = filesChecked - filesWithOffenses;
            let filesSummary = "";
            let shouldDim = false;
            if (filesWithOffenses > 0) {
                filesSummary = `${colorize(colorize(`${filesWithOffenses} with offenses`, "brightRed"), "bold")} | ${colorize(colorize(`${filesClean} clean`, "green"), "bold")} ${colorize(colorize(`(${filesChecked} total)`, "gray"), "dim")}`;
            }
            else {
                filesSummary = `${colorize(colorize(`${filesChecked} clean`, "green"), "bold")} ${colorize(colorize(`(${filesChecked} total)`, "gray"), "dim")}`;
                shouldDim = true;
            }
            if (shouldDim) {
                console.log(colorize(`  ${colorize(pad("Files"), "gray")} ${filesSummary}`, "dim"));
            }
            else {
                console.log(`  ${colorize(pad("Files"), "gray")} ${filesSummary}`);
            }
        }
        let offensesSummary = "";
        const parts = [];
        if (totalErrors > 0) {
            parts.push(colorize(colorize(`${totalErrors} ${this.pluralize(totalErrors, "error")}`, "brightRed"), "bold"));
        }
        if (totalWarnings > 0) {
            parts.push(colorize(colorize(`${totalWarnings} ${this.pluralize(totalWarnings, "warning")}`, "brightYellow"), "bold"));
        }
        else if (totalErrors > 0) {
            parts.push(colorize(colorize(`${totalWarnings} ${this.pluralize(totalWarnings, "warning")}`, "green"), "bold"));
        }
        if (parts.length === 0) {
            offensesSummary = colorize(colorize("0 offenses", "green"), "bold");
        }
        else {
            offensesSummary = parts.join(" | ");
            let detailText = "";
            const totalOffenses = totalErrors + totalWarnings;
            if (filesWithOffenses > 0) {
                detailText = `${totalOffenses} ${this.pluralize(totalOffenses, "offense")} across ${filesWithOffenses} ${this.pluralize(filesWithOffenses, "file")}`;
            }
            offensesSummary += ` ${colorize(colorize(`(${detailText})`, "gray"), "dim")}`;
        }
        console.log(`  ${colorize(pad("Offenses"), "gray")} ${offensesSummary}`);
        if (showTiming) {
            const duration = Date.now() - startTime;
            const timeString = startDate.toTimeString().split(' ')[0];
            console.log(`  ${colorize(pad("Start at"), "gray")} ${colorize(timeString, "cyan")}`);
            console.log(`  ${colorize(pad("Duration"), "gray")} ${colorize(`${duration}ms`, "cyan")} ${colorize(colorize(`(${ruleCount} ${this.pluralize(ruleCount, "rule")})`, "gray"), "dim")}`);
        }
        if (filesWithOffenses === 0 && files.length > 1) {
            console.log("");
            console.log(` ${colorize("", "brightGreen")} ${colorize("All files are clean!", "green")}`);
        }
    }
    displayMostViolatedRules(ruleOffenses, limit = 5) {
        if (ruleOffenses.size === 0)
            return;
        const allRules = Array.from(ruleOffenses.entries()).sort((a, b) => b[1].count - a[1].count);
        const displayedRules = allRules.slice(0, limit);
        const remainingRules = allRules.slice(limit);
        const title = ruleOffenses.size <= limit ? "Rule offenses:" : "Most frequent rule offenses:";
        console.log(` ${colorize(title, "bold")}`);
        for (const [rule, data] of displayedRules) {
            const fileCount = data.files.size;
            const countText = `(${data.count} ${this.pluralize(data.count, "offense")} in ${fileCount} ${this.pluralize(fileCount, "file")})`;
            console.log(`  ${colorize(rule, "gray")} ${colorize(colorize(countText, "gray"), "dim")}`);
        }
        if (remainingRules.length > 0) {
            const remainingOffenseCount = remainingRules.reduce((sum, [_, data]) => sum + data.count, 0);
            const remainingRuleCount = remainingRules.length;
            console.log(colorize(colorize(`\n  ...and ${remainingRuleCount} more ${this.pluralize(remainingRuleCount, "rule")} with ${remainingOffenseCount} ${this.pluralize(remainingOffenseCount, "offense")}`, "gray"), "dim"));
        }
    }
}

class BaseFormatter {
}

class SimpleFormatter extends BaseFormatter {
    async format(allOffenses) {
        if (allOffenses.length === 0)
            return;
        const groupedOffenses = new Map();
        for (const { filename, offense } of allOffenses) {
            const offenses = groupedOffenses.get(filename) || [];
            offenses.push(offense);
            groupedOffenses.set(filename, offenses);
        }
        for (const [filename, offenses] of groupedOffenses) {
            console.log("");
            this.formatFile(filename, offenses);
        }
    }
    formatFile(filename, offenses) {
        console.log(`${colorize(filename, "cyan")}:`);
        for (const offense of offenses) {
            const isError = offense.severity === "error";
            const severity = isError ? colorize("", "brightRed") : colorize("", "brightYellow");
            const rule = colorize(`(${offense.code})`, "blue");
            const locationString = `${offense.location.start.line}:${offense.location.start.column}`;
            const paddedLocation = locationString.padEnd(4); // Pad to 4 characters for alignment
            console.log(`  ${colorize(paddedLocation, "gray")} ${severity} ${offense.message} ${rule}`);
        }
        console.log("");
    }
}

class DetailedFormatter extends BaseFormatter {
    highlighter = null;
    theme;
    wrapLines;
    truncateLines;
    constructor(theme = DEFAULT_THEME, wrapLines = true, truncateLines = false) {
        super();
        this.theme = theme;
        this.wrapLines = wrapLines;
        this.truncateLines = truncateLines;
    }
    async format(allOffenses, isSingleFile = false) {
        if (allOffenses.length === 0)
            return;
        if (!this.highlighter) {
            this.highlighter = new Highlighter(this.theme);
            await this.highlighter.initialize();
        }
        if (isSingleFile) {
            const { filename, content } = allOffenses[0];
            const diagnostics = allOffenses.map(item => item.offense);
            const highlighted = this.highlighter.highlight(filename, content, {
                diagnostics: diagnostics,
                splitDiagnostics: true,
                contextLines: 2,
                wrapLines: this.wrapLines,
                truncateLines: this.truncateLines
            });
            console.log(`\n${highlighted}`);
        }
        else {
            const totalMessageCount = allOffenses.length;
            for (let i = 0; i < allOffenses.length; i++) {
                const { filename, offense, content } = allOffenses[i];
                const formatted = this.highlighter.highlightDiagnostic(filename, offense, content, {
                    contextLines: 2,
                    wrapLines: this.wrapLines,
                    truncateLines: this.truncateLines
                });
                console.log(`\n${formatted}`);
                const width = LineWrapper.getTerminalWidth();
                const progressText = `[${i + 1}/${totalMessageCount}]`;
                const rightPadding = 16;
                const separatorLength = Math.max(0, width - progressText.length - 1 - rightPadding);
                const separator = '';
                const leftSeparator = colorize(separator.repeat(separatorLength), "gray");
                const rightSeparator = colorize(separator.repeat(4), "gray");
                const progress = colorize(progressText, "gray");
                console.log(colorize(`${leftSeparator}  ${progress}`, "dim") + colorize(` ${rightSeparator}\n`, "dim"));
            }
        }
    }
    formatFile(_filename, _offenses) {
        throw new Error("formatFile is not implemented for DetailedFormatter");
    }
}

// https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-commands
class GitHubActionsFormatter extends BaseFormatter {
    highlighter;
    wrapLines;
    truncateLines;
    constructor(wrapLines = true, truncateLines = false) {
        super();
        this.wrapLines = wrapLines;
        this.truncateLines = truncateLines;
        this.highlighter = new Highlighter();
    }
    static MESSAGE_ESCAPE_MAP = {
        '%': '%25',
        '\n': '%0A',
        '\r': '%0D'
    };
    static PARAM_ESCAPE_MAP = {
        '%': '%25',
        '\n': '%0A',
        '\r': '%0D',
        ':': '%3A',
        ',': '%2C'
    };
    async format(allDiagnostics, _isSingleFile = false) {
        await this.formatAnnotations(allDiagnostics);
    }
    async formatAnnotations(allDiagnostics) {
        if (allDiagnostics.length === 0)
            return;
        if (!this.highlighter.initialized) {
            await this.highlighter.initialize();
        }
        for (const { filename, offense, content } of allDiagnostics) {
            const originalNoColor = process.env.NO_COLOR;
            process.env.NO_COLOR = "1";
            let plainCodePreview = "";
            try {
                const formatted = this.highlighter.highlightDiagnostic(filename, offense, content, {
                    contextLines: 2,
                    wrapLines: this.wrapLines,
                    truncateLines: this.truncateLines
                });
                plainCodePreview = formatted.split('\n').slice(1).join('\n');
            }
            finally {
                if (originalNoColor === undefined) {
                    delete process.env.NO_COLOR;
                }
                else {
                    process.env.NO_COLOR = originalNoColor;
                }
            }
            this.formatDiagnostic(filename, offense, plainCodePreview);
        }
    }
    formatFile(filename, diagnostics) {
        for (const diagnostic of diagnostics) {
            this.formatDiagnostic(filename, diagnostic);
        }
    }
    // GitHub Actions annotation format:
    // ::{level} file={file},line={line},col={col},title={title}::{message}
    //
    formatDiagnostic(filename, diagnostic, codePreview = "") {
        const level = diagnostic.severity === "error" ? "error" : "warning";
        const { line, column } = diagnostic.location.start;
        const escapedFilename = this.escapeParam(filename);
        let message = diagnostic.message;
        if (diagnostic.code) {
            message += ` [${diagnostic.code}]`;
        }
        if (codePreview) {
            message += "\n\n" + codePreview;
        }
        const escapedMessage = this.escapeMessage(message);
        let annotations = `file=${escapedFilename},line=${line},col=${column}`;
        if (diagnostic.code) {
            const title = `${diagnostic.code}  ${name}@${version}`;
            const escapedTitle = this.escapeParam(title);
            annotations += `,title=${escapedTitle}`;
        }
        console.log(`\n::${level} ${annotations}::${escapedMessage}`);
    }
    escapeMessage(string) {
        return string.replace(new RegExp(Object.keys(GitHubActionsFormatter.MESSAGE_ESCAPE_MAP).map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'), 'g'), match => GitHubActionsFormatter.MESSAGE_ESCAPE_MAP[match]);
    }
    escapeParam(string) {
        return string.replace(new RegExp(Object.keys(GitHubActionsFormatter.PARAM_ESCAPE_MAP).map(k => k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'), 'g'), match => GitHubActionsFormatter.PARAM_ESCAPE_MAP[match]);
    }
}

class OutputManager {
    summaryReporter = new SummaryReporter();
    /**
     * Output successful lint results
     */
    async outputResults(results, options) {
        const { allOffenses, files, totalErrors, totalWarnings, filesWithOffenses, ruleCount, ruleOffenses } = results;
        if (options.useGitHubActions) {
            const githubFormatter = new GitHubActionsFormatter(options.wrapLines, options.truncateLines);
            await githubFormatter.formatAnnotations(allOffenses);
            if (options.formatOption !== "json") {
                const regularFormatter = options.formatOption === "simple"
                    ? new SimpleFormatter()
                    : new DetailedFormatter(options.theme, options.wrapLines, options.truncateLines);
                await regularFormatter.format(allOffenses, files.length === 1);
                this.summaryReporter.displayMostViolatedRules(ruleOffenses);
                this.summaryReporter.displaySummary({
                    files,
                    totalErrors,
                    totalWarnings,
                    filesWithOffenses,
                    ruleCount,
                    startTime: options.startTime,
                    startDate: options.startDate,
                    showTiming: options.showTiming,
                    ruleOffenses
                });
            }
        }
        else if (options.formatOption === "json") {
            const output = {
                offenses: allOffenses.map(({ filename, offense }) => ({
                    filename,
                    message: offense.message,
                    location: offense.location.toJSON(),
                    severity: offense.severity,
                    code: offense.code,
                    source: offense.source
                })),
                summary: {
                    filesChecked: files.length,
                    filesWithOffenses,
                    totalErrors,
                    totalWarnings,
                    totalOffenses: totalErrors + totalWarnings,
                    ruleCount
                },
                timing: null,
                completed: true,
                clean: totalErrors === 0 && totalWarnings === 0,
                message: null
            };
            const duration = Date.now() - options.startTime;
            output.timing = options.showTiming ? {
                startTime: options.startDate.toISOString(),
                duration: duration
            } : null;
            console.log(JSON.stringify(output, null, 2));
        }
        else {
            const formatter = options.formatOption === "simple"
                ? new SimpleFormatter()
                : new DetailedFormatter(options.theme, options.wrapLines, options.truncateLines);
            await formatter.format(allOffenses, files.length === 1);
            this.summaryReporter.displayMostViolatedRules(ruleOffenses);
            this.summaryReporter.displaySummary({
                files,
                totalErrors,
                totalWarnings,
                filesWithOffenses,
                ruleCount,
                startTime: options.startTime,
                startDate: options.startDate,
                showTiming: options.showTiming,
                ruleOffenses
            });
        }
    }
    /**
     * Output informational message (like "no files found")
     */
    outputInfo(message, options) {
        if (options.useGitHubActions) ;
        else if (options.formatOption === "json") {
            const output = {
                offenses: [],
                summary: {
                    filesChecked: 0,
                    filesWithOffenses: 0,
                    totalErrors: 0,
                    totalWarnings: 0,
                    totalOffenses: 0,
                    ruleCount: 0
                },
                timing: null,
                completed: false,
                clean: null,
                message
            };
            const duration = Date.now() - options.startTime;
            output.timing = options.showTiming ? {
                startTime: options.startDate.toISOString(),
                duration: duration
            } : null;
            console.log(JSON.stringify(output, null, 2));
        }
        else {
            console.log(message);
        }
    }
    /**
     * Output error message
     */
    outputError(message, options) {
        if (options.useGitHubActions) {
            console.log(`::error::${message}`);
        }
        else if (options.formatOption === "json") {
            const output = {
                offenses: [],
                summary: null,
                timing: null,
                completed: false,
                clean: null,
                message
            };
            console.log(JSON.stringify(output, null, 2));
        }
        else {
            console.error(message);
        }
    }
}

class CLI {
    argumentParser = new ArgumentParser();
    fileProcessor = new FileProcessor();
    outputManager = new OutputManager();
    projectPath = process.cwd();
    getProjectPath() {
        return this.projectPath;
    }
    findProjectRoot(startPath) {
        let currentPath = path$1.resolve(startPath);
        if (fs.existsSync(currentPath) && fs.statSync(currentPath).isFile()) {
            currentPath = path$1.dirname(currentPath);
        }
        const projectIndicators = [
            'package.json',
            'Gemfile',
            '.git',
            'tsconfig.json',
            'composer.json',
            'pyproject.toml',
            'requirements.txt',
            '.herb.yml'
        ];
        while (currentPath !== '/') {
            for (const indicator of projectIndicators) {
                if (fs.existsSync(path$1.resolve(currentPath, indicator))) {
                    return currentPath;
                }
            }
            const parentPath = path$1.dirname(currentPath);
            if (parentPath === currentPath) {
                break;
            }
            currentPath = parentPath;
        }
        return fs.existsSync(startPath) && fs.statSync(startPath).isDirectory()
            ? startPath
            : path$1.dirname(startPath);
    }
    exitWithError(message, formatOption, exitCode = 1) {
        this.outputManager.outputError(message, {
            formatOption,
            theme: 'auto',
            wrapLines: false,
            truncateLines: false,
            showTiming: false,
            useGitHubActions: false,
            startTime: 0,
            startDate: new Date()
        });
        process.exit(exitCode);
    }
    exitWithInfo(message, formatOption, exitCode = 0, timingData) {
        const outputOptions = {
            formatOption,
            theme: 'auto',
            wrapLines: false,
            truncateLines: false,
            showTiming: timingData?.showTiming ?? false,
            useGitHubActions: false,
            startTime: timingData?.startTime ?? Date.now(),
            startDate: timingData?.startDate ?? new Date()
        };
        this.outputManager.outputInfo(message, outputOptions);
        process.exit(exitCode);
    }
    determineProjectPath(pattern) {
        if (pattern) {
            const resolvedPattern = path$1.resolve(pattern);
            if (fs.existsSync(resolvedPattern)) {
                const stats = fs.statSync(resolvedPattern);
                if (stats.isDirectory()) {
                    this.projectPath = resolvedPattern;
                }
                else {
                    this.projectPath = this.findProjectRoot(resolvedPattern);
                }
            }
        }
    }
    adjustPattern(pattern) {
        if (!pattern) {
            return '**/*.html.erb';
        }
        const resolvedPattern = path$1.resolve(pattern);
        if (fs.existsSync(resolvedPattern)) {
            const stats = fs.statSync(resolvedPattern);
            if (stats.isDirectory()) {
                return '**/*.html.erb';
            }
            else if (stats.isFile()) {
                return path$1.relative(this.projectPath, resolvedPattern);
            }
        }
        return pattern;
    }
    async beforeProcess() {
        // Hook for subclasses to add custom output before processing
    }
    async afterProcess(_results, _outputOptions) {
        // Hook for subclasses to add custom output after processing
    }
    async run() {
        await Herb.load();
        const startTime = Date.now();
        const startDate = new Date();
        let { pattern, formatOption, showTiming, theme, wrapLines, truncateLines, useGitHubActions } = this.argumentParser.parse(process.argv);
        this.determineProjectPath(pattern);
        pattern = this.adjustPattern(pattern);
        const outputOptions = {
            formatOption,
            theme,
            wrapLines,
            truncateLines,
            showTiming,
            useGitHubActions,
            startTime,
            startDate
        };
        try {
            await this.beforeProcess();
            const files = await glob(pattern, { cwd: this.projectPath });
            if (files.length === 0) {
                this.exitWithInfo(`No files found matching pattern: ${pattern}`, formatOption, 0, { startTime, startDate, showTiming });
            }
            const context = {
                projectPath: this.projectPath,
                pattern: pattern
            };
            const results = await this.fileProcessor.processFiles(files, formatOption, context);
            await this.outputManager.outputResults({ ...results, files }, outputOptions);
            await this.afterProcess(results, outputOptions);
            if (results.totalErrors > 0) {
                process.exit(1);
            }
        }
        catch (error) {
            this.exitWithError(`Error: ${error}`, formatOption);
        }
    }
}

const cli = new CLI();
cli.run();
//# sourceMappingURL=herb-lint.js.map
