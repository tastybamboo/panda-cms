// NOTE: This file is generated by the templates/template.rb script and should not
// be modified manually. See /Users/marcoroth/Development/herb-release-0.7.5/templates/javascript/packages/core/src/errors.ts.erb

import { Location, SerializedLocation } from "./location.js"
import { Token, SerializedToken } from "./token.js"
import { Diagnostic, MonacoDiagnostic } from "./diagnostic.js"

export type HerbErrorType =
  | "UNEXPECTED_ERROR"
  | "UNEXPECTED_TOKEN_ERROR"
  | "MISSING_OPENING_TAG_ERROR"
  | "MISSING_CLOSING_TAG_ERROR"
  | "TAG_NAMES_MISMATCH_ERROR"
  | "QUOTES_MISMATCH_ERROR"
  | "VOID_ELEMENT_CLOSING_TAG_ERROR"
  | "UNCLOSED_ELEMENT_ERROR"
  | "RUBY_PARSE_ERROR"

export type SerializedErrorType = string

export interface SerializedHerbError {
  type: string
  message: string
  location: SerializedLocation
}

export abstract class HerbError implements Diagnostic {
  readonly type: string
  readonly message: string
  readonly location: Location
  readonly severity: "error" | "warning" | "info" | "hint" = "error"
  readonly source: string = "parser"

  get code(): string {
    return this.type
  }

  static from(error: SerializedHerbError): HerbError {
    return fromSerializedError(error)
  }

  constructor(type: string, message: string, location: Location) {
    this.type = type
    this.message = message
    this.location = location
  }

  toJSON(): SerializedHerbError {
    return {
      type: this.type,
      message: this.message,
      location: this.location.toJSON(),
    }
  }

  inspect(): string {
    return this.treeInspect(0)
  }

  abstract treeInspect(indent?: number): string
}

export interface SerializedUnexpectedError {
  type: "UNEXPECTED_ERROR";
  message: string;
  location: SerializedLocation;
  description: string;
  expected: string;
  found: string;
}

export interface UnexpectedErrorProps {
  type: string;
  message: string;
  location: Location;
  description: string;
  expected: string;
  found: string;
}

export class UnexpectedError extends HerbError {
  readonly description: string;
  readonly expected: string;
  readonly found: string;

  static from(data: SerializedUnexpectedError): UnexpectedError {
    return new UnexpectedError({
      type: data.type,
      message: data.message,
      location: Location.from(data.location),
      description: data.description,
      expected: data.expected,
      found: data.found,
    })
  }

  constructor(props: UnexpectedErrorProps) {
    super(props.type, props.message, props.location);

    this.description = props.description;
    this.expected = props.expected;
    this.found = props.found;
  }

  toJSON(): SerializedUnexpectedError {
    return {
      ...super.toJSON(),
      type: "UNEXPECTED_ERROR",
      description: this.description,
      expected: this.expected,
      found: this.found,
    };
  }

  toMonacoDiagnostic(): MonacoDiagnostic {
    return {
      line: this.location.start.line,
      column: this.location.start.column,
      endLine: this.location.end.line,
      endColumn: this.location.end.column,
      message: this.message,
      severity: 'error'
    }
  }

  treeInspect(): string {
    let output = "";

    output += `@ UnexpectedError ${this.location.treeInspectWithLabel()}\n`;
    output += `├── message: "${this.message}"\n`;
    output += `├── description: ${JSON.stringify(this.description)}\n`;
    output += `├── expected: ${JSON.stringify(this.expected)}\n`;
    output += `└── found: ${JSON.stringify(this.found)}\n`;

    return output;
  }
}

export interface SerializedUnexpectedTokenError {
  type: "UNEXPECTED_TOKEN_ERROR";
  message: string;
  location: SerializedLocation;
  expected_type: string | null;
  found: SerializedToken | null;
}

export interface UnexpectedTokenErrorProps {
  type: string;
  message: string;
  location: Location;
  expected_type: string | null;
  found: Token | null;
}

export class UnexpectedTokenError extends HerbError {
  readonly expected_type: string | null;
  readonly found: Token | null;

  static from(data: SerializedUnexpectedTokenError): UnexpectedTokenError {
    return new UnexpectedTokenError({
      type: data.type,
      message: data.message,
      location: Location.from(data.location),
      expected_type: data.expected_type,
      found: data.found ? Token.from(data.found) : null,
    })
  }

  constructor(props: UnexpectedTokenErrorProps) {
    super(props.type, props.message, props.location);

    this.expected_type = props.expected_type;
    this.found = props.found;
  }

  toJSON(): SerializedUnexpectedTokenError {
    return {
      ...super.toJSON(),
      type: "UNEXPECTED_TOKEN_ERROR",
      expected_type: this.expected_type,
      found: this.found ? this.found.toJSON() : null,
    };
  }

  toMonacoDiagnostic(): MonacoDiagnostic {
    return {
      line: this.location.start.line,
      column: this.location.start.column,
      endLine: this.location.end.line,
      endColumn: this.location.end.column,
      message: this.message,
      severity: 'error'
    }
  }

  treeInspect(): string {
    let output = "";

    output += `@ UnexpectedTokenError ${this.location.treeInspectWithLabel()}\n`;
    output += `├── message: "${this.message}"\n`;
    output += `├── expected_type: ${JSON.stringify(this.expected_type)}\n`;
    output += `└── found: ${this.found ? this.found.treeInspect() : "∅"}\n`;

    return output;
  }
}

export interface SerializedMissingOpeningTagError {
  type: "MISSING_OPENING_TAG_ERROR";
  message: string;
  location: SerializedLocation;
  closing_tag: SerializedToken | null;
}

export interface MissingOpeningTagErrorProps {
  type: string;
  message: string;
  location: Location;
  closing_tag: Token | null;
}

export class MissingOpeningTagError extends HerbError {
  readonly closing_tag: Token | null;

  static from(data: SerializedMissingOpeningTagError): MissingOpeningTagError {
    return new MissingOpeningTagError({
      type: data.type,
      message: data.message,
      location: Location.from(data.location),
      closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
    })
  }

  constructor(props: MissingOpeningTagErrorProps) {
    super(props.type, props.message, props.location);

    this.closing_tag = props.closing_tag;
  }

  toJSON(): SerializedMissingOpeningTagError {
    return {
      ...super.toJSON(),
      type: "MISSING_OPENING_TAG_ERROR",
      closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
    };
  }

  toMonacoDiagnostic(): MonacoDiagnostic {
    return {
      line: this.location.start.line,
      column: this.location.start.column,
      endLine: this.location.end.line,
      endColumn: this.location.end.column,
      message: this.message,
      severity: 'error'
    }
  }

  treeInspect(): string {
    let output = "";

    output += `@ MissingOpeningTagError ${this.location.treeInspectWithLabel()}\n`;
    output += `├── message: "${this.message}"\n`;
    output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;

    return output;
  }
}

export interface SerializedMissingClosingTagError {
  type: "MISSING_CLOSING_TAG_ERROR";
  message: string;
  location: SerializedLocation;
  opening_tag: SerializedToken | null;
}

export interface MissingClosingTagErrorProps {
  type: string;
  message: string;
  location: Location;
  opening_tag: Token | null;
}

export class MissingClosingTagError extends HerbError {
  readonly opening_tag: Token | null;

  static from(data: SerializedMissingClosingTagError): MissingClosingTagError {
    return new MissingClosingTagError({
      type: data.type,
      message: data.message,
      location: Location.from(data.location),
      opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
    })
  }

  constructor(props: MissingClosingTagErrorProps) {
    super(props.type, props.message, props.location);

    this.opening_tag = props.opening_tag;
  }

  toJSON(): SerializedMissingClosingTagError {
    return {
      ...super.toJSON(),
      type: "MISSING_CLOSING_TAG_ERROR",
      opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
    };
  }

  toMonacoDiagnostic(): MonacoDiagnostic {
    return {
      line: this.location.start.line,
      column: this.location.start.column,
      endLine: this.location.end.line,
      endColumn: this.location.end.column,
      message: this.message,
      severity: 'error'
    }
  }

  treeInspect(): string {
    let output = "";

    output += `@ MissingClosingTagError ${this.location.treeInspectWithLabel()}\n`;
    output += `├── message: "${this.message}"\n`;
    output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;

    return output;
  }
}

export interface SerializedTagNamesMismatchError {
  type: "TAG_NAMES_MISMATCH_ERROR";
  message: string;
  location: SerializedLocation;
  opening_tag: SerializedToken | null;
  closing_tag: SerializedToken | null;
}

export interface TagNamesMismatchErrorProps {
  type: string;
  message: string;
  location: Location;
  opening_tag: Token | null;
  closing_tag: Token | null;
}

export class TagNamesMismatchError extends HerbError {
  readonly opening_tag: Token | null;
  readonly closing_tag: Token | null;

  static from(data: SerializedTagNamesMismatchError): TagNamesMismatchError {
    return new TagNamesMismatchError({
      type: data.type,
      message: data.message,
      location: Location.from(data.location),
      opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
      closing_tag: data.closing_tag ? Token.from(data.closing_tag) : null,
    })
  }

  constructor(props: TagNamesMismatchErrorProps) {
    super(props.type, props.message, props.location);

    this.opening_tag = props.opening_tag;
    this.closing_tag = props.closing_tag;
  }

  toJSON(): SerializedTagNamesMismatchError {
    return {
      ...super.toJSON(),
      type: "TAG_NAMES_MISMATCH_ERROR",
      opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
      closing_tag: this.closing_tag ? this.closing_tag.toJSON() : null,
    };
  }

  toMonacoDiagnostic(): MonacoDiagnostic {
    return {
      line: this.location.start.line,
      column: this.location.start.column,
      endLine: this.location.end.line,
      endColumn: this.location.end.column,
      message: this.message,
      severity: 'error'
    }
  }

  treeInspect(): string {
    let output = "";

    output += `@ TagNamesMismatchError ${this.location.treeInspectWithLabel()}\n`;
    output += `├── message: "${this.message}"\n`;
    output += `├── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;
    output += `└── closing_tag: ${this.closing_tag ? this.closing_tag.treeInspect() : "∅"}\n`;

    return output;
  }
}

export interface SerializedQuotesMismatchError {
  type: "QUOTES_MISMATCH_ERROR";
  message: string;
  location: SerializedLocation;
  opening_quote: SerializedToken | null;
  closing_quote: SerializedToken | null;
}

export interface QuotesMismatchErrorProps {
  type: string;
  message: string;
  location: Location;
  opening_quote: Token | null;
  closing_quote: Token | null;
}

export class QuotesMismatchError extends HerbError {
  readonly opening_quote: Token | null;
  readonly closing_quote: Token | null;

  static from(data: SerializedQuotesMismatchError): QuotesMismatchError {
    return new QuotesMismatchError({
      type: data.type,
      message: data.message,
      location: Location.from(data.location),
      opening_quote: data.opening_quote ? Token.from(data.opening_quote) : null,
      closing_quote: data.closing_quote ? Token.from(data.closing_quote) : null,
    })
  }

  constructor(props: QuotesMismatchErrorProps) {
    super(props.type, props.message, props.location);

    this.opening_quote = props.opening_quote;
    this.closing_quote = props.closing_quote;
  }

  toJSON(): SerializedQuotesMismatchError {
    return {
      ...super.toJSON(),
      type: "QUOTES_MISMATCH_ERROR",
      opening_quote: this.opening_quote ? this.opening_quote.toJSON() : null,
      closing_quote: this.closing_quote ? this.closing_quote.toJSON() : null,
    };
  }

  toMonacoDiagnostic(): MonacoDiagnostic {
    return {
      line: this.location.start.line,
      column: this.location.start.column,
      endLine: this.location.end.line,
      endColumn: this.location.end.column,
      message: this.message,
      severity: 'error'
    }
  }

  treeInspect(): string {
    let output = "";

    output += `@ QuotesMismatchError ${this.location.treeInspectWithLabel()}\n`;
    output += `├── message: "${this.message}"\n`;
    output += `├── opening_quote: ${this.opening_quote ? this.opening_quote.treeInspect() : "∅"}\n`;
    output += `└── closing_quote: ${this.closing_quote ? this.closing_quote.treeInspect() : "∅"}\n`;

    return output;
  }
}

export interface SerializedVoidElementClosingTagError {
  type: "VOID_ELEMENT_CLOSING_TAG_ERROR";
  message: string;
  location: SerializedLocation;
  tag_name: SerializedToken | null;
  expected: string;
  found: string;
}

export interface VoidElementClosingTagErrorProps {
  type: string;
  message: string;
  location: Location;
  tag_name: Token | null;
  expected: string;
  found: string;
}

export class VoidElementClosingTagError extends HerbError {
  readonly tag_name: Token | null;
  readonly expected: string;
  readonly found: string;

  static from(data: SerializedVoidElementClosingTagError): VoidElementClosingTagError {
    return new VoidElementClosingTagError({
      type: data.type,
      message: data.message,
      location: Location.from(data.location),
      tag_name: data.tag_name ? Token.from(data.tag_name) : null,
      expected: data.expected,
      found: data.found,
    })
  }

  constructor(props: VoidElementClosingTagErrorProps) {
    super(props.type, props.message, props.location);

    this.tag_name = props.tag_name;
    this.expected = props.expected;
    this.found = props.found;
  }

  toJSON(): SerializedVoidElementClosingTagError {
    return {
      ...super.toJSON(),
      type: "VOID_ELEMENT_CLOSING_TAG_ERROR",
      tag_name: this.tag_name ? this.tag_name.toJSON() : null,
      expected: this.expected,
      found: this.found,
    };
  }

  toMonacoDiagnostic(): MonacoDiagnostic {
    return {
      line: this.location.start.line,
      column: this.location.start.column,
      endLine: this.location.end.line,
      endColumn: this.location.end.column,
      message: this.message,
      severity: 'error'
    }
  }

  treeInspect(): string {
    let output = "";

    output += `@ VoidElementClosingTagError ${this.location.treeInspectWithLabel()}\n`;
    output += `├── message: "${this.message}"\n`;
    output += `├── tag_name: ${this.tag_name ? this.tag_name.treeInspect() : "∅"}\n`;
    output += `├── expected: ${JSON.stringify(this.expected)}\n`;
    output += `└── found: ${JSON.stringify(this.found)}\n`;

    return output;
  }
}

export interface SerializedUnclosedElementError {
  type: "UNCLOSED_ELEMENT_ERROR";
  message: string;
  location: SerializedLocation;
  opening_tag: SerializedToken | null;
}

export interface UnclosedElementErrorProps {
  type: string;
  message: string;
  location: Location;
  opening_tag: Token | null;
}

export class UnclosedElementError extends HerbError {
  readonly opening_tag: Token | null;

  static from(data: SerializedUnclosedElementError): UnclosedElementError {
    return new UnclosedElementError({
      type: data.type,
      message: data.message,
      location: Location.from(data.location),
      opening_tag: data.opening_tag ? Token.from(data.opening_tag) : null,
    })
  }

  constructor(props: UnclosedElementErrorProps) {
    super(props.type, props.message, props.location);

    this.opening_tag = props.opening_tag;
  }

  toJSON(): SerializedUnclosedElementError {
    return {
      ...super.toJSON(),
      type: "UNCLOSED_ELEMENT_ERROR",
      opening_tag: this.opening_tag ? this.opening_tag.toJSON() : null,
    };
  }

  toMonacoDiagnostic(): MonacoDiagnostic {
    return {
      line: this.location.start.line,
      column: this.location.start.column,
      endLine: this.location.end.line,
      endColumn: this.location.end.column,
      message: this.message,
      severity: 'error'
    }
  }

  treeInspect(): string {
    let output = "";

    output += `@ UnclosedElementError ${this.location.treeInspectWithLabel()}\n`;
    output += `├── message: "${this.message}"\n`;
    output += `└── opening_tag: ${this.opening_tag ? this.opening_tag.treeInspect() : "∅"}\n`;

    return output;
  }
}

export interface SerializedRubyParseError {
  type: "RUBY_PARSE_ERROR";
  message: string;
  location: SerializedLocation;
  error_message: string;
  diagnostic_id: string;
  level: string;
}

export interface RubyParseErrorProps {
  type: string;
  message: string;
  location: Location;
  error_message: string;
  diagnostic_id: string;
  level: string;
}

export class RubyParseError extends HerbError {
  readonly error_message: string;
  readonly diagnostic_id: string;
  readonly level: string;

  static from(data: SerializedRubyParseError): RubyParseError {
    return new RubyParseError({
      type: data.type,
      message: data.message,
      location: Location.from(data.location),
      error_message: data.error_message,
      diagnostic_id: data.diagnostic_id,
      level: data.level,
    })
  }

  constructor(props: RubyParseErrorProps) {
    super(props.type, props.message, props.location);

    this.error_message = props.error_message;
    this.diagnostic_id = props.diagnostic_id;
    this.level = props.level;
  }

  toJSON(): SerializedRubyParseError {
    return {
      ...super.toJSON(),
      type: "RUBY_PARSE_ERROR",
      error_message: this.error_message,
      diagnostic_id: this.diagnostic_id,
      level: this.level,
    };
  }

  toMonacoDiagnostic(): MonacoDiagnostic {
    return {
      line: this.location.start.line,
      column: this.location.start.column,
      endLine: this.location.end.line,
      endColumn: this.location.end.column,
      message: this.message,
      severity: 'error'
    }
  }

  treeInspect(): string {
    let output = "";

    output += `@ RubyParseError ${this.location.treeInspectWithLabel()}\n`;
    output += `├── message: "${this.message}"\n`;
    output += `├── error_message: ${JSON.stringify(this.error_message)}\n`;
    output += `├── diagnostic_id: ${JSON.stringify(this.diagnostic_id)}\n`;
    output += `└── level: ${JSON.stringify(this.level)}\n`;

    return output;
  }
}


export function fromSerializedError(error: SerializedHerbError): HerbError {
  switch (error.type) {
    case "UNEXPECTED_ERROR": return UnexpectedError.from(error as SerializedUnexpectedError);
    case "UNEXPECTED_TOKEN_ERROR": return UnexpectedTokenError.from(error as SerializedUnexpectedTokenError);
    case "MISSING_OPENING_TAG_ERROR": return MissingOpeningTagError.from(error as SerializedMissingOpeningTagError);
    case "MISSING_CLOSING_TAG_ERROR": return MissingClosingTagError.from(error as SerializedMissingClosingTagError);
    case "TAG_NAMES_MISMATCH_ERROR": return TagNamesMismatchError.from(error as SerializedTagNamesMismatchError);
    case "QUOTES_MISMATCH_ERROR": return QuotesMismatchError.from(error as SerializedQuotesMismatchError);
    case "VOID_ELEMENT_CLOSING_TAG_ERROR": return VoidElementClosingTagError.from(error as SerializedVoidElementClosingTagError);
    case "UNCLOSED_ELEMENT_ERROR": return UnclosedElementError.from(error as SerializedUnclosedElementError);
    case "RUBY_PARSE_ERROR": return RubyParseError.from(error as SerializedRubyParseError);

    default:
      throw new Error(`Unknown node type: ${error.type}`);
  }
}
